/**
 * NIP-17 Live Relay Integration Tests
 * 
 * Tests against REAL Nostr relay (ws://umbrel.local:4848) with:
 * - 3 real participants: Alice, Bob, Charlie
 * - Real WebSocket connections and subscriptions
 * - Real NIP-17 gift wrap events published to relay
 * - Multi-participant chat where everyone sends and receives
 * - Complete interoperability validation
 * 
 * This validates that our NIP-17 implementation works with real Nostr infrastructure
 * and is compatible with other Nostr clients.
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { NostrUnchained } from '../../src/core/NostrUnchained.js';
import type { DMMessage } from '../../src/dm/conversation/DMConversation.js';

// We'll get real pubkeys from the TemporarySigner instances at runtime
// No more hardcoded test keys - everything is generated with real crypto

// Test relay configuration
const LIVE_RELAY_URL = 'ws://umbrel.local:4848';
const TEST_TIMEOUT = 30000; // 30 seconds for real network operations

// Import REAL signing from the codebase - NO MOCKS!
import { TemporarySigner } from '../../src/crypto/SigningProvider.js';

// Helper to wait for condition with timeout
async function waitForCondition<T>(
  checkFn: () => T | Promise<T>,
  timeoutMs: number = 10000,
  intervalMs: number = 100
): Promise<T> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeoutMs) {
    try {
      const result = await checkFn();
      if (result) {
        return result;
      }
    } catch (error) {
      // Continue trying
    }
    await new Promise(resolve => setTimeout(resolve, intervalMs));
  }
  
  throw new Error(`Condition not met within ${timeoutMs}ms`);
}

// Helper to collect messages over time
async function collectMessagesForDuration(
  conversation: any,
  durationMs: number = 5000
): Promise<DMMessage[]> {
  const messages: DMMessage[] = [];
  
  const unsubscribe = conversation.messages.subscribe((msgs: DMMessage[]) => {
    messages.length = 0;
    messages.push(...msgs);
  });

  await new Promise(resolve => setTimeout(resolve, durationMs));
  unsubscribe();
  
  return [...messages];
}

describe('NIP-17 Live Relay Integration', () => {
  let alice: NostrUnchained;
  let bob: NostrUnchained;
  let charlie: NostrUnchained;
  let alicePubkey: string;
  let bobPubkey: string;
  let charliePubkey: string;

  beforeAll(async () => {
    console.log(`🔗 Testing against live relay: ${LIVE_RELAY_URL}`);
    console.log('⚠️  Make sure your Umbrel relay is running and accessible');
  }, TEST_TIMEOUT);

  beforeEach(async () => {
    // Create real NostrUnchained instances
    alice = new NostrUnchained({ 
      relays: [LIVE_RELAY_URL],
      debug: true
    });
    
    bob = new NostrUnchained({ 
      relays: [LIVE_RELAY_URL],
      debug: true 
    });
    
    charlie = new NostrUnchained({ 
      relays: [LIVE_RELAY_URL],
      debug: true 
    });

    // Set up REAL signing providers with proper secp256k1 cryptography
    // Each participant gets their own TemporarySigner with real signatures
    (alice as any).signingProvider = new TemporarySigner();
    (bob as any).signingProvider = new TemporarySigner();
    (charlie as any).signingProvider = new TemporarySigner();

    // Initialize DM modules with real signing and get real pubkeys
    await alice.dm.updateSigningProvider((alice as any).signingProvider);
    await bob.dm.updateSigningProvider((bob as any).signingProvider);
    await charlie.dm.updateSigningProvider((charlie as any).signingProvider);

    // Get the REAL public keys generated by TemporarySigner
    alicePubkey = await (alice as any).signingProvider.getPublicKey();
    bobPubkey = await (bob as any).signingProvider.getPublicKey();
    charliePubkey = await (charlie as any).signingProvider.getPublicKey();

    console.log(`🔑 Alice pubkey: ${alicePubkey}`);
    console.log(`🔑 Bob pubkey: ${bobPubkey}`);
    console.log(`🔑 Charlie pubkey: ${charliePubkey}`);

    // Connect to relay
    console.log('🔌 Connecting to relay...');
    await Promise.all([
      alice.connect(),
      bob.connect(),
      charlie.connect()
    ]);

    // Wait for connections to stabilize
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log('✅ Connected to relay');
  }, TEST_TIMEOUT);

  afterEach(async () => {
    // Clean up connections
    await Promise.all([
      alice?.disconnect(),
      bob?.disconnect(),
      charlie?.disconnect()
    ]);
    
    console.log('🔌 Disconnected from relay');
  }, TEST_TIMEOUT);

  describe('1:1 Conversation with Live Relay', () => {
    it('should send and receive DM between Alice and Bob', async () => {
      console.log('📱 Testing 1:1 conversation: Alice → Bob');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      const bobConversation = await bob.dm.with(alicePubkey);

      // Start Bob's inbox subscription
      await bob.dm.startInboxSubscription();
      
      // Wait for subscriptions to be active
      await waitForCondition(async () => {
        const aliceStatus = await new Promise(resolve => 
          aliceConversation.status.subscribe(status => resolve(status))
        );
        const bobStatus = await new Promise(resolve => 
          bobConversation.status.subscribe(status => resolve(status))
        );
        return aliceStatus === 'active' && bobStatus === 'active';
      }, 10000);

      console.log('📡 Subscriptions active, sending message...');

      // Alice sends message to Bob
      const testMessage = `Hello Bob! Live test at ${new Date().toISOString()}`;
      const sendResult = await aliceConversation.send(testMessage);
      
      expect(sendResult.success).toBe(true);
      console.log(`✅ Alice sent message: "${testMessage}"`);

      // Wait for Bob to receive the message
      console.log('⏳ Waiting for Bob to receive message...');
      
      const bobMessages = await waitForCondition(async () => {
        return new Promise<DMMessage[]>(resolve => {
          bobConversation.messages.subscribe(messages => {
            if (messages.length > 0) {
              resolve(messages);
            }
          });
        });
      }, 15000);

      expect(bobMessages).toHaveLength(1);
      expect(bobMessages[0].content).toBe(testMessage);
      expect(bobMessages[0].senderPubkey).toBe(alicePubkey);
      expect(bobMessages[0].isFromMe).toBe(false);
      expect(bobMessages[0].status).toBe('received');

      console.log(`✅ Bob received message: "${bobMessages[0].content}"`);
    }, TEST_TIMEOUT);

    it('should handle bidirectional conversation', async () => {
      console.log('📱 Testing bidirectional conversation: Alice ↔ Bob');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      const bobConversation = await bob.dm.with(alicePubkey);

      // Start inbox subscriptions
      await Promise.all([
        alice.dm.startInboxSubscription(),
        bob.dm.startInboxSubscription()
      ]);

      // Wait for both to be active
      await waitForCondition(async () => {
        const aliceActive = await new Promise(resolve => 
          aliceConversation.status.subscribe(s => resolve(s === 'active'))
        );
        const bobActive = await new Promise(resolve => 
          bobConversation.status.subscribe(s => resolve(s === 'active'))
        );
        return aliceActive && bobActive;
      });

      // Alice sends first message
      const aliceMessage = `Hi Bob! Bidirectional test ${Date.now()}`;
      await aliceConversation.send(aliceMessage);
      console.log(`Alice → Bob: "${aliceMessage}"`);

      // Wait for Bob to receive Alice's message
      await waitForCondition(async () => {
        return new Promise(resolve => {
          bobConversation.messages.subscribe(messages => {
            resolve(messages.some(m => m.content === aliceMessage));
          });
        });
      });

      // Bob replies
      const bobMessage = `Hi Alice! Got your message. Replying at ${Date.now()}`;
      await bobConversation.send(bobMessage);
      console.log(`Bob → Alice: "${bobMessage}"`);

      // Wait for Alice to receive Bob's reply
      await waitForCondition(async () => {
        return new Promise(resolve => {
          aliceConversation.messages.subscribe(messages => {
            resolve(messages.some(m => m.content === bobMessage && !m.isFromMe));
          });
        });
      });

      // Verify both sides have complete conversation
      const finalAliceMessages = await new Promise<DMMessage[]>(resolve => 
        aliceConversation.messages.subscribe(resolve)
      );
      const finalBobMessages = await new Promise<DMMessage[]>(resolve => 
        bobConversation.messages.subscribe(resolve)
      );

      expect(finalAliceMessages).toHaveLength(2);
      expect(finalBobMessages).toHaveLength(2);

      console.log('✅ Bidirectional conversation successful');
    }, TEST_TIMEOUT);
  });

  describe('Multi-participant Room with Live Relay', () => {
    it('should handle 3-way group chat where everyone sends and receives', async () => {
      console.log('👥 Testing 3-way group chat: Alice, Bob, Charlie');
      
      // Create rooms for each participant
      const aliceRoom = await alice.dm.room(
        [bobPubkey, charliePubkey], 
        { subject: 'Live Test Room' }
      );
      const bobRoom = await bob.dm.room(
        [alicePubkey, charliePubkey], 
        { subject: 'Live Test Room' }
      );
      const charlieRoom = await charlie.dm.room(
        [alicePubkey, bobPubkey], 
        { subject: 'Live Test Room' }
      );

      // Start inbox subscriptions for all
      await Promise.all([
        alice.dm.startInboxSubscription(),
        bob.dm.startInboxSubscription(),
        charlie.dm.startInboxSubscription()
      ]);

      // Wait for all rooms to be active
      await waitForCondition(async () => {
        const statuses = await Promise.all([
          new Promise(resolve => aliceRoom.status.subscribe(resolve)),
          new Promise(resolve => bobRoom.status.subscribe(resolve)),
          new Promise(resolve => charlieRoom.status.subscribe(resolve))
        ]);
        return statuses.every(s => s === 'active');
      });

      console.log('📡 All room subscriptions active');

      // Each participant sends a message
      const timestamp = Date.now();
      const messages = {
        alice: `Alice here! Group test ${timestamp}`,
        bob: `Bob joining the conversation ${timestamp}`,
        charlie: `Charlie ready for group chat ${timestamp}`
      };

      // Send messages with delays to avoid race conditions
      console.log(`Alice → Group: "${messages.alice}"`);
      await aliceRoom.send(messages.alice);
      await new Promise(resolve => setTimeout(resolve, 2000));

      console.log(`Bob → Group: "${messages.bob}"`);
      await bobRoom.send(messages.bob);
      await new Promise(resolve => setTimeout(resolve, 2000));

      console.log(`Charlie → Group: "${messages.charlie}"`);
      await charlieRoom.send(messages.charlie);
      
      // Wait for all messages to propagate
      console.log('⏳ Waiting for all messages to propagate...');
      await new Promise(resolve => setTimeout(resolve, 5000));

      // Collect final messages from all participants
      const aliceMessages = await collectMessagesForDuration(aliceRoom);
      const bobMessages = await collectMessagesForDuration(bobRoom);
      const charlieMessages = await collectMessagesForDuration(charlieRoom);

      console.log(`Alice sees ${aliceMessages.length} messages`);
      console.log(`Bob sees ${bobMessages.length} messages`);
      console.log(`Charlie sees ${charlieMessages.length} messages`);

      // Each participant should see messages from the other two
      // (their own messages appear as sent, others as received)
      
      // Alice should see Bob's and Charlie's messages
      const aliceReceivedFromBob = aliceMessages.find(m => 
        m.content === messages.bob && m.senderPubkey === bobPubkey
      );
      const aliceReceivedFromCharlie = aliceMessages.find(m => 
        m.content === messages.charlie && m.senderPubkey === charliePubkey
      );

      expect(aliceReceivedFromBob).toBeDefined();
      expect(aliceReceivedFromCharlie).toBeDefined();

      // Bob should see Alice's and Charlie's messages
      const bobReceivedFromAlice = bobMessages.find(m => 
        m.content === messages.alice && m.senderPubkey === alicePubkey
      );
      const bobReceivedFromCharlie = bobMessages.find(m => 
        m.content === messages.charlie && m.senderPubkey === charliePubkey
      );

      expect(bobReceivedFromAlice).toBeDefined();
      expect(bobReceivedFromCharlie).toBeDefined();

      // Charlie should see Alice's and Bob's messages
      const charlieReceivedFromAlice = charlieMessages.find(m => 
        m.content === messages.alice && m.senderPubkey === alicePubkey
      );
      const charlieReceivedFromBob = charlieMessages.find(m => 
        m.content === messages.bob && m.senderPubkey === bobPubkey
      );

      expect(charlieReceivedFromAlice).toBeDefined();
      expect(charlieReceivedFromBob).toBeDefined();

      console.log('✅ 3-way group chat successful - everyone sent and received!');

      // Log message details for verification
      console.log('\n📋 Final message summary:');
      console.log(`Alice sent: "${messages.alice}"`);
      console.log(`Bob sent: "${messages.bob}"`);
      console.log(`Charlie sent: "${messages.charlie}"`);
      console.log('\n✅ All participants successfully communicated in group chat');
    }, TEST_TIMEOUT);

    it('should handle room participant updates in live environment', async () => {
      console.log('👥 Testing dynamic participant management');
      
      // Start with Alice and Bob
      const aliceRoom = await alice.dm.room([bobPubkey], { 
        subject: 'Dynamic Room Test' 
      });

      // Verify initial participants
      const initialParticipants = await new Promise<string[]>(resolve => 
        aliceRoom.participants.subscribe(resolve)
      );

      expect(initialParticipants).toContain(alicePubkey);
      expect(initialParticipants).toContain(bobPubkey);
      expect(initialParticipants).toHaveLength(2);

      // Add Charlie
      const addResult = await aliceRoom.addParticipant(charliePubkey);
      expect(addResult.success).toBe(true);

      // Verify Charlie was added
      const updatedParticipants = await new Promise<string[]>(resolve => 
        aliceRoom.participants.subscribe(resolve)
      );

      expect(updatedParticipants).toContain(charliePubkey);
      expect(updatedParticipants).toHaveLength(3);

      console.log('✅ Dynamic participant management works');
    }, TEST_TIMEOUT);
  });

  describe('NIP-17 Protocol Compliance on Live Relay', () => {
    it('should publish correctly formatted gift wrap events', async () => {
      console.log('🔍 Testing NIP-17 protocol compliance');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      
      // Send a message
      const testMessage = `Protocol compliance test ${Date.now()}`;
      const sendResult = await aliceConversation.send(testMessage);
      
      expect(sendResult.success).toBe(true);
      
      // The gift wrap should be published to the relay
      // We can't directly inspect relay events, but successful send indicates
      // proper NIP-17 format was accepted by the relay
      
      console.log('✅ Gift wrap event successfully published to live relay');
    }, TEST_TIMEOUT);

    it('should handle subject-based message threading', async () => {
      console.log('🧵 Testing subject-based threading');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      const bobConversation = await bob.dm.with(alicePubkey);

      await bob.dm.startInboxSubscription();

      // Send message with specific subject
      const subject = `Test Subject ${Date.now()}`;
      const message = 'Message with subject threading';
      
      await aliceConversation.send(message, subject);

      // Wait for Bob to receive
      const bobMessages = await waitForCondition(async () => {
        return new Promise<DMMessage[]>(resolve => {
          bobConversation.messages.subscribe(messages => {
            if (messages.length > 0) resolve(messages);
          });
        });
      });

      expect(bobMessages[0].subject).toBe(subject);
      console.log(`✅ Subject preserved: "${subject}"`);
    }, TEST_TIMEOUT);
  });

  describe('Error Handling with Live Relay', () => {
    it('should handle network connectivity issues gracefully', async () => {
      console.log('🌐 Testing network error handling');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      
      // Disconnect from relay
      await alice.disconnect();
      
      // Try to send message while disconnected
      const sendResult = await aliceConversation.send('This should fail');
      
      // Should handle gracefully (might succeed if buffered or fail cleanly)
      expect(typeof sendResult.success).toBe('boolean');
      
      console.log('✅ Network error handled gracefully');
    }, TEST_TIMEOUT);

    it('should recover from temporary connection loss', async () => {
      console.log('🔄 Testing connection recovery');
      
      const aliceConversation = await alice.dm.with(bobPubkey);
      
      // Disconnect and reconnect
      await alice.disconnect();
      await new Promise(resolve => setTimeout(resolve, 1000));
      await alice.connect();
      
      // Should be able to send after reconnection
      const sendResult = await aliceConversation.send(`Recovery test ${Date.now()}`);
      expect(sendResult.success).toBe(true);
      
      console.log('✅ Connection recovery successful');
    }, TEST_TIMEOUT);
  });
});