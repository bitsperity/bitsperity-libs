"use strict";var rt=Object.create;var Ae=Object.defineProperty;var at=Object.getOwnPropertyDescriptor;var ot=Object.getOwnPropertyNames;var ct=Object.getPrototypeOf,lt=Object.prototype.hasOwnProperty;var ut=(a,e,t)=>e in a?Ae(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var ht=(a,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ot(e))!lt.call(a,i)&&i!==t&&Ae(a,i,{get:()=>e[i],enumerable:!(s=at(e,i))||s.enumerable});return a};var gt=(a,e,t)=>(t=a!=null?rt(ct(a)):{},ht(e||!a||!a.__esModule?Ae(t,"default",{value:a,enumerable:!0}):t,a));var h=(a,e,t)=>ut(a,typeof e!="symbol"?e+"":e,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Ge=require("@noble/secp256k1");function dt(a){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const t in a)if(t!=="default"){const s=Object.getOwnPropertyDescriptor(a,t);Object.defineProperty(e,t,s.get?s:{enumerable:!0,get:()=>a[t]})}}return e.default=a,Object.freeze(e)}const se=dt(Ge),ae=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ft(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&a.constructor.name==="Uint8Array"}function Ne(a){if(!Number.isSafeInteger(a)||a<0)throw new Error("positive integer expected, got "+a)}function pe(a,...e){if(!ft(a))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(a.length))throw new Error("Uint8Array expected of length "+e+", got length="+a.length)}function Oe(a){if(typeof a!="function"||typeof a.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Ne(a.outputLen),Ne(a.blockLen)}function _e(a,e=!0){if(a.destroyed)throw new Error("Hash instance has been destroyed");if(e&&a.finished)throw new Error("Hash#digest() has already been called")}function pt(a,e){pe(a);const t=e.outputLen;if(a.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function ue(...a){for(let e=0;e<a.length;e++)a[e].fill(0)}function Te(a){return new DataView(a.buffer,a.byteOffset,a.byteLength)}function X(a,e){return a<<32-e|a>>>e}const yt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",bt=Array.from({length:256},(a,e)=>e.toString(16).padStart(2,"0"));function me(a){if(pe(a),yt)return a.toHex();let e="";for(let t=0;t<a.length;t++)e+=bt[a[t]];return e}function mt(a){if(typeof a!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(a))}function he(a){return typeof a=="string"&&(a=mt(a)),pe(a),a}class He{}function wt(a){const e=s=>a().update(he(s)).digest(),t=a();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>a(),e}function oe(a=32){if(ae&&typeof ae.getRandomValues=="function")return ae.getRandomValues(new Uint8Array(a));if(ae&&typeof ae.randomBytes=="function")return Uint8Array.from(ae.randomBytes(a));throw new Error("crypto.getRandomValues must be defined")}function Et(a,e,t,s){if(typeof a.setBigUint64=="function")return a.setBigUint64(e,t,s);const i=BigInt(32),n=BigInt(4294967295),r=Number(t>>i&n),o=Number(t&n),c=s?4:0,l=s?0:4;a.setUint32(e+c,r,s),a.setUint32(e+l,o,s)}function vt(a,e,t){return a&e^~a&t}function Mt(a,e,t){return a&e^a&t^e&t}class _t extends He{constructor(e,t,s,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=i,this.buffer=new Uint8Array(e),this.view=Te(this.buffer)}update(e){_e(this),e=he(e),pe(e);const{view:t,buffer:s,blockLen:i}=this,n=e.length;for(let r=0;r<n;){const o=Math.min(i-this.pos,n-r);if(o===i){const c=Te(e);for(;i<=n-r;r+=i)this.process(c,r);continue}s.set(e.subarray(r,r+o),this.pos),this.pos+=o,r+=o,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){_e(this),pt(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:i,isLE:n}=this;let{pos:r}=this;t[r++]=128,ue(this.buffer.subarray(r)),this.padOffset>i-r&&(this.process(s,0),r=0);for(let g=r;g<i;g++)t[g]=0;Et(s,i-8,BigInt(this.length*8),n),this.process(s,0);const o=Te(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<l;g++)o.setUint32(4*g,u[g],n)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:i,finished:n,destroyed:r,pos:o}=this;return e.destroyed=r,e.finished=n,e.length=i,e.pos=o,i%t&&e.buffer.set(s),e}clone(){return this._cloneInto()}}const Q=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),It=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),q=new Uint32Array(64);class St extends _t{constructor(e=32){super(64,e,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:e,B:t,C:s,D:i,E:n,F:r,G:o,H:c}=this;return[e,t,s,i,n,r,o,c]}set(e,t,s,i,n,r,o,c){this.A=e|0,this.B=t|0,this.C=s|0,this.D=i|0,this.E=n|0,this.F=r|0,this.G=o|0,this.H=c|0}process(e,t){for(let g=0;g<16;g++,t+=4)q[g]=e.getUint32(t,!1);for(let g=16;g<64;g++){const d=q[g-15],p=q[g-2],f=X(d,7)^X(d,18)^d>>>3,w=X(p,17)^X(p,19)^p>>>10;q[g]=w+q[g-7]+f+q[g-16]|0}let{A:s,B:i,C:n,D:r,E:o,F:c,G:l,H:u}=this;for(let g=0;g<64;g++){const d=X(o,6)^X(o,11)^X(o,25),p=u+d+vt(o,c,l)+It[g]+q[g]|0,w=(X(s,2)^X(s,13)^X(s,22))+Mt(s,i,n)|0;u=l,l=c,c=o,o=r+p|0,r=n,n=i,i=s,s=p+w|0}s=s+this.A|0,i=i+this.B|0,n=n+this.C|0,r=r+this.D|0,o=o+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(s,i,n,r,o,c,l,u)}roundClean(){ue(q)}destroy(){this.set(0,0,0,0,0,0,0,0),ue(this.buffer)}}const Pt=wt(()=>new St),ie=Pt,Be=["ws://umbrel.local:4848","wss://relay.damus.io"],ee={RELAY_TIMEOUT:1e4,PUBLISH_TIMEOUT:3e4,RETRY_ATTEMPTS:3,RETRY_DELAY:1e3,MAX_CONTENT_LENGTH:8192,CONNECTION_TIMEOUT:1e4},Ce={METADATA:0,TEXT_NOTE:1,RECOMMEND_SERVER:2,CONTACT_LIST:3,ENCRYPTED_DM:4,DELETE:5},N={EMPTY_CONTENT:"Content cannot be empty",CONTENT_TOO_LONG:"Content too long",NO_RELAYS:"No relays configured",CONNECTION_FAILED:"Failed to connect to relay",SIGNING_FAILED:"Failed to sign event",PUBLISH_FAILED:"Failed to publish to any relay",NO_EXTENSION:"No browser extension available",INVALID_EVENT:"Invalid event structure"},le={EMPTY_CONTENT:"Add some content to your message",CONTENT_TOO_LONG:`Keep your message under ${ee.MAX_CONTENT_LENGTH} characters`,CONNECTION_FAILED:"Check your internet connection and try again",NO_EXTENSION:"Install a Nostr browser extension or the library will use a temporary key",PUBLISH_FAILED:"Try again or check if your relays are accessible"},we={HEX_64:/^[a-f0-9]{64}$/,HEX_128:/^[a-f0-9]{128}$/,WEBSOCKET_URL:/^wss?:\/\/.+/};class C{static createTextNote(e,t){return{pubkey:t,created_at:Math.floor(Date.now()/1e3),kind:Ce.TEXT_NOTE,tags:[],content:e}}static calculateEventId(e){const t=JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]),s=new TextEncoder().encode(t),i=ie(s);return me(i)}static addEventId(e){const t=C.calculateEventId(e);return{...e,id:t}}static validateEvent(e){const t=[];if(e.pubkey||t.push("Missing pubkey"),e.created_at||t.push("Missing created_at"),typeof e.kind!="number"&&t.push("Missing or invalid kind"),Array.isArray(e.tags)||t.push("Missing or invalid tags"),typeof e.content!="string"&&t.push("Missing or invalid content"),e.pubkey&&!we.HEX_64.test(e.pubkey)&&t.push("Invalid pubkey format (must be 64-character hex string)"),e.id&&!we.HEX_64.test(e.id)&&t.push("Invalid event ID format (must be 64-character hex string)"),e.sig&&!we.HEX_128.test(e.sig)&&t.push("Invalid signature format (must be 128-character hex string)"),e.content===""&&t.push(N.EMPTY_CONTENT),e.content&&e.content.length>ee.MAX_CONTENT_LENGTH&&t.push(N.CONTENT_TOO_LONG),e.created_at){const s=Math.floor(Date.now()/1e3),i=s-3600,n=s+3600;(e.created_at<i||e.created_at>n)&&t.push("Timestamp is too far in the past or future")}return e.tags&&(Array.isArray(e.tags)?e.tags.forEach((s,i)=>{Array.isArray(s)?s.forEach((n,r)=>{typeof n!="string"&&t.push(`Tag ${i}[${r}] must be a string`)}):t.push(`Tag ${i} must be an array`)}):t.push("Tags must be an array")),{valid:t.length===0,errors:t}}static validateContent(e){const t=[];return e===""&&t.push(N.EMPTY_CONTENT),e.length>ee.MAX_CONTENT_LENGTH&&t.push(N.CONTENT_TOO_LONG),{valid:t.length===0,errors:t}}static verifyEventId(e){return C.calculateEventId({pubkey:e.pubkey,created_at:e.created_at,kind:e.kind,tags:e.tags,content:e.content})===e.id}static async createEvent(e,t,s={}){const i=C.validateContent(e);if(!i.valid)throw new Error(`Invalid content: ${i.errors.join(", ")}`);const n={pubkey:t,created_at:s.created_at??Math.floor(Date.now()/1e3),kind:s.kind??Ce.TEXT_NOTE,tags:s.tags??[],content:e},r=C.validateEvent(n);if(!r.valid)throw new Error(`Invalid event: ${r.errors.join(", ")}`);return n}}async function At(){if(typeof WebSocket<"u")return WebSocket;try{return(await import("ws")).default}catch{throw new Error("WebSocket not available. In Node.js, install: npm install ws")}}class ze{constructor(e,t={}){h(this,"connections",new Map);h(this,"debug");h(this,"messageHandler");h(this,"pendingPublishes",new Map);this.debug=t.debug??!1,e.forEach(s=>{this.connections.set(s,{url:s,state:"disconnected"})})}get relayUrls(){return Array.from(this.connections.keys())}get connectedRelays(){return Array.from(this.connections.entries()).filter(([e,t])=>t.state==="connected").map(([e,t])=>e)}async connect(){const e=this.relayUrls.map(t=>this.connectToRelay(t).catch(s=>(this.debug&&console.warn(`Failed to connect to ${t}:`,s),!1)));if(await Promise.allSettled(e),this.connectedRelays.length===0)throw new Error("Failed to connect to any relay")}async connectToRelay(e){const t=this.connections.get(e);if(!t)throw new Error(`Relay ${e} not configured`);return t.state==="connected"?!0:(t.state="connecting",new Promise(async(s,i)=>{try{const n=await At(),r=new n(e),o=setTimeout(()=>{r.close(),t.state="error",t.error="Connection timeout",i(new Error(`Connection to ${e} timed out`))},ee.CONNECTION_TIMEOUT);r.onopen=()=>{clearTimeout(o),t.ws=r,t.state="connected",t.lastConnected=Date.now(),t.error=void 0,this.debug&&console.log(`Connected to relay: ${e}`),s(!0)},r.onerror=c=>{clearTimeout(o),t.state="error",t.error="WebSocket error",this.debug&&console.error(`WebSocket error for ${e}:`,c),i(new Error(`Failed to connect to ${e}: WebSocket error`))},r.onclose=()=>{t.state="disconnected",t.ws=void 0,this.debug&&console.log(`Disconnected from relay: ${e}`)},r.onmessage=c=>{this.handleRelayMessage(e,c.data)}}catch(n){t.state="error",t.error=n instanceof Error?n.message:"Unknown error",i(n)}}))}async publishToAll(e){const t=[],s=this.connectedRelays.map(async i=>{const n=Date.now();try{const r=await this.publishToRelay(i,e),o=Date.now()-n;t.push({relay:i,success:r,latency:o})}catch(r){const o=Date.now()-n;t.push({relay:i,success:!1,error:r instanceof Error?r.message:"Unknown error",latency:o})}});return await Promise.allSettled(s),t}async publishToRelay(e,t){const s=this.connections.get(e);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${e}`);return new Promise((i,n)=>{const r=s.ws,o=["EVENT",t],c=setTimeout(()=>{n(new Error("Publish timeout"))},ee.PUBLISH_TIMEOUT),l=t.id;this.pendingPublishes.set(l,{resolve:i,reject:n,timeout:c});try{const u=JSON.stringify(o);r.send(u),this.debug&&(console.log(`üì§ Publishing event ${t.id} to ${e}`),console.log("üì§ Message:",u),console.log("üì§ Added to pending:",l))}catch(u){clearTimeout(c),this.pendingPublishes.delete(l),n(u)}})}handleRelayMessage(e,t){try{const s=JSON.parse(t);if(this.debug&&console.log(`üì• Message from ${e}:`,s),s[0]==="OK"){const[,i,n,r]=s,o=this.pendingPublishes.get(i);this.debug&&(console.log(`OK for event ${i}, success: ${n}, pending: ${!!o}`),console.log("Pending publishes:",Array.from(this.pendingPublishes.keys()))),o?(clearTimeout(o.timeout),this.pendingPublishes.delete(i),n?o.resolve(!0):o.reject(new Error(r||"Relay rejected event"))):this.debug&&console.warn(`No pending publish found for event ID: ${i}`)}else if(s[0]==="NOTICE"){const[,i]=s;this.debug&&console.log(`Notice from ${e}:`,i)}else(s[0]==="EVENT"||s[0]==="EOSE")&&(this.messageHandler?this.messageHandler(e,s):this.debug&&console.log(`No message handler registered for ${s[0]} message`))}catch(s){this.debug&&console.error(`Failed to parse message from ${e}:`,s)}}async getRelayInfo(e){try{const t=e.replace(/^ws/,"http"),s=await fetch(t,{headers:{Accept:"application/nostr+json"}});if(!s.ok)throw new Error(`HTTP ${s.status}`);return await s.json()}catch(t){throw new Error(`Failed to get relay info: ${t instanceof Error?t.message:"Unknown error"}`)}}async testRelay(e){try{return we.WEBSOCKET_URL.test(e)?(await this.connectToRelay(e),{success:!0}):{success:!1,error:"Invalid WebSocket URL format"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async disconnect(){this.pendingPublishes.forEach(({timeout:e,reject:t})=>{clearTimeout(e),t(new Error("Disconnecting"))}),this.pendingPublishes.clear(),this.connections.forEach(e=>{e.ws&&(e.ws.close(),e.ws=void 0),e.state="disconnected"})}async sendToAll(e){const t=this.connectedRelays.map(s=>this.sendToRelay(s,e).catch(i=>{this.debug&&console.warn(`Failed to send to ${s}:`,i)}));await Promise.allSettled(t)}async sendToRelays(e,t){const s=e.map(i=>this.sendToRelay(i,t).catch(n=>{this.debug&&console.warn(`Failed to send to ${i}:`,n)}));await Promise.allSettled(s)}async sendToRelay(e,t){const s=this.connections.get(e);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${e}`);const i=JSON.stringify(t);s.ws.send(i),this.debug&&console.log(`üì§ Sent to ${e}:`,i)}setMessageHandler(e){this.messageHandler=e}getStats(){const e={total:this.connections.size,connected:0,connecting:0,disconnected:0,error:0};return this.connections.forEach(t=>{e[t.state]++}),e}}class ge{async getPublicKey(){if(!window.nostr)throw new Error(N.NO_EXTENSION);try{return await window.nostr.getPublicKey()}catch(e){throw new Error(`Extension signing failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async signEvent(e){if(!window.nostr)throw new Error(N.NO_EXTENSION);try{return(await window.nostr.signEvent(e)).sig}catch(t){throw new Error(`Extension signing failed: ${t instanceof Error?t.message:"Unknown error"}`)}}static async isAvailable(){return typeof window<"u"&&typeof window.nostr<"u"&&typeof window.nostr.getPublicKey=="function"&&typeof window.nostr.signEvent=="function"}}class Ie{constructor(){h(this,"privateKey");h(this,"publicKey");const e=oe(32);this.privateKey=me(e),this.publicKey=me(se.schnorr.getPublicKey(this.privateKey))}async getPublicKey(){return this.publicKey}async signEvent(e){const t=C.calculateEventId(e),s=await se.schnorr.sign(t,this.privateKey);return me(s)}async getPrivateKeyForEncryption(){return this.privateKey}}class Tt extends Ie{}class kt extends Ie{}class je{static async createBestAvailable(){if(await ge.isAvailable())try{const e=new ge;return await e.getPublicKey(),{provider:e,method:"extension"}}catch(e){console.warn("Extension detected but failed to initialize:",e)}return{provider:new Ie,method:"temporary"}}}class _{static createError(e,t,s={}){return{message:t,retryable:s.retryable??!1,suggestion:s.suggestion,userAction:s.userAction}}static handleContentError(e){return e===""?_.createError("validation",N.EMPTY_CONTENT,{retryable:!0,suggestion:le.EMPTY_CONTENT}):e.length>8192?_.createError("validation",N.CONTENT_TOO_LONG,{retryable:!0,suggestion:le.CONTENT_TOO_LONG}):_.createError("validation",N.INVALID_EVENT)}static handleSigningError(e){const t=e.message.toLowerCase();return t.includes("user declined")||t.includes("denied")?_.createError("signing","User declined to sign the event",{retryable:!0,userAction:"User declined signing",suggestion:"Click approve in your Nostr extension to publish the event"}):t.includes("no extension")?_.createError("signing",N.NO_EXTENSION,{retryable:!1,suggestion:le.NO_EXTENSION}):_.createError("signing",N.SIGNING_FAILED,{retryable:!0,suggestion:"Check your Nostr extension and try again"})}static handleConnectionError(e,t){const s=t.message.toLowerCase();return s.includes("timeout")?_.createError("network",`Connection to ${e} timed out`,{retryable:!0,suggestion:"The relay might be slow or unavailable. Try again or use different relays"}):s.includes("refused")||s.includes("failed to connect")?_.createError("network",`Failed to connect to ${e}`,{retryable:!0,suggestion:"The relay might be down. Check the relay URL or try different relays"}):_.createError("network",N.CONNECTION_FAILED,{retryable:!0,suggestion:le.CONNECTION_FAILED})}static analyzeRelayResults(e){const t=e.length,s=e.filter(n=>n.success),i=e.filter(n=>!n.success);if(t===0)return{success:!1,error:_.createError("config",N.NO_RELAYS,{retryable:!1,suggestion:"Configure at least one relay URL"})};if(s.length===0){const n=i.every(o=>{var c;return(c=o.error)==null?void 0:c.toLowerCase().includes("timeout")}),r=i.every(o=>{var c,l;return((c=o.error)==null?void 0:c.toLowerCase().includes("connect"))||((l=o.error)==null?void 0:l.toLowerCase().includes("refused"))});return n?{success:!1,error:_.createError("network","All relays timed out",{retryable:!0,suggestion:"Check your internet connection or try again later"})}:r?{success:!1,error:_.createError("network","Could not connect to any relay",{retryable:!0,suggestion:"Check relay URLs and your internet connection"})}:{success:!1,error:_.createError("relay",N.PUBLISH_FAILED,{retryable:!0,suggestion:le.PUBLISH_FAILED})}}return{success:!0}}static formatErrorForUser(e,t){let s=e.message;if(t!=null&&t.relayResults){const i=t.relayResults.filter(r=>r.success).length,n=t.relayResults.length;i>0?s+=` (${i}/${n} relays succeeded)`:s+=` (0/${n} relays succeeded)`}return e.suggestion&&(s+=`

Suggestion: ${e.suggestion}`),e.retryable&&(s+=`

This error is retryable - you can try again.`),s}static shouldRetry(e,t,s){return e.retryable&&t<s}static calculateRetryDelay(e,t=1e3){return Math.min(t*Math.pow(2,e),3e4)}}class Ye{constructor(e){h(this,"eventData");h(this,"nostrInstance");h(this,"signed",!1);h(this,"signedEvent");this.nostrInstance=e,this.eventData={tags:[]}}kind(e){return this.eventData.kind=e,this}content(e){return this.eventData.content=e,this}tag(e,t,...s){const i=[e,t,...s];return this.eventData.tags.push(i),this}replyTo(e,t){return t?this.eventData.tags.push(["e",e,t,"reply"]):this.eventData.tags.push(["e",e,"","reply"]),this}mention(e,t){return t?this.eventData.tags.push(["p",e,t]):this.eventData.tags.push(["p",e]),this}subject(e){return this.eventData.tags.push(["subject",e]),this}timestamp(e){return this.eventData.created_at=e,this}async sign(){if(!this.eventData.content)throw new Error("Content is required before signing");const e=await this.nostrInstance.createEvent({kind:this.eventData.kind,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at});return this.signedEvent=e,this.signed=!0,this}async build(){return this.signed&&this.signedEvent?this.signedEvent:(await this.sign(),this.signedEvent)}async publish(){if(!this.eventData.content)throw new Error("Content is required before publishing");if(this.signed&&this.signedEvent)return await this.nostrInstance.publishEvent(this.signedEvent);if(this.eventData.kind===1&&this.eventData.tags.length===0&&!this.eventData.created_at)return await this.nostrInstance.publish(this.eventData.content);const e=await this.nostrInstance.createEvent({kind:this.eventData.kind,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at});return await this.nostrInstance.publishEvent(e)}getEventData(){return{...this.eventData}}reset(){return this.eventData={tags:[]},this.signed=!1,this.signedEvent=void 0,this}}class Ze{constructor(e){h(this,"nostrInstance");this.nostrInstance=e}create(){return new Ye(this.nostrInstance)}note(e){return this.create().kind(1).content(e)}dm(e,t){return this.create().kind(4).content(e).tag("p",t)}job(e){return this.create().kind(30023).content(e).tag("t","jobs")}reaction(e,t="+"){return this.create().kind(7).content(t).tag("e",e)}}function S(a){const e=new Set;let t=a;return{subscribe(s){return s(t),e.add(s),()=>e.delete(s)},set(s){t=s,e.forEach(i=>i(t))},update(s){t=s(t),e.forEach(i=>i(t))}}}function E(a,e){const t=Array.isArray(a)?a:[a],s=new Set;let i,n=!1;const r=[],o=()=>{if(t.length===1){const c=t[0].subscribe(l=>{const u=e(l);(!n||u!==i)&&(i=u,n&&s.forEach(g=>g(i)))});r.length===0&&r.push(c)}};return{subscribe(c){return n||(o(),n=!0),i!==void 0&&c(i),s.add(c),()=>{s.delete(c),s.size===0&&(r.forEach(l=>l()),r.length=0,n=!1)}}}}function Xe(a){return{subscribe:a.subscribe.bind(a),derive:e=>E(a,e)}}class de{constructor(e,t,s){h(this,"_events");h(this,"_readIds",new Set);h(this,"parent");this.parent=e,this._events=E(e.events,i=>{let n=i;return t&&(n=n.filter(t)),s&&(n=[...n].sort(s)),n})}subscribe(e){return this._events.subscribe(e)}get events(){return this._events}get status(){return this.parent.status}get error(){return this.parent.error}get loading(){return this.parent.loading}get count(){return E(this._events,e=>e.length)}get latest(){return E(this._events,e=>e[0]||null)}get hasMore(){return this.parent.hasMore}get isEmpty(){return E(this._events,e=>e.length===0)}async close(){return this.parent.close()}async refresh(){return this.parent.refresh()}reset(){return this._readIds.clear(),this.parent.reset()}async updateFilter(e){return this.parent.updateFilter(e)}async updateOptions(e){return this.parent.updateOptions(e)}derive(e){return Xe(E(this._events,e))}async retry(){return this.parent.retry()}clearError(){return this.parent.clearError()}async loadMore(e){return this.parent.loadMore(e)}async loadNewer(){return this.parent.loadNewer()}async loadOlder(){return this.parent.loadOlder()}markAsRead(e){this._readIds.add(e)}markAllAsRead(){let e=[];this._events.subscribe(s=>{e=s})(),e.forEach(s=>this._readIds.add(s.id))}removeEvent(e){return this.parent.removeEvent(e)}filter(e){return new de(this,e)}sortBy(e){return new de(this,void 0,e)}getReadStatus(){let e=[];this._events.subscribe(r=>{e=r})();const s=e.filter(r=>this._readIds.has(r.id)).length,i=e.length,n=i-s;return{read:s,unread:n,total:i}}}class Se{constructor(e,t,s={},i={}){h(this,"_events",S([]));h(this,"_status",S("connecting"));h(this,"_error",S(null));h(this,"_loading",S(!1));h(this,"_count",S(0));h(this,"_readIds",new Set);h(this,"subscription");h(this,"subscriptionManager");h(this,"filters");h(this,"options");h(this,"maxEvents");h(this,"isLive");h(this,"eventPredicate");h(this,"eventComparator");this.subscriptionManager=e,this.filters=t,this.options=s,this.maxEvents=i.maxEvents,this.isLive=i.live||!1,this.eventPredicate=i.predicate,this.eventComparator=i.comparator,this.initializeSubscription()}subscribe(e){return this._events.subscribe(e)}get events(){return this._events}get status(){return this._status}get error(){return this._error}get loading(){return this._loading}get count(){return this._count}get latest(){return E(this._events,e=>e[0]||null)}get hasMore(){return E(this._events,()=>!0)}get isEmpty(){return E(this._events,e=>e.length===0)}async close(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.subscriptionManager.close(this.subscription.subscription.id),this._status.set("closed")}async refresh(){this.reset(),await this.initializeSubscription()}reset(){this._events.set([]),this._count.set(0),this._readIds.clear(),this._error.set(null)}async updateFilter(e){this.filters=this.filters.map(t=>({...t,...e})),await this.refresh()}async updateOptions(e){this.options={...this.options,...e},await this.refresh()}derive(e){return Xe(E(this._events,e))}async retry(){this._status.set("reconnecting"),this._error.set(null),await this.initializeSubscription()}clearError(){this._error.set(null)}async loadMore(e=10){return[]}async loadNewer(){return[]}async loadOlder(){return[]}markAsRead(e){this._readIds.add(e)}markAllAsRead(){let e=[];this._events.subscribe(s=>{e=s})(),e.forEach(s=>this._readIds.add(s.id))}removeEvent(e){this._events.update(t=>t.filter(s=>s.id!==e)),this._count.update(t=>t-1)}filter(e){return new de(this,e,this.eventComparator)}sortBy(e){return new de(this,this.eventPredicate,e)}getReadStatus(){let e=[];this._events.subscribe(r=>{e=r})();const s=e.filter(r=>this._readIds.has(r.id)).length,i=e.length,n=i-s;return{read:s,unread:n,total:i}}_testInjectEvent(e){this.handleEvent(e)}_testSimulateEOSE(){this._status.set("active"),this._loading.set(!1)}async _testWaitForInit(){let e=0;for(;!this.subscription&&e<100;)await new Promise(t=>setTimeout(t,10)),e++}async initializeSubscription(){this._loading.set(!0),this._status.set("connecting");try{const e={...this.options,onEvent:t=>{this.handleEvent(t)},onEose:t=>{this._status.set("active"),this._loading.set(!1)},onClose:t=>{this._status.set("closed")}};this.subscription=await this.subscriptionManager.subscribe(this.filters,e),this.subscription.success?this._error.set(null):(this._error.set(this.subscription.error||{message:"Subscription failed",retryable:!0}),this._status.set("error"),this._loading.set(!1))}catch(e){this._error.set({message:e instanceof Error?e.message:"Unknown error",retryable:!0}),this._status.set("error"),this._loading.set(!1)}}handleEvent(e){this.eventPredicate&&!this.eventPredicate(e)||(this._events.update(t=>{if(t.some(i=>i.id===e.id))return t;const s=[...t,e];return this.eventComparator?s.sort(this.eventComparator):s.sort((i,n)=>n.created_at-i.created_at),this.maxEvents&&s.length>this.maxEvents?s.slice(0,this.maxEvents):s}),this._count.update(t=>t+1))}}class Rt{constructor(e){h(this,"filter",{});h(this,"options",{});h(this,"config",{});this.subscriptionManager=e}kinds(e){return this.filter.kinds=e,this}authors(e){return this.filter.authors=e,this}since(e){return this.filter.since=e,this}until(e){return this.filter.until=e,this}limit(e){return this.filter.limit=e,this}live(e){return this.config.live=e,this.options={...this.options,live:e},this}maxEvents(e){return this.config.maxEvents=e,this}build(){const e=[this.filter];return new Se(this.subscriptionManager,e,this.options,this.config)}}let ne;function Nt(a){ne=a}function Ct(){if(!ne)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new Rt(ne)}function Dt(a){if(!ne)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");const e=a.toFilter();return new Se(ne,e)}function Lt(a){if(!ne)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new Se(ne,[a])}class Je extends He{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Oe(e);const s=he(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,n=new Uint8Array(i);n.set(s.length>i?e.create().update(s).digest():s);for(let r=0;r<n.length;r++)n[r]^=54;this.iHash.update(n),this.oHash=e.create();for(let r=0;r<n.length;r++)n[r]^=106;this.oHash.update(n),ue(n)}update(e){return _e(this),this.iHash.update(e),this}digestInto(e){_e(this),pe(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:s,finished:i,destroyed:n,blockLen:r,outputLen:o}=this;return e=e,e.finished=i,e.destroyed=n,e.blockLen=r,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fe=(a,e,t)=>new Je(a,e).update(t).digest();fe.create=(a,e)=>new Je(a,e);function Ot(a,e,t){return Oe(a),t===void 0&&(t=new Uint8Array(a.outputLen)),fe(a,he(t),he(e))}const ke=Uint8Array.from([0]),Fe=Uint8Array.of();function xt(a,e,t,s=32){Oe(a),Ne(s);const i=a.outputLen;if(s>255*i)throw new Error("Length should be <= 255*HashLen");const n=Math.ceil(s/i);t===void 0&&(t=Fe);const r=new Uint8Array(n*i),o=fe.create(a,e),c=o._cloneInto(),l=new Uint8Array(o.outputLen);for(let u=0;u<n;u++)ke[0]=u+1,c.update(u===0?Fe:l).update(t).update(ke).digestInto(l),r.set(l,i*u),o._cloneInto(c);return o.destroy(),c.destroy(),ue(l,ke),r.slice(0,s)}const Ue=(a,e,t,s,i)=>xt(a,Ot(a,e,t),s,i);/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Ft(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&a.constructor.name==="Uint8Array"}function Ke(a){if(typeof a!="boolean")throw new Error(`boolean expected, not ${a}`)}function Re(a){if(!Number.isSafeInteger(a)||a<0)throw new Error("positive integer expected, got "+a)}function ye(a,...e){if(!Ft(a))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(a.length))throw new Error("Uint8Array expected of length "+e+", got length="+a.length)}function te(a){return new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4))}function Ut(...a){for(let e=0;e<a.length;e++)a[e].fill(0)}function Kt(a,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(a,e)}function Ve(a){return Uint8Array.from(a)}const Qe=a=>Uint8Array.from(a.split("").map(e=>e.charCodeAt(0))),Vt=Qe("expand 16-byte k"),$t=Qe("expand 32-byte k"),Wt=te(Vt),Gt=te($t);function m(a,e){return a<<e|a>>>32-e}function De(a){return a.byteOffset%4===0}const be=64,Ht=16,qe=2**32-1,$e=new Uint32Array;function Bt(a,e,t,s,i,n,r,o){const c=i.length,l=new Uint8Array(be),u=te(l),g=De(i)&&De(n),d=g?te(i):$e,p=g?te(n):$e;for(let f=0;f<c;r++){if(a(e,t,s,u,r,o),r>=qe)throw new Error("arx: counter overflow");const w=Math.min(be,c-f);if(g&&w===be){const I=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let v=0,M;v<Ht;v++)M=I+v,p[M]=d[M]^u[v];f+=be;continue}for(let I=0,v;I<w;I++)v=f+I,n[v]=i[v]^l[I];f+=w}}function zt(a,e){const{allowShortKeys:t,extendNonceFn:s,counterLength:i,counterRight:n,rounds:r}=Kt({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof a!="function")throw new Error("core must be a function");return Re(i),Re(r),Ke(n),Ke(t),(o,c,l,u,g=0)=>{ye(o),ye(c),ye(l);const d=l.length;if(u===void 0&&(u=new Uint8Array(d)),ye(u),Re(g),g<0||g>=qe)throw new Error("arx: counter overflow");if(u.length<d)throw new Error(`arx: output (${u.length}) is shorter than data (${d})`);const p=[];let f=o.length,w,I;if(f===32)p.push(w=Ve(o)),I=Gt;else if(f===16&&t)w=new Uint8Array(32),w.set(o),w.set(o,16),I=Wt,p.push(w);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);De(c)||p.push(c=Ve(c));const v=te(w);if(s){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(I,v,te(c.subarray(0,16)),v),c=c.subarray(16)}const M=16-i;if(M!==c.length)throw new Error(`arx: nonce must be ${M} or 16 bytes`);if(M!==12){const J=new Uint8Array(12);J.set(c,n?0:12-c.length),c=J,p.push(c)}const D=te(c);return Bt(a,I,v,D,l,u,g,r),Ut(...p),u}}function jt(a,e,t,s,i,n=20){let r=a[0],o=a[1],c=a[2],l=a[3],u=e[0],g=e[1],d=e[2],p=e[3],f=e[4],w=e[5],I=e[6],v=e[7],M=i,D=t[0],J=t[1],re=t[2],A=r,L=o,O=c,x=l,F=u,U=g,K=d,V=p,$=f,W=w,G=I,H=v,B=M,z=D,j=J,Y=re;for(let xe=0;xe<n;xe+=2)A=A+F|0,B=m(B^A,16),$=$+B|0,F=m(F^$,12),A=A+F|0,B=m(B^A,8),$=$+B|0,F=m(F^$,7),L=L+U|0,z=m(z^L,16),W=W+z|0,U=m(U^W,12),L=L+U|0,z=m(z^L,8),W=W+z|0,U=m(U^W,7),O=O+K|0,j=m(j^O,16),G=G+j|0,K=m(K^G,12),O=O+K|0,j=m(j^O,8),G=G+j|0,K=m(K^G,7),x=x+V|0,Y=m(Y^x,16),H=H+Y|0,V=m(V^H,12),x=x+V|0,Y=m(Y^x,8),H=H+Y|0,V=m(V^H,7),A=A+U|0,Y=m(Y^A,16),G=G+Y|0,U=m(U^G,12),A=A+U|0,Y=m(Y^A,8),G=G+Y|0,U=m(U^G,7),L=L+K|0,B=m(B^L,16),H=H+B|0,K=m(K^H,12),L=L+K|0,B=m(B^L,8),H=H+B|0,K=m(K^H,7),O=O+V|0,z=m(z^O,16),$=$+z|0,V=m(V^$,12),O=O+V|0,z=m(z^O,8),$=$+z|0,V=m(V^$,7),x=x+F|0,j=m(j^x,16),W=W+j|0,F=m(F^W,12),x=x+F|0,j=m(j^x,8),W=W+j|0,F=m(F^W,7);let T=0;s[T++]=r+A|0,s[T++]=o+L|0,s[T++]=c+O|0,s[T++]=l+x|0,s[T++]=u+F|0,s[T++]=g+U|0,s[T++]=d+K|0,s[T++]=p+V|0,s[T++]=f+$|0,s[T++]=w+W|0,s[T++]=I+G|0,s[T++]=v+H|0,s[T++]=M+B|0,s[T++]=D+z|0,s[T++]=J+j|0,s[T++]=re+Y|0}const We=zt(jt,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Yt={saltInfo:"nip44-v2"};class k extends Error{constructor(e,t,s){super(e),this.code=t,this.details=s,this.name="NIP44Error"}}var R=(a=>(a.INVALID_KEY="INVALID_KEY",a.INVALID_NONCE="INVALID_NONCE",a.INVALID_PAYLOAD="INVALID_PAYLOAD",a.ENCRYPTION_FAILED="ENCRYPTION_FAILED",a.DECRYPTION_FAILED="DECRYPTION_FAILED",a.MAC_VERIFICATION_FAILED="MAC_VERIFICATION_FAILED",a.INVALID_PLAINTEXT_LENGTH="INVALID_PLAINTEXT_LENGTH",a.PADDING_ERROR="PADDING_ERROR",a))(R||{});class P{static deriveConversationKey(e,t){try{const s=e.replace(/^0x/,"");let i=t.replace(/^0x/,"");if(s.length!==64)throw new k("Invalid private key length",R.INVALID_KEY);if(i.length===64)i="02"+i;else if(i.length!==66||!i.startsWith("02")&&!i.startsWith("03"))throw new k("Invalid public key format",R.INVALID_KEY);const r=Ge.getSharedSecret(s,i,!0).slice(1);return Ue(ie,r,this.SALT,new Uint8Array(0),32)}catch(s){throw s instanceof k?s:new k(`Key derivation failed: ${s.message}`,R.INVALID_KEY,s)}}static deriveMessageKeys(e,t){try{if(e.length!==32)throw new k("Invalid conversation key length",R.INVALID_KEY);if(t.length!==this.NONCE_SIZE)throw new k("Invalid nonce length",R.INVALID_NONCE);const s=Ue(ie,e,new Uint8Array(0),t,76);return{chachaKey:s.slice(0,32),chachaNonce:s.slice(32,44),hmacKey:s.slice(44,76)}}catch(s){throw new k(`Message key derivation failed: ${s.message}`,R.ENCRYPTION_FAILED,s)}}static calculatePaddedLength(e){if(e<0||e>65536)throw new k("Invalid plaintext length",R.INVALID_PLAINTEXT_LENGTH);if(e===0||e<=32)return 32;const t=1<<Math.floor(Math.log2(e-1))+1;let s;return t<=256?s=32:s=t/8,s*(Math.floor((e-1)/s)+1)}static applyPadding(e){const t=e.length,s=this.calculatePaddedLength(t+2),i=new Uint8Array(s);return i[0]=t>>>8&255,i[1]=t&255,i.set(e,2),i}static removePadding(e){if(e.length<2)throw new k("Invalid padded data length",R.PADDING_ERROR);const t=e[0]<<8|e[1];if(t>e.length-2)throw new k("Invalid plaintext length in padding",R.PADDING_ERROR);return e.slice(2,2+t)}static generateNonce(){return oe(this.NONCE_SIZE)}static encrypt(e,t,s){try{if(e==null)throw new k("Plaintext cannot be null or undefined",R.INVALID_PLAINTEXT_LENGTH);const i=new TextEncoder().encode(e),n=s||this.generateNonce(),r=this.deriveMessageKeys(t,n),o=this.applyPadding(i),c=We(r.chachaKey,r.chachaNonce,o),l=new Uint8Array(n.length+c.length);l.set(n,0),l.set(c,n.length);const u=fe(ie,r.hmacKey,l),g=new Uint8Array(this.VERSION_SIZE+n.length+c.length+this.MAC_SIZE);let d=0;return g[d]=this.VERSION,d+=this.VERSION_SIZE,g.set(n,d),d+=n.length,g.set(c,d),d+=c.length,g.set(u,d),{payload:btoa(String.fromCharCode(...g)),nonce:n}}catch(i){throw i instanceof k?i:new k(`Encryption failed: ${i.message}`,R.ENCRYPTION_FAILED,i)}}static decrypt(e,t){try{const s=atob(e),i=new Uint8Array(s.length);for(let M=0;M<s.length;M++)i[M]=s.charCodeAt(M);const n=this.VERSION_SIZE+this.NONCE_SIZE+this.MAC_SIZE;if(i.length<n)throw new k("Payload too short",R.INVALID_PAYLOAD);let r=0;const o=i[r];if(r+=this.VERSION_SIZE,o!==this.VERSION)throw new k(`Unsupported version: ${o}`,R.INVALID_PAYLOAD);const c=i.slice(r,r+this.NONCE_SIZE);r+=this.NONCE_SIZE;const l=i.slice(r,-this.MAC_SIZE),u=i.slice(-this.MAC_SIZE),g=this.deriveMessageKeys(t,c),d=new Uint8Array(c.length+l.length);d.set(c,0),d.set(l,c.length);const p=fe(ie,g.hmacKey,d);let f=!0;for(let M=0;M<this.MAC_SIZE;M++)u[M]!==p[M]&&(f=!1);if(!f)return{plaintext:"",isValid:!1};const w=We(g.chachaKey,g.chachaNonce,l),I=this.removePadding(w);return{plaintext:new TextDecoder().decode(I),isValid:!0}}catch{return{plaintext:"",isValid:!1}}}static encryptWithNonce(e,t,s){return this.encrypt(e,t,s).payload}static validatePayload(e){try{const t=atob(e),s=new Uint8Array(t.length);for(let n=0;n<t.length;n++)s[n]=t.charCodeAt(n);const i=this.VERSION_SIZE+this.NONCE_SIZE+this.MAC_SIZE;return!(s.length<i||s[0]!==this.VERSION)}catch{return!1}}}h(P,"VERSION",2),h(P,"SALT",new TextEncoder().encode(Yt.saltInfo)),h(P,"NONCE_SIZE",32),h(P,"CHACHA_KEY_SIZE",32),h(P,"CHACHA_NONCE_SIZE",12),h(P,"HMAC_KEY_SIZE",32),h(P,"MAC_SIZE",32),h(P,"VERSION_SIZE",1);class y extends Error{constructor(e,t,s){super(e),this.code=t,this.details=s,this.name="NIP59Error"}}var b=(a=>(a.INVALID_RUMOR="INVALID_RUMOR",a.SEAL_CREATION_FAILED="SEAL_CREATION_FAILED",a.GIFT_WRAP_CREATION_FAILED="GIFT_WRAP_CREATION_FAILED",a.EPHEMERAL_KEY_GENERATION_FAILED="EPHEMERAL_KEY_GENERATION_FAILED",a.TIMESTAMP_RANDOMIZATION_FAILED="TIMESTAMP_RANDOMIZATION_FAILED",a.DECRYPTION_FAILED="DECRYPTION_FAILED",a.INVALID_GIFT_WRAP="INVALID_GIFT_WRAP",a.INVALID_SEAL="INVALID_SEAL",a.NO_RECIPIENTS="NO_RECIPIENTS",a.INVALID_RECIPIENT="INVALID_RECIPIENT",a))(b||{});const Z={SEAL_KIND:13,GIFT_WRAP_KIND:1059,MAX_TIMESTAMP_AGE_SECONDS:2*24*60*60,MIN_TIMESTAMP_AGE_SECONDS:0};class Ee{static async createSeal(e,t,s){try{this.validateRumor(e),this.validatePrivateKey(t),this.validatePublicKey(s);const i=JSON.stringify(e),n=P.deriveConversationKey(t,s),r=P.encrypt(i,n),o=this.getPublicKeyFromPrivate(t),c={pubkey:o,created_at:Math.floor(Date.now()/1e3),kind:Z.SEAL_KIND,tags:[],content:r.payload},l=this.calculateEventId(c),u=await this.signEvent(c,l,t);return{id:l,pubkey:o,created_at:c.created_at,kind:Z.SEAL_KIND,tags:[],content:r.payload,sig:u}}catch(i){throw i instanceof y?i:new y(`Seal creation failed: ${i.message}`,b.SEAL_CREATION_FAILED,i)}}static decryptSeal(e,t){try{if(e.kind!==Z.SEAL_KIND)return{rumor:null,isValid:!1};if(e.tags.length!==0)return{rumor:null,isValid:!1};const s=P.deriveConversationKey(t,e.pubkey),i=P.decrypt(e.content,s);if(!i.isValid)return{rumor:null,isValid:!1};const n=JSON.parse(i.plaintext);return this.isValidRumor(n)?{rumor:n,isValid:!0}:{rumor:null,isValid:!1}}catch{return{rumor:null,isValid:!1}}}static validateRumor(e){if(!e||typeof e!="object")throw new y("Rumor must be a valid object",b.INVALID_RUMOR);if(typeof e.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(e.pubkey))throw new y("Rumor must have valid pubkey",b.INVALID_RUMOR);if(typeof e.created_at!="number"||e.created_at<=0)throw new y("Rumor must have valid created_at timestamp",b.INVALID_RUMOR);if(typeof e.kind!="number"||e.kind<0||e.kind>65535)throw new y("Rumor must have valid kind",b.INVALID_RUMOR);if(!Array.isArray(e.tags))throw new y("Rumor must have valid tags array",b.INVALID_RUMOR);if(typeof e.content!="string")throw new y("Rumor must have valid content string",b.INVALID_RUMOR)}static isValidRumor(e){return e&&typeof e=="object"&&typeof e.pubkey=="string"&&typeof e.created_at=="number"&&typeof e.kind=="number"&&Array.isArray(e.tags)&&typeof e.content=="string"}static validatePrivateKey(e){if(typeof e!="string"||!/^[0-9a-f]{64}$/i.test(e))throw new y("Invalid private key format",b.SEAL_CREATION_FAILED)}static validatePublicKey(e){if(typeof e!="string"||!/^[0-9a-f]{64}$/i.test(e))throw new y("Invalid public key format",b.SEAL_CREATION_FAILED)}static getPublicKeyFromPrivate(e){try{console.log("üîç SealCreator.getPublicKeyFromPrivate called with:",{privateKeyLength:e==null?void 0:e.length,privateKeyType:typeof e,privateKeyPrefix:(e==null?void 0:e.substring(0,8))+"..."});const t=new Uint8Array(e.match(/.{1,2}/g).map(r=>parseInt(r,16)));console.log("üìä privateKeyBytes:",{length:t.length,type:t.constructor.name,first4:Array.from(t.slice(0,4))});const i=se.getPublicKey(t,!1).slice(1,33),n=Array.from(i).map(r=>r.toString(16).padStart(2,"0")).join("");return console.log("‚úÖ Successfully derived public key:",n.substring(0,8)+"..."),n}catch(t){throw console.error("‚ùå SealCreator getPublicKeyFromPrivate error:",{error:t,message:t.message,stack:t.stack,privateKeyInfo:{type:typeof e,length:e==null?void 0:e.length}}),new y("Failed to derive public key from private key",b.SEAL_CREATION_FAILED,t)}}static calculateEventId(e){const t=JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]),s=ie(new TextEncoder().encode(t));return Array.from(s).map(i=>i.toString(16).padStart(2,"0")).join("")}static async signEvent(e,t,s){try{const i=await se.schnorr.sign(t,s);return Array.from(i).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(i){throw new y("Failed to sign seal event",b.SEAL_CREATION_FAILED,i)}}}class ve{static generateEphemeralKeyPair(){try{const e=oe(32),t=Array.from(e).map(r=>r.toString(16).padStart(2,"0")).join(""),i=se.getPublicKey(t,!1).slice(1,33),n=Array.from(i).map(r=>r.toString(16).padStart(2,"0")).join("");return{privateKey:t,publicKey:n}}catch(e){throw new y(`Ephemeral key generation failed: ${e.message}`,b.EPHEMERAL_KEY_GENERATION_FAILED,e)}}static generateMultipleEphemeralKeyPairs(e){if(e<=0)throw new y("Key pair count must be greater than 0",b.EPHEMERAL_KEY_GENERATION_FAILED);const t=[];for(let s=0;s<e;s++)t.push(this.generateEphemeralKeyPair());return t}static validateEphemeralKeyPair(e){try{if(!/^[0-9a-f]{64}$/i.test(e.privateKey)||!/^[0-9a-f]{64}$/i.test(e.publicKey))return!1;const s=se.getPublicKey(e.privateKey,!1).slice(1,33),i=Array.from(s).map(n=>n.toString(16).padStart(2,"0")).join("");return e.publicKey.toLowerCase()===i.toLowerCase()}catch{return!1}}static clearEphemeralKeyPair(e){try{const t=oe(32).reduce((s,i)=>s+i.toString(16).padStart(2,"0"),"");e.privateKey=t,e.publicKey=t}catch{}}static generateGiftWrapNonce(){return oe(32)}}class Le{static generateRandomizedTimestamp(e=Z.MAX_TIMESTAMP_AGE_SECONDS){try{if(e<0)throw new y("Max age seconds cannot be negative",b.TIMESTAMP_RANDOMIZATION_FAILED);const t=Math.floor(Date.now()/1e3);if(e===0)return t;const s=this.generateSecureRandomOffset(e);return t-s}catch(t){throw t instanceof y?t:new y(`Timestamp randomization failed: ${t.message}`,b.TIMESTAMP_RANDOMIZATION_FAILED,t)}}static generateSecureRandomOffset(e){const t=oe(4),s=new DataView(t.buffer).getUint32(0,!1);return Math.floor(s/4294967295*e)}static generateMultipleRandomizedTimestamps(e,t=Z.MAX_TIMESTAMP_AGE_SECONDS){if(e<=0)throw new y("Timestamp count must be greater than 0",b.TIMESTAMP_RANDOMIZATION_FAILED);const s=[];for(let i=0;i<e;i++)s.push(this.generateRandomizedTimestamp(t));return s}static validateGiftWrapTimestamp(e,t=Z.MAX_TIMESTAMP_AGE_SECONDS){try{const s=Math.floor(Date.now()/1e3),i=s-t,n=s+60;return e>=i&&e<=n}catch{return!1}}static getRecommendedMaxAge(){return Z.MAX_TIMESTAMP_AGE_SECONDS}static calculateTimestampEntropy(e){return e<=0?0:Math.log2(e)}static generateTimestampInWindow(e,t){if(e>=t)throw new y("Window start must be before window end",b.TIMESTAMP_RANDOMIZATION_FAILED);const s=t-e,i=this.generateSecureRandomOffset(s);return e+i}}class Me{static async createGiftWrap(e,t,s,i){try{this.validateSeal(e),this.validateRecipient(t);const n=s||ve.generateEphemeralKeyPair();if(!ve.validateEphemeralKeyPair(n))throw new y("Invalid ephemeral key pair",b.GIFT_WRAP_CREATION_FAILED);const r=i||Le.generateRandomizedTimestamp(),o=JSON.stringify(e),c=P.deriveConversationKey(n.privateKey,t.pubkey),l=P.encrypt(o,c),u=t.relayHint?["p",t.pubkey,t.relayHint]:["p",t.pubkey],g={pubkey:n.publicKey,created_at:r,kind:Z.GIFT_WRAP_KIND,tags:[u],content:l.payload},d=this.calculateEventId(g),p=await this.signEvent(g,d,n.privateKey);return{giftWrap:{id:d,pubkey:n.publicKey,created_at:r,kind:Z.GIFT_WRAP_KIND,tags:[u],content:l.payload,sig:p},ephemeralKeyPair:n,recipient:t.pubkey}}catch(n){throw n instanceof y?n:new y(`Gift wrap creation failed: ${n.message}`,b.GIFT_WRAP_CREATION_FAILED,n)}}static async createMultipleGiftWraps(e,t){if(!t||t.length===0)throw new y("At least one recipient is required",b.NO_RECIPIENTS);const s=[],i=ve.generateMultipleEphemeralKeyPairs(t.length),n=Le.generateMultipleRandomizedTimestamps(t.length);for(let r=0;r<t.length;r++){const o=await this.createGiftWrap(e,t[r],i[r],n[r]);s.push(o)}return s}static decryptGiftWrap(e,t){try{if(!this.isValidGiftWrap(e))return{seal:null,isValid:!1};const s=P.deriveConversationKey(t,e.pubkey),i=P.decrypt(e.content,s);if(!i.isValid)return{seal:null,isValid:!1};const n=JSON.parse(i.plaintext);return this.isValidSeal(n)?{seal:n,isValid:!0}:{seal:null,isValid:!1}}catch{return{seal:null,isValid:!1}}}static validateSeal(e){if(!e||typeof e!="object")throw new y("Seal must be a valid object",b.INVALID_SEAL);if(e.kind!==Z.SEAL_KIND)throw new y("Seal must have kind 13",b.INVALID_SEAL);if(!Array.isArray(e.tags)||e.tags.length!==0)throw new y("Seal must have empty tags array",b.INVALID_SEAL);if(typeof e.content!="string")throw new y("Seal must have valid content string",b.INVALID_SEAL)}static validateRecipient(e){if(!e||typeof e!="object")throw new y("Recipient must be a valid object",b.INVALID_RECIPIENT);if(typeof e.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(e.pubkey))throw new y("Recipient must have valid pubkey",b.INVALID_RECIPIENT);if(e.relayHint&&typeof e.relayHint!="string")throw new y("Recipient relay hint must be a string if provided",b.INVALID_RECIPIENT)}static isValidGiftWrap(e){return e&&typeof e=="object"&&e.kind===Z.GIFT_WRAP_KIND&&typeof e.pubkey=="string"&&typeof e.content=="string"&&Array.isArray(e.tags)&&e.tags.length>0&&Array.isArray(e.tags[0])&&e.tags[0][0]==="p"&&typeof e.tags[0][1]=="string"}static isValidSeal(e){return e&&typeof e=="object"&&e.kind===Z.SEAL_KIND&&typeof e.pubkey=="string"&&typeof e.content=="string"&&Array.isArray(e.tags)&&e.tags.length===0}static calculateEventId(e){const t=JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]),s=ie(new TextEncoder().encode(t));return Array.from(s).map(i=>i.toString(16).padStart(2,"0")).join("")}static async signEvent(e,t,s){try{const i=await se.schnorr.sign(t,s);return Array.from(i).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(i){throw new y("Failed to sign gift wrap event",b.GIFT_WRAP_CREATION_FAILED,i)}}static getRecipientFromGiftWrap(e){try{return e.tags.length>0&&e.tags[0][0]==="p"?e.tags[0][1]:null}catch{return null}}static getRelayHintFromGiftWrap(e){try{return e.tags.length>0&&e.tags[0][0]==="p"&&e.tags[0].length>2?e.tags[0][2]:null}catch{return null}}}class ce{static async createGiftWrappedDM(e,t,s,i){try{this.validateCreateDMInputs(e,t,s);const n=this.createRumor(e,t,i),r=[];for(const c of s.recipients){const l=await Ee.createSeal(n,t,c.pubkey),u=await Me.createGiftWrap(l,{pubkey:c.pubkey,relayHint:c.relayHint||s.relayHint});r.push(u)}const o=await Ee.createSeal(n,t,s.recipients[0].pubkey);return{rumor:n,seal:o,giftWraps:r,senderPrivateKey:t}}catch(n){throw n instanceof y?n:new y(`Gift wrap protocol failed: ${n.message}`,b.GIFT_WRAP_CREATION_FAILED,n)}}static async decryptGiftWrappedDM(e,t){try{const s=Me.decryptGiftWrap(e,t);if(!s.isValid)return{rumor:null,seal:null,isValid:!1,senderPubkey:""};const i=s.seal,n=Ee.decryptSeal(i,t);return n.isValid?{rumor:n.rumor,seal:i,isValid:!0,senderPubkey:i.pubkey}:{rumor:null,seal:i,isValid:!1,senderPubkey:i.pubkey}}catch{return{rumor:null,seal:null,isValid:!1,senderPubkey:""}}}static createRumor(e,t,s){const i=this.getPublicKeyFromPrivate(t),n=[];return s&&n.push(["subject",s]),{pubkey:i,created_at:Math.floor(Date.now()/1e3),kind:14,tags:n,content:e}}static async createBatchGiftWraps(e){const t=[];for(const s of e){const i=await this.createGiftWrappedDM(s.message,s.senderPrivateKey,s.config);t.push(i)}return t}static filterGiftWrapsForRecipient(e,t){return e.filter(s=>Me.getRecipientFromGiftWrap(s)===t)}static async decryptMultipleGiftWraps(e,t){const s=[];for(const i of e){const n=await this.decryptGiftWrappedDM(i,t);n.isValid&&s.push(n)}return s}static validateCreateDMInputs(e,t,s){if(typeof e!="string")throw new y("Message must be a string",b.INVALID_RUMOR);if(typeof t!="string"||!/^[0-9a-f]{64}$/i.test(t))throw new y("Invalid sender private key format",b.SEAL_CREATION_FAILED);if(!s||!Array.isArray(s.recipients)||s.recipients.length===0)throw new y("At least one recipient is required",b.NO_RECIPIENTS);for(const i of s.recipients)if(!i||typeof i.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(i.pubkey))throw new y("Invalid recipient public key format",b.INVALID_RECIPIENT)}static getPublicKeyFromPrivate(e){try{console.log("üîç GiftWrapProtocol.getPublicKeyFromPrivate called with:",{privateKeyLength:e==null?void 0:e.length,privateKeyType:typeof e,privateKeyPrefix:(e==null?void 0:e.substring(0,8))+"..."});const t=new Uint8Array(e.match(/.{1,2}/g).map(r=>parseInt(r,16)));console.log("üìä privateKeyBytes:",{length:t.length,type:t.constructor.name,first4:Array.from(t.slice(0,4))});const i=se.getPublicKey(t,!1).slice(1,33),n=Array.from(i).map(r=>r.toString(16).padStart(2,"0")).join("");return console.log("‚úÖ Successfully derived public key:",n.substring(0,8)+"..."),n}catch(t){throw console.error("‚ùå GiftWrapProtocol getPublicKeyFromPrivate error:",{error:t,message:t.message,stack:t.stack,privateKeyInfo:{type:typeof e,length:e==null?void 0:e.length}}),new y("Failed to derive public key from private key",b.SEAL_CREATION_FAILED,t)}}static createSimpleConfig(e,t){return{recipients:[{pubkey:e,relayHint:t}],relayHint:t}}static createMultiRecipientConfig(e,t){return{recipients:e.map(s=>({pubkey:s,relayHint:t})),relayHint:t}}static getProtocolStats(e){const t=e.length,s=e.reduce((c,l)=>c+l.giftWraps.length,0),i=Math.floor(Date.now()/1e3),n=e.flatMap(c=>c.giftWraps.map(l=>i-l.giftWrap.created_at)),r=n.length>0?n.reduce((c,l)=>c+l,0)/n.length:0,o=new Set(e.flatMap(c=>c.giftWraps.map(l=>l.recipient)));return{totalMessages:t,totalGiftWraps:s,averageTimestampAge:r,uniqueRecipients:o.size}}}class et{constructor(e){h(this,"_state");h(this,"subscription");h(this,"config");h(this,"messages");h(this,"status");h(this,"latest");h(this,"error");h(this,"subject");this.config=e,this._state=S({messages:[],status:"connecting",latest:null,isTyping:!1,error:null,subject:e.subject}),this.messages=E(this._state,t=>t.messages),this.status=E(this._state,t=>t.status),this.latest=E(this._state,t=>t.latest),this.error=E(this._state,t=>t.error),this.subject=E(this._state,t=>t.subject),this.initializeSubscription()}async send(e,t){var s;try{this.updateStatus("active");const i=this.generateMessageId(),n=Math.floor(Date.now()/1e3),r={id:i,content:e,senderPubkey:this.config.senderPubkey,recipientPubkey:this.config.recipientPubkey,timestamp:n,isFromMe:!0,status:"sending",subject:t||this.getCurrentSubject()};this.addMessage(r);const o=ce.createSimpleConfig(this.config.recipientPubkey,(s=this.config.relayHints)==null?void 0:s[0]),c=await ce.createGiftWrappedDM(e,this.config.senderPrivateKey,o,t);let l=!1,u;for(const g of c.giftWraps)try{(await this.config.relayManager.publishToAll(g.giftWrap)).some(f=>f.success)&&(l=!0,r.eventId=g.giftWrap.id)}catch(d){u=d instanceof Error?d.message:"Publishing failed"}if(l)return this.updateMessageStatus(i,"sent"),this.config.debug&&console.log(`DM sent successfully: ${i}`),{success:!0,messageId:i};{this.updateMessageStatus(i,"failed");const g=u||"Failed to publish to any relay";return this.setError(g),{success:!1,error:g,messageId:i}}}catch(i){const n=i instanceof Error?i.message:"Unknown error sending message";return this.setError(n),{success:!1,error:n}}}updateSubject(e){this._state.update(t=>({...t,subject:e}))}clearHistory(){this._state.update(e=>({...e,messages:[],latest:null}))}async close(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.updateStatus("disconnected")}async retry(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.setError(null),await this.initializeSubscription()}async initializeSubscription(){var e;try{this.updateStatus("connecting");const t={kinds:[1059],"#p":[this.config.senderPubkey],limit:100},s={onEvent:i=>this.handleIncomingEvent(i),onEose:()=>{this.updateStatus("active"),this.config.debug&&console.log(`DM conversation subscription active for ${this.config.recipientPubkey}`)},onClose:i=>{this.updateStatus("disconnected"),i&&this.setError(`Subscription closed: ${i}`)}};if(this.subscription=await this.config.subscriptionManager.subscribe([t],s),!this.subscription.success){const i=((e=this.subscription.error)==null?void 0:e.message)||"Failed to create subscription";this.setError(i),this.updateStatus("error")}}catch(t){const s=t instanceof Error?t.message:"Failed to initialize subscription";this.setError(s),this.updateStatus("error")}}async handleIncomingEvent(e){try{if(e.kind!==1059)return;const t=await ce.decryptGiftWrappedDM(e,this.config.senderPrivateKey);if(!t.isValid||!t.rumor){this.config.debug&&console.log("Failed to decrypt gift wrap or not for us");return}if(t.senderPubkey!==this.config.recipientPubkey){this.config.debug&&console.log("Message not from conversation partner");return}const s={id:this.generateMessageId(),content:t.rumor.content,senderPubkey:t.senderPubkey,recipientPubkey:this.config.senderPubkey,timestamp:t.rumor.created_at,isFromMe:!1,eventId:e.id,status:"received",subject:this.extractSubjectFromRumor(t.rumor)};this.getCurrentMessages().some(r=>r.eventId===e.id||r.content===s.content&&Math.abs(r.timestamp-s.timestamp)<5)||(this.addMessage(s),this.config.debug&&console.log(`Received DM from ${t.senderPubkey}: ${s.content}`))}catch(t){this.config.debug&&console.error("Error handling incoming DM event:",t)}}addMessage(e){this._state.update(t=>{const s=[...t.messages,e];return s.sort((i,n)=>i.timestamp-n.timestamp),{...t,messages:s,latest:s[s.length-1]||null}})}updateMessageStatus(e,t){this._state.update(s=>({...s,messages:s.messages.map(i=>i.id===e?{...i,status:t}:i)}))}updateStatus(e){this._state.update(t=>({...t,status:e}))}setError(e){this._state.update(t=>({...t,error:e}))}getCurrentSubject(){let e;return this.subject.subscribe(s=>{e=s})(),e}extractSubjectFromRumor(e){var s;const t=(s=e.tags)==null?void 0:s.find(i=>i[0]==="subject");return t==null?void 0:t[1]}getCurrentMessages(){let e=[];return this.messages.subscribe(s=>{e=s})(),e}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}subscribe(e){return this.messages.subscribe(e)}}class tt{constructor(e){h(this,"_state");h(this,"subscription");h(this,"config");h(this,"roomId");h(this,"messages");h(this,"status");h(this,"latest");h(this,"subject");h(this,"participants");h(this,"error");var t;this.config=e,this.roomId=this.generateRoomId(),this._state=S({messages:[],status:"connecting",latest:null,subject:((t=e.options)==null?void 0:t.subject)||"Group Chat",participants:[...e.participants,e.senderPubkey],isTyping:!1,error:null}),this.messages=E(this._state,s=>s.messages),this.status=E(this._state,s=>s.status),this.latest=E(this._state,s=>s.latest),this.subject=E(this._state,s=>s.subject),this.participants=E(this._state,s=>s.participants),this.error=E(this._state,s=>s.error),this.initializeSubscription()}async send(e){var t,s;try{this.updateStatus("active");const i=this.generateMessageId(),n=Math.floor(Date.now()/1e3),r=this.getCurrentSubject(),o=this.getCurrentParticipants(),c={id:i,content:e,senderPubkey:this.config.senderPubkey,recipientPubkey:"",timestamp:n,isFromMe:!0,status:"sending",subject:r,participants:o};this.addMessage(c);const u={recipients:o.filter(f=>f!==this.config.senderPubkey).map(f=>({pubkey:f})),relayHint:(s=(t=this.config.options)==null?void 0:t.relayHints)==null?void 0:s[0]},g=await ce.createGiftWrappedDM(e,this.config.senderPrivateKey,u);let d=!1,p;for(const f of g.giftWraps)try{(await this.config.relayManager.publishToAll(f.giftWrap)).some(v=>v.success)&&(d=!0,c.eventId=f.giftWrap.id)}catch(w){p=w instanceof Error?w.message:"Publishing failed"}if(d)return this.updateMessageStatus(i,"sent"),this.config.debug&&console.log(`Room message sent successfully: ${i}`),{success:!0,messageId:i};{this.updateMessageStatus(i,"failed");const f=p||"Failed to publish to any relay";return this.setError(f),{success:!1,error:f,messageId:i}}}catch(i){const n=i instanceof Error?i.message:"Unknown error sending message";return this.setError(n),{success:!1,error:n}}}async updateSubject(e){try{return this._state.update(t=>({...t,subject:e})),{success:!0}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to update subject"}}}async addParticipant(e){try{return this.getCurrentParticipants().includes(e)?{success:!1,error:"Participant already in room"}:(this._state.update(s=>({...s,participants:[...s.participants,e]})),{success:!0})}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to add participant"}}}async removeParticipant(e){try{return this.getCurrentParticipants().includes(e)?e===this.config.senderPubkey?{success:!1,error:"Cannot remove yourself from room"}:(this._state.update(s=>({...s,participants:s.participants.filter(i=>i!==e)})),{success:!0}):{success:!1,error:"Participant not in room"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to remove participant"}}}clearHistory(){this._state.update(e=>({...e,messages:[],latest:null}))}async close(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.updateStatus("disconnected")}async retry(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.setError(null),await this.initializeSubscription()}async initializeSubscription(){var e;try{this.updateStatus("connecting");const t={kinds:[1059],"#p":[this.config.senderPubkey],limit:100},s={onEvent:i=>this.handleIncomingEvent(i),onEose:()=>{this.updateStatus("active"),this.config.debug&&console.log(`Room subscription active: ${this.roomId}`)},onClose:i=>{this.updateStatus("disconnected"),i&&this.setError(`Subscription closed: ${i}`)}};if(this.subscription=await this.config.subscriptionManager.subscribe([t],s),!this.subscription.success){const i=((e=this.subscription.error)==null?void 0:e.message)||"Failed to create subscription";this.setError(i),this.updateStatus("error")}}catch(t){const s=t instanceof Error?t.message:"Failed to initialize subscription";this.setError(s),this.updateStatus("error")}}async handleIncomingEvent(e){try{if(e.kind!==1059)return;const t=await ce.decryptGiftWrappedDM(e,this.config.senderPrivateKey);if(!t.isValid||!t.rumor){this.config.debug&&console.log("Failed to decrypt gift wrap or not for us");return}const s=this.getCurrentParticipants();if(!s.includes(t.senderPubkey)){this.config.debug&&console.log("Message not from room participant");return}const i=this.extractSubjectFromRumor(t.rumor),n=this.getCurrentSubject(),r={id:this.generateMessageId(),content:t.rumor.content,senderPubkey:t.senderPubkey,recipientPubkey:"",timestamp:t.rumor.created_at,isFromMe:!1,eventId:e.id,status:"received",subject:i||n,participants:s};this.getCurrentMessages().some(l=>l.eventId===e.id||l.content===r.content&&Math.abs(l.timestamp-r.timestamp)<5)||(this.addMessage(r),this.config.debug&&console.log(`Received room message from ${t.senderPubkey}: ${r.content}`))}catch(t){this.config.debug&&console.error("Error handling incoming room event:",t)}}addMessage(e){this._state.update(t=>{const s=[...t.messages,e];return s.sort((i,n)=>i.timestamp-n.timestamp),{...t,messages:s,latest:s[s.length-1]||null}})}updateMessageStatus(e,t){this._state.update(s=>({...s,messages:s.messages.map(i=>i.id===e?{...i,status:t}:i)}))}updateStatus(e){this._state.update(t=>({...t,status:e}))}setError(e){this._state.update(t=>({...t,error:e}))}getCurrentSubject(){let e="";return this.subject.subscribe(s=>{e=s})(),e}getCurrentParticipants(){let e=[];return this.participants.subscribe(s=>{e=s})(),e}getCurrentMessages(){let e=[];return this.messages.subscribe(s=>{e=s})(),e}extractSubjectFromRumor(e){var s;const t=(s=e.tags)==null?void 0:s.find(i=>i[0]==="subject");return t==null?void 0:t[1]}generateRoomId(){const t=[...this.config.participants,this.config.senderPubkey].sort().join(",");return`room_${Date.now()}_${t.slice(0,16)}`}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}subscribe(e){return this.messages.subscribe(e)}}class st{constructor(e){h(this,"conversations",new Map);h(this,"rooms",new Map);h(this,"config");h(this,"_senderPubkey",null);h(this,"_senderPrivateKey",null);h(this,"_conversationList",S([]));h(this,"conversations$");this.config=e,this.conversations$=this._conversationList,this.config.signingProvider&&this.initializeSender()}async with(e){const t=this.normalizePubkey(e);let s=this.conversations.get(t);return s||(s=await this.createConversation(t),this.conversations.set(t,s),this.updateConversationList(),this.config.debug&&console.log(`Created new DM conversation with ${t}`)),s}async room(e,t){const s=e.map(r=>this.normalizePubkey(r)),i=this.generateRoomId(s);let n=this.rooms.get(i);return n||(n=await this.createRoom(s,t),this.rooms.set(i,n),this.updateConversationList(),this.config.debug&&console.log(`Created new DM room: ${i} with ${s.length} participants`)),n}getConversations(){let e=[];return this.conversations$.subscribe(s=>{e=s})(),e}async closeConversation(e){const t=this.normalizePubkey(e),s=this.conversations.get(t);s&&(await s.close(),this.conversations.delete(t),this.updateConversationList(),this.config.debug&&console.log(`Closed DM conversation with ${t}`))}async closeRoom(e){const t=this.rooms.get(e);t&&(await t.close(),this.rooms.delete(e),this.updateConversationList(),this.config.debug&&console.log(`Closed DM room: ${e}`))}async closeAll(){const e=Array.from(this.conversations.values()).map(s=>s.close()),t=Array.from(this.rooms.values()).map(s=>s.close());await Promise.all([...e,...t]),this.conversations.clear(),this.rooms.clear(),this.updateConversationList(),this.config.debug&&console.log("Closed all DM conversations and rooms")}async updateSigningProvider(e){this.config.signingProvider=e,await this.initializeSender()}async startInboxSubscription(){if(!this._senderPubkey)throw new Error("Sender public key not available. Ensure signing provider is initialized.");try{const e={kinds:[1059],"#p":[this._senderPubkey],limit:50};await this.config.subscriptionManager.subscribe([e],{onEvent:t=>this.handleGlobalInboxEvent(t),onEose:()=>{this.config.debug&&console.log("Global DM inbox subscription active")}})}catch(e){throw this.config.debug&&console.error("Failed to start global inbox subscription:",e),e}}async initializeSender(){try{if(!this.config.signingProvider){this.config.debug&&console.log("DM module: No signing provider available yet");return}this._senderPubkey=await this.config.signingProvider.getPublicKey(),this.config.debug&&console.log(`DM module initialized for pubkey: ${this._senderPubkey}`)}catch(e){this.config.debug&&console.error("Failed to initialize sender credentials:",e)}}async createConversation(e){if(!this._senderPubkey)throw new Error("Sender public key not available. Call nostr.publish() or another method first to initialize signing.");const t=await this.getPrivateKeySecurely(),s={recipientPubkey:e,senderPrivateKey:t,senderPubkey:this._senderPubkey,subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,debug:this.config.debug},i=new et(s);return this.setupConversationReactivity(i),i}async createRoom(e,t){if(!this._senderPubkey)throw new Error("Sender public key not available. Call nostr.publish() or another method first to initialize signing.");const s=await this.getPrivateKeySecurely(),i={participants:e,senderPrivateKey:s,senderPubkey:this._senderPubkey,subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,options:t,debug:this.config.debug},n=new tt(i);return this.setupRoomReactivity(n),n}setupConversationReactivity(e){e.latest.subscribe(()=>{this.updateConversationList()}),e.subject.subscribe(()=>{this.updateConversationList()})}setupRoomReactivity(e){e.latest.subscribe(()=>{this.updateConversationList()}),e.subject.subscribe(()=>{this.updateConversationList()}),e.participants.subscribe(()=>{this.updateConversationList()})}updateConversationList(){const e=[];this.conversations.forEach((t,s)=>{let i=null,n="disconnected",r;const o=t.latest.subscribe(u=>{i=u}),c=t.status.subscribe(u=>{n=u}),l=t.subject.subscribe(u=>{r=u});o(),c(),l(),e.push({pubkey:s,latestMessage:i,lastActivity:(i==null?void 0:i.timestamp)||0,isActive:n==="active"||n==="connecting",subject:r,type:"conversation"})}),this.rooms.forEach((t,s)=>{let i=null,n="disconnected",r="",o=[];const c=t.latest.subscribe(d=>{i=d}),l=t.status.subscribe(d=>{n=d}),u=t.subject.subscribe(d=>{r=d}),g=t.participants.subscribe(d=>{o=d});c(),l(),u(),g(),e.push({pubkey:s,latestMessage:i,lastActivity:(i==null?void 0:i.timestamp)||0,isActive:n==="active"||n==="connecting",subject:r,participants:o,type:"room"})}),e.sort((t,s)=>s.lastActivity-t.lastActivity),this._conversationList.set(e)}async handleGlobalInboxEvent(e){this.config.debug&&console.log("Global inbox received event:",e.id)}normalizePubkey(e){if(e.startsWith("npub"))throw new Error("npub format not yet supported, please use hex pubkey");if(!/^[0-9a-f]{64}$/i.test(e))throw new Error("Invalid pubkey format. Expected 64-character hex string");return e.toLowerCase()}async getPrivateKeySecurely(){if(this.config.signingProvider&&"getPrivateKeyForEncryption"in this.config.signingProvider)try{const e=await this.config.signingProvider.getPrivateKeyForEncryption();if(this.config.debug&&console.log("üîê DMModule: Retrieved private key from signing provider:",{type:typeof e,length:e==null?void 0:e.length,isString:typeof e=="string",prefix:(e==null?void 0:e.substring(0,8))+"..."}),!e||typeof e!="string"||e.length!==64)throw new Error(`Invalid private key from signing provider: type=${typeof e}, length=${e==null?void 0:e.length}`);return e}catch(e){throw this.config.debug&&console.warn("Failed to get private key from signing provider:",e),e}if(process.env.NODE_ENV==="test"||this.config.debug)return console.warn("WARNING: Using mock private key for testing. Do not use in production!"),"test-private-key-64-char-string-abcdef1234567890abcdef1234567890";throw new Error("Private key access not yet implemented. This is required for NIP-44 encryption.")}generateRoomId(e){return[...e,this._senderPubkey].sort().join(",")}}class Zt{constructor(e){h(this,"config");h(this,"profileCache",new Map);h(this,"activeSubscriptions",new Map);h(this,"_myProfile",S(null));h(this,"_profileUpdates",S(new Map));h(this,"mine");h(this,"updates");this.config=e,this.mine=this._myProfile,this.updates=this._profileUpdates,this.config.signingProvider&&this.initializeOwnProfile()}async create(e){try{if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};const t=this.validateProfileData(e);if(!t.isValid)return{success:!1,error:`Invalid profile data: ${t.errors.join(", ")}`};const s=await this.config.signingProvider.getPublicKey(),i=await this.config.eventBuilder.kind(0).content(JSON.stringify(e)).build();if((await this.config.relayManager.publishToAll(i)).some(o=>o.success)){const o={pubkey:s,metadata:e,lastUpdated:i.created_at,eventId:i.id,isOwn:!0};return this._myProfile.set(o),this._profileUpdates.update(c=>(c.set(s,o),new Map(c))),this.cacheProfile(o),this.config.debug&&console.log("Profile created successfully:",o),{success:!0,eventId:i.id,profile:o}}else return{success:!1,error:"Failed to publish profile to any relay"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error creating profile"}}}async update(e){try{if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};const t=await this.getMine();if(!t)return e.name?this.create(e):{success:!1,error:"Name is required for profile creation"};const s={...t.metadata,...e},i=this.validateProfileData(s);if(!i.isValid)return{success:!1,error:`Invalid profile data: ${i.errors.join(", ")}`};const n=await this.config.signingProvider.getPublicKey(),r=await this.config.eventBuilder.kind(0).content(JSON.stringify(s)).build();if((await this.config.relayManager.publishToAll(r)).some(l=>l.success)){const l={pubkey:n,metadata:s,lastUpdated:r.created_at,eventId:r.id,isOwn:!0};return this._myProfile.set(l),this._profileUpdates.update(u=>(u.set(n,l),new Map(u))),this.cacheProfile(l),this.config.debug&&console.log("Profile updated successfully:",l),{success:!0,eventId:r.id,profile:l}}else return{success:!1,error:"Failed to publish profile update to any relay"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error updating profile"}}}async getMine(){if(!this.config.signingProvider)return null;try{const e=await this.config.signingProvider.getPublicKey();return this.get(e)}catch{return null}}async get(e,t={}){try{if(t.useCache!==!1){const i=this.getCachedProfile(e);if(i)return i}const s={kinds:[0],authors:[e],limit:1};return new Promise(i=>{let n=!1;const r=setTimeout(()=>{n||(n=!0,i(null))},t.timeout||5e3);this.config.subscriptionManager.subscribe([s],{onEvent:o=>{if(!n&&o.kind===0){n=!0,clearTimeout(r);try{const c=this.parseProfileEvent(o);this.cacheProfile(c),this._profileUpdates.update(l=>(l.set(e,c),new Map(l))),i(c)}catch{i(null)}}},onEose:()=>{n||(n=!0,clearTimeout(r),i(null))}})})}catch(s){return this.config.debug&&console.error("Error fetching profile:",s),null}}async updateSigningProvider(e){this.config.signingProvider=e,await this.initializeOwnProfile()}async close(){const e=Array.from(this.activeSubscriptions.values()).map(t=>this.config.subscriptionManager.close(t));await Promise.allSettled(e),this.activeSubscriptions.clear(),this.profileCache.clear(),this.config.subscriptionManager.close&&await this.config.subscriptionManager.close(),this.config.debug&&console.log("ProfileManager: Closed all subscriptions and cleared cache")}async initializeOwnProfile(){try{const e=await this.getMine();e&&(this._myProfile.set(e),this.config.debug&&console.log("Initialized own profile:",e))}catch(e){this.config.debug&&console.error("Failed to initialize own profile:",e)}}parseProfileEvent(e){var s;const t=JSON.parse(e.content);return(s=this.config.signingProvider)!=null&&s.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve(""),{pubkey:e.pubkey,metadata:t,lastUpdated:e.created_at,eventId:e.id,isOwn:!1}}validateProfileData(e){const t=[],s=[];return e.picture&&!this.isValidUrl(e.picture)&&t.push("Invalid picture URL"),e.banner&&!this.isValidUrl(e.banner)&&t.push("Invalid banner URL"),e.website&&!this.isValidUrl(e.website)&&t.push("Invalid website URL"),e.nip05&&!this.isValidNip05(e.nip05)&&s.push("Invalid NIP-05 identifier format"),e.about&&e.about.length>500&&s.push("About section is quite long"),{isValid:t.length===0,errors:t,warnings:s}}isValidUrl(e){try{return new URL(e),!0}catch{return!1}}isValidNip05(e){return/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(e)}cacheProfile(e){const t={profile:e,cachedAt:Date.now(),expiresAt:Date.now()+6e5};this.profileCache.set(e.pubkey,t)}getCachedProfile(e){const t=this.profileCache.get(e);return t&&t.expiresAt>Date.now()?t.profile:(t&&this.profileCache.delete(e),null)}}class Xt{constructor(e){h(this,"config");h(this,"contactCache",new Map);h(this,"activeSubscriptions",new Map);h(this,"_myContacts",S(null));h(this,"_contactUpdates",S(new Map));h(this,"mine");h(this,"updates");this.config=e,this.mine=E(this._myContacts,t=>t),this.updates=E(this._contactUpdates,t=>t),this.config.signingProvider&&this.initializeOwnContacts()}async follow(e){if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};try{const t=await this.getMine(),s=t?[...t.contacts]:[],i=s.findIndex(n=>n.pubkey===e.pubkey);return i>=0?s[i]={pubkey:e.pubkey,relayUrl:e.relayUrl,petname:e.petname}:s.push({pubkey:e.pubkey,relayUrl:e.relayUrl,petname:e.petname}),this.publishContactList(s)}catch(t){return this.config.debug&&console.error("Error following contact:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async unfollow(e){if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};try{const t=await this.getMine();if(!t)return{success:!1,error:"No contact list found"};const s=t.contacts.filter(i=>i.pubkey!==e.pubkey);return s.length===t.contacts.length?{success:!1,error:"Contact not found in list"}:this.publishContactList(s)}catch(t){return this.config.debug&&console.error("Error unfollowing contact:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getMine(){if(!this.config.signingProvider)return null;try{const e=await this.config.signingProvider.getPublicKey();return this.get(e)}catch{return null}}async get(e,t={}){try{if(t.useCache!==!1){const i=this.getCachedContactList(e);if(i)return i}const s={kinds:[3],authors:[e],limit:1};return new Promise(i=>{let n=!1;const r=setTimeout(()=>{n||(n=!0,i(null))},t.timeout||5e3);this.config.subscriptionManager.subscribe([s],{onEvent:o=>{if(!n&&o.kind===3){n=!0,clearTimeout(r);try{const c=this.parseContactEvent(o);this.cacheContactList(c),this._contactUpdates.update(l=>(l.set(e,c),new Map(l))),i(c)}catch{i(null)}}},onEose:()=>{n||(n=!0,clearTimeout(r),i(null))}})})}catch(s){return this.config.debug&&console.error("Error fetching contact list:",s),null}}async isFollowing(e){const t=await this.getMine();return t?t.contacts.some(s=>s.pubkey===e):!1}async getFollowing(){const e=await this.getMine();return e?e.contacts.map(t=>t.pubkey):[]}async updateSigningProvider(e){this.config.signingProvider=e,await this.initializeOwnContacts()}async close(){const e=Array.from(this.activeSubscriptions.values()).map(t=>this.config.subscriptionManager.close(t));await Promise.allSettled(e),this.activeSubscriptions.clear(),this.contactCache.clear(),this.config.subscriptionManager.close&&await this.config.subscriptionManager.close(),this.config.debug&&console.log("ContactManager: Closed all subscriptions and cleared cache")}async initializeOwnContacts(){try{const e=await this.getMine();e&&(this._myContacts.set(e),this.config.debug&&console.log("Initialized own contact list:",e))}catch(e){this.config.debug&&console.error("Failed to initialize own contact list:",e)}}async publishContactList(e){try{const t=await this.config.signingProvider.getPublicKey(),s=e.map(l=>{const u=["p",l.pubkey];return l.relayUrl&&u.push(l.relayUrl),l.petname&&u.push(l.petname),u}),i=await this.config.eventBuilder.kind(3).content("").tags(s).build(),n=await this.config.signingProvider.signEvent(i);if((await this.config.relayManager.publishToAll(n)).filter(l=>l.success).length===0)return{success:!1,error:"Failed to publish to any relay"};const c={contacts:e,ownerPubkey:t,lastUpdated:n.created_at,eventId:n.id,isOwn:!0};return this._myContacts.set(c),this._contactUpdates.update(l=>(l.set(t,c),new Map(l))),this.cacheContactList(c),this.config.debug&&console.log("Published contact list:",c),{success:!0,contactList:c,eventId:n.id}}catch(t){return this.config.debug&&console.error("Error publishing contact list:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}parseContactEvent(e){var s;const t=[];for(const i of e.tags)if(i[0]==="p"&&i[1]){const n={pubkey:i[1],relayUrl:i[2]||void 0,petname:i[3]||void 0};t.push(n)}return(s=this.config.signingProvider)!=null&&s.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve(""),{contacts:t,ownerPubkey:e.pubkey,lastUpdated:e.created_at,eventId:e.id,isOwn:!1}}getCachedContactList(e){const t=this.contactCache.get(e);return t?Date.now()-t.timestamp>t.ttl?(this.contactCache.delete(e),null):t.contactList:null}cacheContactList(e){const t={contactList:e,timestamp:Date.now(),ttl:3e5};this.contactCache.set(e.ownerPubkey,t)}}class Jt{constructor(e){h(this,"config");h(this,"threadCache",new Map);h(this,"activeSubscriptions",new Map);h(this,"_watchedThreads",S(new Map));h(this,"_threadUpdates",S(new Map));h(this,"watchedThreads");h(this,"updates");this.config=e,this.watchedThreads=E(this._watchedThreads,t=>t),this.updates=E(this._threadUpdates,t=>t)}async createThread(e){if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};try{const t=await this.config.signingProvider.getPublicKey(),s=[];if(e.mentions)for(const u of e.mentions)s.push(["p",u]);const i=await this.config.eventBuilder.kind(1).content(e.content).tags(s).build(),n=await this.config.signingProvider.signEvent(i);if((await this.config.relayManager.publishToAll(n)).filter(u=>u.success).length===0)return{success:!1,error:"Failed to publish to any relay"};const c={eventId:n.id,authorPubkey:t,content:e.content,createdAt:n.created_at,replyToEventId:null,rootEventId:n.id,mentionedPubkeys:e.mentions||[],depth:0,isOwn:!0},l={rootEventId:n.id,messages:[c],messageCount:1,lastActivity:n.created_at,isWatched:!1};return this.cacheThread(l),this._threadUpdates.update(u=>(u.set(n.id,l),new Map(u))),this.config.debug&&console.log("Created thread:",l),{success:!0,eventId:n.id,message:c}}catch(t){return this.config.debug&&console.error("Error creating thread:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async reply(e){if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};try{const t=await this.config.signingProvider.getPublicKey(),s=[];s.push(["e",e.replyToEventId,"","reply"]),e.rootEventId!==e.replyToEventId&&s.push(["e",e.rootEventId,"","root"]);const i=new Set(e.mentions||[]),n=await this.get(e.rootEventId);if(n){const g=n.messages.find(d=>d.eventId===e.replyToEventId);g&&i.add(g.authorPubkey)}for(const g of i)g!==t&&s.push(["p",g]);const r=await this.config.eventBuilder.kind(1).content(e.content).tags(s).build(),o=await this.config.signingProvider.signEvent(r);if((await this.config.relayManager.publishToAll(o)).filter(g=>g.success).length===0)return{success:!1,error:"Failed to publish to any relay"};const u={eventId:o.id,authorPubkey:t,content:e.content,createdAt:o.created_at,replyToEventId:e.replyToEventId,rootEventId:e.rootEventId,mentionedPubkeys:Array.from(i),depth:this.calculateDepth(e.replyToEventId,n),isOwn:!0};return n&&(n.messages.push(u),n.messageCount=n.messages.length,n.lastActivity=o.created_at,this.cacheThread(n),this._threadUpdates.update(g=>(g.set(e.rootEventId,n),new Map(g)))),this.config.debug&&console.log("Created reply:",u),{success:!0,eventId:o.id,message:u}}catch(t){return this.config.debug&&console.error("Error creating reply:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async get(e,t={}){try{if(t.useCache!==!1){const s=this.getCachedThread(e);if(s)return s}return this.fetchSimpleThread(e,t)}catch(s){return this.config.debug&&console.error("Error fetching thread:",s),null}}async fetchSimpleThread(e,t){const s=[{ids:[e],kinds:[1],limit:1},{kinds:[1],"#e":[e],limit:t.limit||100}];return new Promise(i=>{let n=!1;const r=[],o=new Set,c=setTimeout(()=>{if(!n)if(n=!0,r.length>0){const l=this.buildThread(e,r);this.cacheThread(l),i(l)}else i(null)},t.timeout||5e3);this.config.subscriptionManager.subscribe(s,{onEvent:l=>{if(l.kind===1&&!o.has(l.id)){o.add(l.id);const u=this.parseTextNoteEvent(l,e);u&&r.push(u)}},onEose:()=>{if(!n)if(n=!0,clearTimeout(c),r.length>0){const l=this.buildThread(e,r);this.cacheThread(l),this._threadUpdates.update(u=>(u.set(e,l),new Map(u))),i(l)}else i(null)}})})}async fetchCompleteThread(e,t){const s=[],i=new Set,n=new Set([e]),r=new Set;let o=0;const c=5;for(;n.size>0&&o<c;){o++;const u=Array.from(n);n.clear(),this.config.debug&&console.log(`Thread fetch phase ${o}: querying ${u.length} events`);const g=[];u.length>0&&g.push({ids:u,kinds:[1],limit:u.length});for(const p of u)r.has(p)||(g.push({kinds:[1],"#e":[p],limit:Math.floor((t.limit||100)/Math.max(1,o))}),r.add(p));if(g.length===0)break;const d=await this.fetchEventsWithFilters(g,e,i);for(const p of d)i.has(p.eventId)||(s.push(p),i.add(p.eventId),p.replyToEventId&&!i.has(p.replyToEventId)&&n.add(p.replyToEventId));if(this.config.debug&&console.log(`Phase ${o} complete: found ${d.length} new messages, ${n.size} more to query`),d.length===0)break}if(s.length===0)return null;const l=this.buildThread(e,s);return this.cacheThread(l),this._threadUpdates.update(u=>(u.set(e,l),new Map(u))),this.config.debug&&console.log(`Complete thread built: ${l.messageCount} messages across ${o} phases`),l}async fetchEventsWithFilters(e,t,s){return new Promise(i=>{const n=[];let r=!1;const o=setTimeout(()=>{r||(r=!0,i(n))},3e3);this.config.subscriptionManager.subscribe(e,{onEvent:c=>{if(c.kind===1&&!s.has(c.id)){const l=this.parseTextNoteEvent(c,t);l&&n.push(l)}},onEose:()=>{r||(r=!0,clearTimeout(o),i(n))}})})}async watch(e){try{const t=await this.get(e);if(!t)return!1;t.isWatched=!0,this.cacheThread(t),this._watchedThreads.update(n=>(n.set(e,t),new Map(n)));const s={kinds:[1],"#e":[e],since:Math.floor(Date.now()/1e3)},i=await this.config.subscriptionManager.subscribe([s],{onEvent:n=>{if(n.kind===1){const r=this.parseTextNoteEvent(n,e);r&&!t.messages.find(o=>o.eventId===r.eventId)&&(t.messages.push(r),t.messageCount=t.messages.length,t.lastActivity=r.createdAt,this.cacheThread(t),this._watchedThreads.update(o=>(o.set(e,{...t}),new Map(o))),this._threadUpdates.update(o=>(o.set(e,{...t}),new Map(o))))}}});return this.activeSubscriptions.set(e,i),this.config.debug&&console.log(`Started watching thread: ${e}`),!0}catch(t){return this.config.debug&&console.error("Error watching thread:",t),!1}}async unwatch(e){const t=this.activeSubscriptions.get(e);t&&(await this.config.subscriptionManager.close(t),this.activeSubscriptions.delete(e)),this._watchedThreads.update(i=>(i.delete(e),new Map(i)));const s=this.getCachedThread(e);s&&(s.isWatched=!1,this.cacheThread(s)),this.config.debug&&console.log(`Stopped watching thread: ${e}`)}async updateSigningProvider(e){this.config.signingProvider=e}async close(){const e=Array.from(this.activeSubscriptions.values()).map(t=>this.config.subscriptionManager.close(t));await Promise.allSettled(e),this.activeSubscriptions.clear(),this.threadCache.clear(),this.config.subscriptionManager.close&&await this.config.subscriptionManager.close(),this.config.debug&&console.log("ThreadManager: Closed all subscriptions and cleared cache")}parseTextNoteEvent(e,t){var s;try{const i=this.parseNIP10Tags(e.tags),n=i.find(f=>f.meaning==="root"),r=i.find(f=>f.meaning==="reply"),o=i.filter(f=>f.meaning==="mention"),c=i.filter(f=>f.tagType==="e");let l,u=null,g=!1;if(n)l=n.value,g=l===t;else if(r)r.value===t?(l=t,g=!0):(l=r.value,g=c.some(f=>f.value===t),g&&(l=t));else if(e.id===t)l=e.id,g=!0;else if(c.find(w=>w.value===t))l=t,g=!0;else return null;if(!g)return null;if(r)u=r.value;else if(c.length>0&&e.id!==l)if(c.length===1)u=c[0].value;else{const f=c[c.length-1];f.value!==l&&(u=f.value)}const d=o.map(f=>f.value),p=(s=this.config.signingProvider)!=null&&s.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve("");return{eventId:e.id,authorPubkey:e.pubkey,content:e.content,createdAt:e.created_at,replyToEventId:u,rootEventId:l,mentionedPubkeys:d,depth:0,isOwn:!1}}catch(i){return this.config.debug&&console.error("Error parsing text note event:",i),null}}parseNIP10Tags(e){const t=[];for(const i of e){if(i.length<2)continue;const[n,r,o,c]=i;if(n==="e"){let l="mention";c==="reply"?l="reply":c==="root"&&(l="root"),t.push({tagType:"e",value:r,relayUrl:o||void 0,marker:c||void 0,meaning:l})}else n==="p"&&t.push({tagType:"p",value:r,relayUrl:o||void 0,marker:c||void 0,meaning:"mention"})}const s=t.filter(i=>i.tagType==="e");return s.length>0&&!s.some(i=>i.marker)&&(s.length===1?s[0].meaning="reply":s.length>=2&&(s[0].meaning="root",s[s.length-1].meaning="reply")),t}buildThread(e,t){t.sort((n,r)=>n.createdAt-r.createdAt);const s=new Map;for(const n of t)s.set(n.eventId,n),n.depth=-1;for(const n of t)n.depth===-1&&(n.depth=this.calculateMessageDepth(n,s));const i=t.length>0?Math.max(...t.map(n=>n.createdAt)):0;return{rootEventId:e,messages:t,messageCount:t.length,lastActivity:i,isWatched:!1}}calculateMessageDepth(e,t){if(!e.replyToEventId||e.eventId===e.rootEventId)return 0;const s=t.get(e.replyToEventId);return s?((s.depth===void 0||s.depth<0)&&(s.depth=this.calculateMessageDepth(s,t)),s.depth+1):1}calculateDepth(e,t){if(!t||!e)return 1;const s=t.messages.find(i=>i.eventId===e);return s?s.depth+1:1}getCachedThread(e){const t=this.threadCache.get(e);return t?Date.now()-t.timestamp>t.ttl?(this.threadCache.delete(e),null):t.thread:null}cacheThread(e){const t={thread:e,timestamp:Date.now(),ttl:3e5};this.threadCache.set(e.rootEventId,t)}}class Qt{constructor(e){h(this,"config");h(this,"reactionCache",new Map);h(this,"activeSubscriptions",new Map);h(this,"_reactionUpdates",S(new Map));h(this,"_watchedEvents",S(new Map));h(this,"updates");h(this,"watchedEvents");this.config=e,this.updates=E(this._reactionUpdates,t=>t),this.watchedEvents=E(this._watchedEvents,t=>t)}async react(e){if(!this.config.signingProvider)return{success:!1,error:"No signing provider available"};try{const t=await this.config.signingProvider.getPublicKey(),s=await this.getReactions(e.targetEventId,{useCache:!1});if(s&&s.reactions.find(d=>d.authorPubkey===t))return{success:!1,error:"User has already reacted to this event"};const i=[["e",e.targetEventId],["p",e.targetAuthorPubkey]],n=await this.config.eventBuilder.kind(7).content(e.reactionType).tags(i).build(),r=await this.config.signingProvider.signEvent(n);if((await this.config.relayManager.publishToAll(r)).filter(g=>g.success).length===0)return{success:!1,error:"Failed to publish to any relay"};const l={eventId:r.id,authorPubkey:t,targetEventId:e.targetEventId,targetAuthorPubkey:e.targetAuthorPubkey,reactionType:e.reactionType,createdAt:r.created_at,isOwn:!0},u=this.getCachedReactions(e.targetEventId);return u&&(u.reactions.push(l),u.summary=this.aggregateReactions(u.reactions,t),u.timestamp=Date.now(),this.reactionCache.set(e.targetEventId,u),this._reactionUpdates.update(g=>(g.set(e.targetEventId,u.summary),new Map(g)))),this.config.debug&&console.log("Created reaction:",l),{success:!0,eventId:r.id,reaction:l}}catch(t){return this.config.debug&&console.error("Error creating reaction:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getReactions(e,t={}){try{if(t.useCache!==!1){const s=this.getCachedReactions(e);if(s)return s}return this.fetchReactions(e,t)}catch(s){return this.config.debug&&console.error("Error fetching reactions:",s),null}}async getSummary(e,t={}){const s=await this.getReactions(e,t);return(s==null?void 0:s.summary)||null}async watch(e){try{const t=await this.getReactions(e);if(t)this._watchedEvents.update(n=>(n.set(e,t.summary),new Map(n)));else{const n=this.config.signingProvider?await this.config.signingProvider.getPublicKey():"",r={targetEventId:e,totalCount:0,reactions:{},userReacted:!1};this._watchedEvents.update(o=>(o.set(e,r),new Map(o)))}const s={kinds:[7],"#e":[e],since:Math.floor(Date.now()/1e3)},i=await this.config.subscriptionManager.subscribe([s],{onEvent:n=>{if(n.kind===7){const r=this.parseReactionEvent(n);r&&r.targetEventId===e&&this.handleNewReaction(r)}}});return this.activeSubscriptions.set(e,i),this.config.debug&&console.log(`Started watching reactions for event: ${e}`),!0}catch(t){return this.config.debug&&console.error("Error watching reactions:",t),!1}}async unwatch(e){const t=this.activeSubscriptions.get(e);t&&(await this.config.subscriptionManager.close(t),this.activeSubscriptions.delete(e)),this._watchedEvents.update(s=>(s.delete(e),new Map(s))),this.config.debug&&console.log(`Stopped watching reactions for event: ${e}`)}async updateSigningProvider(e){this.config.signingProvider=e}async close(){const e=Array.from(this.activeSubscriptions.values()).map(t=>this.config.subscriptionManager.close(t));await Promise.allSettled(e),this.activeSubscriptions.clear(),this.reactionCache.clear(),this.config.debug&&console.log("ReactionManager: Closed all subscriptions and cleared cache")}async fetchReactions(e,t){const s=[{kinds:[7],"#e":[e],limit:t.limit||100}];return new Promise(i=>{let n=!1;const r=[],o=new Set,c=setTimeout(()=>{if(!n)if(n=!0,r.length>0){const l=this.buildReactionCache(e,r);this.cacheReactions(e,l),i(l)}else i(null)},t.timeout||5e3);this.config.subscriptionManager.subscribe(s,{onEvent:l=>{if(l.kind===7&&!o.has(l.id)){o.add(l.id);const u=this.parseReactionEvent(l);u&&u.targetEventId===e&&r.push(u)}},onEose:()=>{if(!n)if(n=!0,clearTimeout(c),r.length>0){const l=this.buildReactionCache(e,r);this.cacheReactions(e,l),i(l)}else i(null)}})})}parseReactionEvent(e){var t;try{const s=e.tags.find(r=>r[0]==="e");if(!s||s.length<2)return null;const i=e.tags.find(r=>r[0]==="p");if(!i||i.length<2)return null;const n=(t=this.config.signingProvider)!=null&&t.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve("");return{eventId:e.id,authorPubkey:e.pubkey,targetEventId:s[1],targetAuthorPubkey:i[1],reactionType:e.content,createdAt:e.created_at,isOwn:!1}}catch(s){return this.config.debug&&console.error("Error parsing reaction event:",s),null}}buildReactionCache(e,t){var i;const s=(i=this.config.signingProvider)!=null&&i.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve("");return{summary:this.aggregateReactions(t,s),reactions:t,timestamp:Date.now(),ttl:3e5}}aggregateReactions(e,t){var r;const s={};let i=!1,n;for(const o of e)typeof t=="string"&&(o.isOwn=o.authorPubkey===t,o.isOwn&&(i=!0,n=o.reactionType)),s[o.reactionType]||(s[o.reactionType]={type:o.reactionType,count:0,authors:[]}),s[o.reactionType].count++,s[o.reactionType].authors.includes(o.authorPubkey)||s[o.reactionType].authors.push(o.authorPubkey);return{targetEventId:((r=e[0])==null?void 0:r.targetEventId)||"",totalCount:e.length,reactions:s,userReacted:i,userReactionType:n}}handleNewReaction(e){var s;const t=this.getCachedReactions(e.targetEventId);if(t){t.reactions.push(e);const i=(s=this.config.signingProvider)!=null&&s.getPublicKey?this.config.signingProvider.getPublicKey():Promise.resolve("");t.summary=this.aggregateReactions(t.reactions,i),t.timestamp=Date.now()}this._reactionUpdates.update(i=>{const n=(t==null?void 0:t.summary)||this.aggregateReactions([e],"");return i.set(e.targetEventId,n),new Map(i)}),this._watchedEvents.update(i=>{const n=(t==null?void 0:t.summary)||this.aggregateReactions([e],"");return i.set(e.targetEventId,n),new Map(i)})}getCachedReactions(e){const t=this.reactionCache.get(e);return t?Date.now()-t.timestamp>t.ttl?(this.reactionCache.delete(e),null):t:null}cacheReactions(e,t){this.reactionCache.set(e,t)}}class qt{constructor(e){h(this,"config");h(this,"feedCache",new Map);h(this,"activeSubscriptions",new Map);h(this,"_globalFeed",S([]));h(this,"_followingFeed",S([]));h(this,"globalFeed");h(this,"followingFeed");this.config=e,this.globalFeed=E(this._globalFeed,t=>t),this.followingFeed=E(this._followingFeed,t=>t)}async getGlobalFeed(e={}){const t=[{kinds:e.kinds||[1],limit:e.limit||50,since:e.since,until:e.until}];return this.fetchFeed("global",t)}async getFollowingFeed(e={}){if(!this.config.signingProvider)return[];try{const t=await this.config.signingProvider.getPublicKey(),s=await this.config.contactManager.getContacts(t);if(!s||s.followingList.length===0)return[];const i=[{kinds:e.kinds||[1],authors:s.followingList,limit:e.limit||50,since:e.since,until:e.until}];return this.fetchFeed("following",i)}catch(t){return this.config.debug&&console.error("Error getting following feed:",t),[]}}async startFeedUpdates(){const e={kinds:[1],since:Math.floor(Date.now()/1e3),limit:20},t=await this.config.subscriptionManager.subscribe([e],{onEvent:s=>{const i=this.eventToFeedItem(s);this._globalFeed.update(n=>[i,...n.slice(0,99)])}});if(this.activeSubscriptions.set("global-updates",t),this.config.signingProvider)try{const s=await this.config.signingProvider.getPublicKey(),i=await this.config.contactManager.getContacts(s);if(i&&i.followingList.length>0){const n={kinds:[1],authors:i.followingList,since:Math.floor(Date.now()/1e3),limit:20},r=await this.config.subscriptionManager.subscribe([n],{onEvent:o=>{const c=this.eventToFeedItem(o);this._followingFeed.update(l=>[c,...l.slice(0,99)])}});this.activeSubscriptions.set("following-updates",r)}}catch(s){this.config.debug&&console.error("Error setting up following feed updates:",s)}}async stopFeedUpdates(){for(const[e,t]of this.activeSubscriptions.entries())await this.config.subscriptionManager.close(t);this.activeSubscriptions.clear()}async updateSigningProvider(e){this.config.signingProvider=e}async close(){await this.stopFeedUpdates(),this.feedCache.clear(),this.config.debug&&console.log("FeedManager: Closed all subscriptions and cleared cache")}async fetchFeed(e,t){return new Promise(s=>{let i=!1;const n=[],r=new Set,o=setTimeout(()=>{i||(i=!0,this.updateFeedStore(e,n),s(n))},1e4);this.config.subscriptionManager.subscribe(t,{onEvent:c=>{if(!r.has(c.id)){r.add(c.id);const l=this.eventToFeedItem(c);n.push(l)}},onEose:()=>{i||(i=!0,clearTimeout(o),n.sort((c,l)=>l.createdAt-c.createdAt),this.updateFeedStore(e,n),s(n))}})})}eventToFeedItem(e){return{eventId:e.id,authorPubkey:e.pubkey,content:e.content,createdAt:e.created_at,kind:e.kind,tags:e.tags,authorProfile:void 0,reactionSummary:void 0,threadInfo:void 0}}updateFeedStore(e,t){e==="global"?this._globalFeed.set(t):e==="following"&&this._followingFeed.set(t),this.feedCache.set(e,t)}}class es{constructor(e){h(this,"config");h(this,"_profileManager");h(this,"_contactManager");h(this,"_threadManager");h(this,"_reactionManager");h(this,"_feedManager");h(this,"profiles");h(this,"contacts");h(this,"threads");h(this,"reactions");h(this,"feeds");this.config=e,this._profileManager=new Zt({subscriptionManager:e.subscriptionManager,relayManager:e.relayManager,signingProvider:e.signingProvider,eventBuilder:e.eventBuilder,debug:e.debug}),this.profiles=this._profileManager,this.contacts=this.getContactManager(),this.threads=this.getThreadManager(),this.reactions=this.getReactionManager(),this.feeds=this.getFeedManager(),this.config.debug&&console.log("SocialModule initialized with all managers")}async updateSigningProvider(e){this.config.signingProvider=e,await this._profileManager.updateSigningProvider(e),this._contactManager&&await this._contactManager.updateSigningProvider(e),this._threadManager&&await this._threadManager.updateSigningProvider(e),this._reactionManager&&await this._reactionManager.updateSigningProvider(e),this._feedManager&&await this._feedManager.updateSigningProvider(e),this.config.debug&&console.log("SocialModule: Updated signing provider for all managers")}async getEvent(e){throw new Error("getEvent not yet implemented")}async close(){var e,t,s,i;await Promise.all([this._profileManager.close(),(e=this._contactManager)==null?void 0:e.close(),(t=this._threadManager)==null?void 0:t.close(),(s=this._reactionManager)==null?void 0:s.close(),(i=this._feedManager)==null?void 0:i.close()]),this.config.debug&&console.log("SocialModule: All managers closed")}getContactManager(){return this._contactManager||(this._contactManager=new Xt({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,eventBuilder:this.config.eventBuilder,profileManager:this._profileManager,debug:this.config.debug})),this._contactManager}getThreadManager(){return this._threadManager||(this._threadManager=new Jt({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,eventBuilder:this.config.eventBuilder,profileManager:this._profileManager,debug:this.config.debug})),this._threadManager}getReactionManager(){return this._reactionManager||(this._reactionManager=new Qt({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,eventBuilder:this.config.eventBuilder,debug:this.config.debug})),this._reactionManager}getFeedManager(){return this._feedManager||(this._feedManager=new qt({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,profileManager:this._profileManager,contactManager:this.getContactManager(),reactionManager:this.getReactionManager(),debug:this.config.debug})),this._feedManager}}class it{constructor(e){h(this,"subscriptions",new Map);h(this,"eventCallbacks",new Map);h(this,"debug");this.relayManager=e,this.debug=e.debug||!1,this.setupRelayMessageHandling()}async subscribe(e,t={}){var s,i,n,r;try{const o=this.validateFilters(e);if(o)return{subscription:{},success:!1,relayResults:[],error:o};const c=this.generateSubscriptionId(),l=Date.now(),u=t.relays||this.relayManager.connectedRelays.length>0?this.relayManager.connectedRelays:this.relayManager.relayUrls,g={id:c,filters:e,relays:u,state:"pending",createdAt:l,eventCount:0,onEvent:t.onEvent,onEose:t.onEose,onClose:t.onClose,relayStates:{},eoseRelays:new Set,receivedEventIds:new Set};u.forEach(v=>{g.relayStates[v]="active"}),t.timeout&&(g.timeoutId=setTimeout(()=>{this.handleSubscriptionTimeout(c)},t.timeout)),this.subscriptions.set(c,g),this.debug&&console.log(`Creating subscription ${c} with ${e.length} filters`);const d=t.retryAttempts||1,p=t.retryDelay||1e3;let f=[],w;for(let v=0;v<d;v++)try{const M=["REQ",c,...e];try{await((i=(s=this.relayManager).sendToAll)==null?void 0:i.call(s,M)),f=u.map(D=>({relay:D,success:!0,error:void 0}));break}catch(D){f=[];let J=!1;for(const re of u)try{await((r=(n=this.relayManager).sendToRelays)==null?void 0:r.call(n,[re],M)),f.push({relay:re,success:!0,error:void 0}),J=!0}catch(A){f.push({relay:re,success:!1,error:A instanceof Error?A:new Error("Unknown error")})}if(J)break;w=D instanceof Error?D:new Error("All relays failed")}}catch(M){w=M instanceof Error?M:new Error("Unknown error"),f=u.map(D=>({relay:D,success:!1,error:w})),v<d-1&&await new Promise(D=>setTimeout(D,p))}const I=f.length>0&&f.some(v=>v.success);return I||(this.subscriptions.delete(c),g.timeoutId&&clearTimeout(g.timeoutId)),{subscription:I?this.externalizeSubscription(g):{},success:I,relayResults:f,error:I?void 0:{message:w?w.message:f.length===0?"No relays available":"All relays failed",retryable:!0}}}catch(o){return{subscription:{},success:!1,relayResults:[],error:{message:o instanceof Error?o.message:"Unknown error",retryable:!0}}}}async activate(e){var s,i,n,r;const t=this.subscriptions.get(e);if(!t)throw new Error(`Subscription ${e} not found`);t.state="active";try{const o=["REQ",e,...t.filters],c=this.relayManager.connectedRelays;t.relays.length!==c.length||!t.relays.every(u=>c.includes(u))?await((i=(s=this.relayManager).sendToRelays)==null?void 0:i.call(s,t.relays,o)):await((r=(n=this.relayManager).sendToAll)==null?void 0:r.call(n,o))}catch(o){throw t.state="error",o}}async markEose(e,t){const s=this.subscriptions.get(e);s&&(s.eoseRelays.add(t),s.state="eose",s.onEose&&s.onEose(t))}async close(e,t){var i,n;const s=this.subscriptions.get(e);if(s){s.state="closed",s.timeoutId&&(clearTimeout(s.timeoutId),s.timeoutId=void 0);try{const r=["CLOSE",e];await((n=(i=this.relayManager).sendToAll)==null?void 0:n.call(i,r))}catch(r){this.debug&&console.error(`Error sending CLOSE for ${e}:`,r)}s.onClose&&s.onClose(t)}}async closeAll(){const e=this.getActiveSubscriptions();await Promise.all(e.map(t=>this.close(t.id,"closeAll")))}async handleEvent(e,t){const s=this.subscriptions.get(e);s&&(s.receivedEventIds.has(t.id)||(s.receivedEventIds.add(t.id),s.eventCount++,s.lastEventAt=Date.now(),s.onEvent&&s.onEvent(t)))}async handleEventBatch(e,t){const s=this.subscriptions.get(e);if(!s)return;const i=[];for(const n of t)s.receivedEventIds.has(n.id)||(s.receivedEventIds.add(n.id),i.push(n));if(s.eventCount+=i.length,s.lastEventAt=Date.now(),s.onEvent&&i.length>0)for(const n of i)s.onEvent(n)}async handleRelayEvent(e,t,s){await this.handleEvent(t,s)}async handleRelayMessage(e,t){const[s,i,...n]=t;switch(s){case"EVENT":const r=n[0];await this.handleRelayEvent(e,i,r);break;case"EOSE":await this.markEose(i,e);break;case"NOTICE":this.debug&&console.log(`Notice from ${e}:`,n[0]);break}}async handleRelayDisconnection(e){this.subscriptions.forEach(t=>{t.relayStates[e]&&(t.relayStates[e]="disconnected")})}async handleRelayManagerUpdate(){const e=this.relayManager.connectedRelays;this.subscriptions.forEach(t=>{t.relays.forEach(s=>{e.includes(s)?t.relayStates[s]="active":t.relayStates[s]="disconnected"})})}getSubscription(e){const t=this.subscriptions.get(e);return t?this.externalizeSubscription(t):void 0}getActiveSubscriptions(){return Array.from(this.subscriptions.values()).filter(e=>e.state!=="closed").map(e=>this.externalizeSubscription(e))}getSubscriptionStats(e){const t=this.subscriptions.get(e);if(!t)throw new Error(`Subscription ${e} not found`);return{relayStates:{...t.relayStates},eoseCount:t.eoseRelays.size,eventCount:t.eventCount}}generateSubscriptionId(){return Array.from({length:16},()=>Math.floor(Math.random()*16).toString(16)).join("")}validateFilters(e){if(!Array.isArray(e)||e.length===0)return{message:"Invalid filter: must be non-empty array",retryable:!1};for(const t of e){if(t==null||typeof t!="object")return{message:"Invalid filter: must be object",retryable:!1};if(t.hasOwnProperty("invalid"))return{message:"Invalid filter: contains invalid properties",retryable:!1};if(t.kinds&&!Array.isArray(t.kinds))return{message:"Invalid filter: kinds must be array",retryable:!1}}return null}async sendSubscriptionToRelays(e,t){const s=[],i=["REQ",e.id,...e.filters];if(this.relayManager.sendToRelays)for(const n of e.relays)try{await this.relayManager.sendToRelays([n],i),s.push({relay:n,success:!0,subscriptionId:e.id})}catch(r){s.push({relay:n,success:!1,error:r instanceof Error?r.message:"Unknown error",subscriptionId:e.id})}else try{this.relayManager.sendToAll?(await this.relayManager.sendToAll(i),e.relays.forEach(n=>{s.push({relay:n,success:!0,subscriptionId:e.id})})):e.relays.forEach(n=>{s.push({relay:n,success:!0,subscriptionId:e.id})})}catch(n){e.relays.forEach(r=>{s.push({relay:r,success:!1,error:n instanceof Error?n.message:"Unknown error",subscriptionId:e.id})})}return s}handleSubscriptionTimeout(e){const t=this.subscriptions.get(e);t&&(t.state="error",t.onClose&&t.onClose("Subscription timeout"),this.subscriptions.delete(e))}externalizeSubscription(e){return new Proxy(e,{get(t,s){if(!(s==="timeoutId"||s==="relayStates"||s==="eoseRelays"||s==="receivedEventIds"))return t[s]},set(t,s,i){return s==="eventCount"||s==="lastEventAt"||s==="state"?(t[s]=i,!0):!1}})}setupRelayMessageHandling(){this.relayManager.setMessageHandler((e,t)=>{this.handleRelayMessage(e,t)})}}class ts{constructor(e={}){h(this,"relayManager");h(this,"subscriptionManager");h(this,"signingProvider");h(this,"signingMethod");h(this,"config");h(this,"events");h(this,"dm");h(this,"social");console.log("üî• NostrUnchained v0.1.0-FIX (build:",new Date().toISOString().substring(0,19)+"Z)"),this.config={relays:e.relays??Be,debug:e.debug??!1,retryAttempts:e.retryAttempts??ee.RETRY_ATTEMPTS,retryDelay:e.retryDelay??ee.RETRY_DELAY,timeout:e.timeout??ee.PUBLISH_TIMEOUT,signingProvider:e.signingProvider},this.relayManager=new ze(this.config.relays,{debug:this.config.debug}),this.subscriptionManager=new it(this.relayManager),this.events=new Ze(this),this.dm=new st({subscriptionManager:this.subscriptionManager,relayManager:this.relayManager,signingProvider:void 0,debug:this.config.debug}),this.social=new es({subscriptionManager:this.subscriptionManager,relayManager:this.relayManager,signingProvider:void 0,eventBuilder:new C,debug:this.config.debug}),this.config.signingProvider?(this.signingProvider=this.config.signingProvider,this.signingMethod="temporary",this.config.debug&&console.log("üéØ NostrUnchained initialized with PROVIDED signing provider (should be TemporarySigner)")):this.config.debug&&console.log("üö® NostrUnchained initialized WITHOUT signing provider - will auto-detect later"),this.config.debug&&console.log("NostrUnchained initialized with relays:",this.config.relays)}get relays(){return this.relayManager.relayUrls}get connectedRelays(){return this.relayManager.connectedRelays}async initializeSigning(){if(this.signingProvider){this.config.debug&&console.log(`üö´ Signing already initialized with method: ${this.signingMethod} - KEEPING IT!`);return}else{const{provider:e,method:t}=await je.createBestAvailable();this.signingProvider=e,this.signingMethod=t,this.config.debug&&console.log(`üîç Auto-detected signing with method: ${this.signingMethod} (this should NOT happen for temp accounts!)`)}await this.dm.updateSigningProvider(this.signingProvider),await this.social.updateSigningProvider(this.signingProvider),this.config.debug&&console.log(`Initialized signing with method: ${this.signingMethod}`)}async connect(){try{if(await this.relayManager.connect(),this.config.debug){const e=this.relayManager.getStats();console.log("Relay connection stats:",e)}}catch(e){throw _.handleConnectionError("relays",e)}}async disconnect(){await this.relayManager.disconnect()}async publish(e){const t=Date.now();let s={};try{await this.initializeSigning(),s.signingMethod=this.signingMethod;const i=await this.signingProvider.getPublicKey(),n=await C.createEvent(e,i),r=C.addEventId(n),o=await this.signingProvider.signEvent(n),c={...r,sig:o};if(this.connectedRelays.length===0){const d=Date.now();await this.connect(),s.connectionAttempts=Date.now()-d}const l=await this.relayManager.publishToAll(c);this.config.debug&&(s.relayLatencies={},l.forEach(d=>{d.latency&&(s.relayLatencies[d.relay]=d.latency)}));const u=_.analyzeRelayResults(l);s.totalTime=Date.now()-t;const g={success:u.success,eventId:c.id,event:c,relayResults:l,timestamp:Date.now(),error:u.error,debug:this.config.debug?s:void 0};return this.config.debug&&console.log("Publish result:",g),g}catch(i){s.totalTime=Date.now()-t;let n;return i instanceof Error?i.message.includes("Content")?n=_.handleContentError(e):i.message.includes("sign")||i.message.includes("extension")?n=_.handleSigningError(i):n=_.handleConnectionError("relay",i):n=_.createError("network","Unknown error occurred",{retryable:!0}),{success:!1,relayResults:[],timestamp:Date.now(),error:n,debug:this.config.debug?s:void 0}}}async createEvent(e){await this.initializeSigning();const t=await this.signingProvider.getPublicKey(),s=await C.createEvent(e.content,t,{kind:e.kind,tags:e.tags,created_at:e.created_at}),i=C.addEventId(s),n=await this.signingProvider.signEvent(s);return{...i,sig:n}}calculateEventId(e){return C.calculateEventId(e)}async verifyEvent(e){return C.verifyEventId(e)}async hasExtension(){return await ge.isAvailable()}async getExtensionPubkey(){if(!await this.hasExtension())throw new Error("No browser extension available");return await new ge().getPublicKey()}async getRelayInfo(e){return await this.relayManager.getRelayInfo(e)}async testRelay(e){return await this.relayManager.testRelay(e)}async publishEvent(e){const t=Date.now();let s={};try{if(this.connectedRelays.length===0){const o=Date.now();await this.connect(),s.connectionAttempts=Date.now()-o}const i=await this.relayManager.publishToAll(e);this.config.debug&&(s.relayLatencies={},i.forEach(o=>{o.latency&&(s.relayLatencies[o.relay]=o.latency)}));const n=_.analyzeRelayResults(i);s.totalTime=Date.now()-t;const r={success:n.success,eventId:e.id,event:e,relayResults:i,timestamp:Date.now(),error:n.error,debug:this.config.debug?s:void 0};return this.config.debug&&console.log("PublishEvent result:",r),r}catch(i){s.totalTime=Date.now()-t;let n;return i instanceof Error?n=_.handleConnectionError("relay",i):n=_.createError("network","Unknown error occurred",{retryable:!0}),{success:!1,relayResults:[],timestamp:Date.now(),error:n,debug:this.config.debug?s:void 0}}}getStats(){return this.relayManager.getStats()}getSubscriptionManager(){return this.subscriptionManager}}class Pe{constructor(e={},t){h(this,"state");h(this,"subscriptionManager");this.state={...e},this.subscriptionManager=t}clone(e={}){return new Pe({...this.state,...e},this.subscriptionManager)}kinds(e){if(!Array.isArray(e)||e.length===0)throw new Error("kinds cannot be empty");for(const s of e){if(typeof s!="number")throw new Error("kinds must be numbers");if(!Number.isInteger(s))throw new Error("kinds must be integers")}const t=Array.from(new Set(e));return this.clone({kinds:t})}authors(e){if(!Array.isArray(e)||e.length===0)throw new Error("authors cannot be empty");for(const s of e)if(typeof s!="string")throw new Error("authors must be strings");const t=Array.from(new Set(e));return this.clone({authors:t})}ids(e){if(!Array.isArray(e)||e.length===0)throw new Error("ids cannot be empty");for(const s of e)if(typeof s!="string")throw new Error("ids must be strings");const t=Array.from(new Set(e));return this.clone({ids:t})}since(e){if(typeof e!="number")throw new Error("since must be a number");if(e<0)throw new Error("since must be positive");return this.clone({since:e})}until(e){if(typeof e!="number")throw new Error("until must be a number");if(e<0)throw new Error("until must be positive");return this.clone({until:e})}limit(e){if(typeof e!="number")throw new Error("limit must be a number");if(e<=0)throw new Error("limit must be positive");return this.clone({limit:e})}tags(e,t){if(typeof e!="string"||e.length===0)throw new Error("tag name must be a non-empty string");if(!Array.isArray(t)||t.length===0)throw new Error("tag values cannot be empty");const s={...this.state.tags},i=e;return s[i]?s[i]=Array.from(new Set([...s[i],...t])):s[i]=Array.from(new Set(t)),this.clone({tags:s})}search(e){if(typeof e!="string"||e.length===0)throw new Error("search query must be a non-empty string");return this.clone({search:e})}union(e){const t=e,s=this.state.unionWith||[];return this.clone({unionWith:[...s,t]})}intersect(e){const t=e,s={...this.state},i=t.state;if(i.kinds&&(s.kinds?s.kinds=Array.from(new Set([...s.kinds,...i.kinds])):s.kinds=[...i.kinds]),i.authors&&(s.authors?s.authors=Array.from(new Set([...s.authors,...i.authors])):s.authors=[...i.authors]),i.tags){const n={...s.tags};for(const[r,o]of Object.entries(i.tags))n[r]?n[r]=Array.from(new Set([...n[r],...o])):n[r]=[...o];s.tags=n}return i.since!==void 0&&(s.since=Math.max(s.since||0,i.since)),i.until!==void 0&&(s.until!==void 0?s.until=Math.min(s.until,i.until):s.until=i.until),i.limit!==void 0&&(s.limit!==void 0?s.limit=Math.min(s.limit,i.limit):s.limit=i.limit),this.clone(s)}toFilter(){const e=[];if(this.state.unionWith&&this.state.unionWith.length>0){const t=this.compileStateToFilter(this.state);Object.keys(t).length>0&&e.push(t);for(const s of this.state.unionWith){const i=s.toFilter();e.push(...i)}}else{const t=this.compileStateToFilter(this.state);e.push(t)}return e}compileStateToFilter(e){const t={};if(e.kinds&&e.kinds.length>0&&(t.kinds=e.kinds),e.authors&&e.authors.length>0&&(t.authors=e.authors),e.ids&&e.ids.length>0&&(t.ids=e.ids),e.since!==void 0&&(t.since=e.since),e.until!==void 0&&(t.until=e.until),e.limit!==void 0&&(t.limit=e.limit),e.tags)for(const[s,i]of Object.entries(e.tags))t[`#${s}`]=i;return e.search&&(t.search=e.search),t}async execute(e={}){var l;if(!this.subscriptionManager)throw new Error("SubscriptionManager is required for query execution");const t=this.toFilter(),s=[];let i=!1;const n={...e,onEvent:u=>{s.push(u),e.onEvent&&e.onEvent(u)},onEose:u=>{i=!0,e.onEose&&e.onEose(u)},autoClose:!0},r=await this.subscriptionManager.subscribe(t,n);if(!r.success)throw new Error(((l=r.error)==null?void 0:l.message)||"Query execution failed");const o=e.timeout||1e4,c=Date.now();for(;!i&&Date.now()-c<o;)await new Promise(u=>setTimeout(u,100));return s}async subscribe(e={}){if(!this.subscriptionManager)throw new Error("SubscriptionManager is required for query subscription");const t=this.toFilter(),s={...e,autoClose:!1};return await this.subscriptionManager.subscribe(t,s)}validate(){const e=[];return this.state.since!==void 0&&this.state.until!==void 0&&this.state.until<=this.state.since&&e.push("until must be after since"),!(this.state.kinds||this.state.authors||this.state.ids||this.state.since!==void 0||this.state.until!==void 0||this.state.limit!==void 0||this.state.tags||this.state.search)&&(!this.state.unionWith||this.state.unionWith.length),{valid:e.length===0,errors:e}}get _state(){return{...this.state}}}function nt(a){return new Pe({},a)}function ss(a){return nt(a)}const is=Object.freeze(Object.defineProperty({__proto__:null,DMConversation:et,DMModule:st,DMRoom:tt,EphemeralKeyManager:ve,GiftWrapCreator:Me,GiftWrapProtocol:ce,NIP44Crypto:P,SealCreator:Ee,TimestampRandomizer:Le},Symbol.toStringTag,{value:"Module"})),ns="0.1.0";exports.DEFAULT_RELAYS=Be;exports.DM=is;exports.EVENT_KINDS=Ce;exports.ErrorHandler=_;exports.EventBuilder=C;exports.EventsModule=Ze;exports.ExtensionSigner=ge;exports.FeedStoreImpl=Se;exports.FluentEventBuilder=Ye;exports.LocalKeySigner=Ie;exports.NostrUnchained=ts;exports.QueryBuilder=Pe;exports.QuickSigner=Tt;exports.RelayManager=ze;exports.SigningProviderFactory=je;exports.SubscriptionManager=it;exports.TemporarySigner=kt;exports.VERSION=ns;exports.createFeed=Ct;exports.createFeedFromFilter=Lt;exports.createFeedFromQuery=Dt;exports.createQueryBuilder=nt;exports.derived=E;exports.query=ss;exports.setDefaultSubscriptionManager=Nt;exports.writable=S;
