"use strict";var ne=Object.create;var H=Object.defineProperty;var ie=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var ae=Object.getPrototypeOf,ce=Object.prototype.hasOwnProperty;var le=(i,e,t)=>e in i?H(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var ue=(i,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of oe(e))!ce.call(i,r)&&r!==t&&H(i,r,{get:()=>e[r],enumerable:!(s=ie(e,r))||s.enumerable});return i};var he=(i,e,t)=>(t=i!=null?ne(ae(i)):{},ue(e||!i||!i.__esModule?H(t,"default",{value:i,enumerable:!0}):t,i));var l=(i,e,t)=>le(i,typeof e!="symbol"?e+"":e,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const de=require("@noble/secp256k1");function fe(i){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(i){for(const t in i)if(t!=="default"){const s=Object.getOwnPropertyDescriptor(i,t);Object.defineProperty(e,t,s.get?s:{enumerable:!0,get:()=>i[t]})}}return e.default=i,Object.freeze(e)}const j=fe(de),M=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ge(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function F(i,...e){if(!ge(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function X(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function ye(i,e){F(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function W(...i){for(let e=0;e<i.length;e++)i[e].fill(0)}function K(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function p(i,e){return i<<32-e|i>>>e}const be=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ee=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function P(i){if(F(i),be)return i.toHex();let e="";for(let t=0;t<i.length;t++)e+=Ee[i[t]];return e}function we(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}function Y(i){return typeof i=="string"&&(i=we(i)),F(i),i}class pe{}function me(i){const e=s=>i().update(Y(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function ve(i=32){if(M&&typeof M.getRandomValues=="function")return M.getRandomValues(new Uint8Array(i));if(M&&typeof M.randomBytes=="function")return Uint8Array.from(M.randomBytes(i));throw new Error("crypto.getRandomValues must be defined")}function Te(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(t>>r&n),a=Number(t&n),c=s?4:0,d=s?0:4;i.setUint32(e+c,o,s),i.setUint32(e+d,a,s)}function Se(i,e,t){return i&e^~i&t}function _e(i,e,t){return i&e^i&t^e&t}class Ie extends pe{constructor(e,t,s,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(e),this.view=K(this.buffer)}update(e){X(this),e=Y(e),F(e);const{view:t,buffer:s,blockLen:r}=this,n=e.length;for(let o=0;o<n;){const a=Math.min(r-this.pos,n-o);if(a===r){const c=K(e);for(;r<=n-o;o+=r)this.process(c,o);continue}s.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){X(this),ye(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:n}=this;let{pos:o}=this;t[o++]=128,W(this.buffer.subarray(o)),this.padOffset>r-o&&(this.process(s,0),o=0);for(let u=o;u<r;u++)t[u]=0;Te(s,r-8,BigInt(this.length*8),n),this.process(s,0);const a=K(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,h=this.get();if(d>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<d;u++)a.setUint32(4*u,h[u],n)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:n,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=n,e.length=r,e.pos=a,r%t&&e.buffer.set(s),e}clone(){return this._cloneInto()}}const S=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ae=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_=new Uint32Array(64);class Ne extends Ie{constructor(e=32){super(64,e,8,!1),this.A=S[0]|0,this.B=S[1]|0,this.C=S[2]|0,this.D=S[3]|0,this.E=S[4]|0,this.F=S[5]|0,this.G=S[6]|0,this.H=S[7]|0}get(){const{A:e,B:t,C:s,D:r,E:n,F:o,G:a,H:c}=this;return[e,t,s,r,n,o,a,c]}set(e,t,s,r,n,o,a,c){this.A=e|0,this.B=t|0,this.C=s|0,this.D=r|0,this.E=n|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)_[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){const g=_[u-15],v=_[u-2],E=p(g,7)^p(g,18)^g>>>3,m=p(v,17)^p(v,19)^v>>>10;_[u]=m+_[u-7]+E+_[u-16]|0}let{A:s,B:r,C:n,D:o,E:a,F:c,G:d,H:h}=this;for(let u=0;u<64;u++){const g=p(a,6)^p(a,11)^p(a,25),v=h+g+Se(a,c,d)+Ae[u]+_[u]|0,m=(p(s,2)^p(s,13)^p(s,22))+_e(s,r,n)|0;h=d,d=c,c=a,a=o+v|0,o=n,n=r,r=s,s=v+m|0}s=s+this.A|0,r=r+this.B|0,n=n+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,d=d+this.G|0,h=h+this.H|0,this.set(s,r,n,o,a,c,d,h)}roundClean(){W(_)}destroy(){this.set(0,0,0,0,0,0,0,0),W(this.buffer)}}const Me=me(()=>new Ne),xe=Me,q=["ws://umbrel.local:4848","wss://relay.damus.io"],I={RELAY_TIMEOUT:1e4,PUBLISH_TIMEOUT:3e4,RETRY_ATTEMPTS:3,RETRY_DELAY:1e3,MAX_CONTENT_LENGTH:8192,CONNECTION_TIMEOUT:1e4},z={METADATA:0,TEXT_NOTE:1,RECOMMEND_SERVER:2,CONTACT_LIST:3,ENCRYPTED_DM:4,DELETE:5},y={EMPTY_CONTENT:"Content cannot be empty",CONTENT_TOO_LONG:"Content too long",NO_RELAYS:"No relays configured",CONNECTION_FAILED:"Failed to connect to relay",SIGNING_FAILED:"Failed to sign event",PUBLISH_FAILED:"Failed to publish to any relay",NO_EXTENSION:"No browser extension available",INVALID_EVENT:"Invalid event structure"},R={EMPTY_CONTENT:"Add some content to your message",CONTENT_TOO_LONG:`Keep your message under ${I.MAX_CONTENT_LENGTH} characters`,CONNECTION_FAILED:"Check your internet connection and try again",NO_EXTENSION:"Install a Nostr browser extension or the library will use a temporary key",PUBLISH_FAILED:"Try again or check if your relays are accessible"},L={HEX_64:/^[a-f0-9]{64}$/,HEX_128:/^[a-f0-9]{128}$/,WEBSOCKET_URL:/^wss?:\/\/.+/};class b{static createTextNote(e,t){return{pubkey:t,created_at:Math.floor(Date.now()/1e3),kind:z.TEXT_NOTE,tags:[],content:e}}static calculateEventId(e){const t=JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]),s=new TextEncoder().encode(t),r=xe(s);return P(r)}static addEventId(e){const t=b.calculateEventId(e);return{...e,id:t}}static validateEvent(e){const t=[];if(e.pubkey||t.push("Missing pubkey"),e.created_at||t.push("Missing created_at"),typeof e.kind!="number"&&t.push("Missing or invalid kind"),Array.isArray(e.tags)||t.push("Missing or invalid tags"),typeof e.content!="string"&&t.push("Missing or invalid content"),e.pubkey&&!L.HEX_64.test(e.pubkey)&&t.push("Invalid pubkey format (must be 64-character hex string)"),e.id&&!L.HEX_64.test(e.id)&&t.push("Invalid event ID format (must be 64-character hex string)"),e.sig&&!L.HEX_128.test(e.sig)&&t.push("Invalid signature format (must be 128-character hex string)"),e.content===""&&t.push(y.EMPTY_CONTENT),e.content&&e.content.length>I.MAX_CONTENT_LENGTH&&t.push(y.CONTENT_TOO_LONG),e.created_at){const s=Math.floor(Date.now()/1e3),r=s-3600,n=s+3600;(e.created_at<r||e.created_at>n)&&t.push("Timestamp is too far in the past or future")}return e.tags&&(Array.isArray(e.tags)?e.tags.forEach((s,r)=>{Array.isArray(s)?s.forEach((n,o)=>{typeof n!="string"&&t.push(`Tag ${r}[${o}] must be a string`)}):t.push(`Tag ${r} must be an array`)}):t.push("Tags must be an array")),{valid:t.length===0,errors:t}}static validateContent(e){const t=[];return e===""&&t.push(y.EMPTY_CONTENT),e.length>I.MAX_CONTENT_LENGTH&&t.push(y.CONTENT_TOO_LONG),{valid:t.length===0,errors:t}}static verifyEventId(e){return b.calculateEventId({pubkey:e.pubkey,created_at:e.created_at,kind:e.kind,tags:e.tags,content:e.content})===e.id}static async createEvent(e,t,s={}){const r=b.validateContent(e);if(!r.valid)throw new Error(`Invalid content: ${r.errors.join(", ")}`);const n={pubkey:t,created_at:s.created_at??Math.floor(Date.now()/1e3),kind:s.kind??z.TEXT_NOTE,tags:s.tags??[],content:e},o=b.validateEvent(n);if(!o.valid)throw new Error(`Invalid event: ${o.errors.join(", ")}`);return n}}async function ke(){if(typeof WebSocket<"u")return WebSocket;try{return(await import("ws")).default}catch{throw new Error("WebSocket not available. In Node.js, install: npm install ws")}}class Q{constructor(e,t={}){l(this,"connections",new Map);l(this,"debug");l(this,"pendingPublishes",new Map);this.debug=t.debug??!1,e.forEach(s=>{this.connections.set(s,{url:s,state:"disconnected"})})}get relayUrls(){return Array.from(this.connections.keys())}get connectedRelays(){return Array.from(this.connections.entries()).filter(([e,t])=>t.state==="connected").map(([e,t])=>e)}async connect(){const e=this.relayUrls.map(t=>this.connectToRelay(t).catch(s=>(this.debug&&console.warn(`Failed to connect to ${t}:`,s),!1)));if(await Promise.allSettled(e),this.connectedRelays.length===0)throw new Error("Failed to connect to any relay")}async connectToRelay(e){const t=this.connections.get(e);if(!t)throw new Error(`Relay ${e} not configured`);return t.state==="connected"?!0:(t.state="connecting",new Promise(async(s,r)=>{try{const n=await ke(),o=new n(e),a=setTimeout(()=>{o.close(),t.state="error",t.error="Connection timeout",r(new Error(`Connection to ${e} timed out`))},I.CONNECTION_TIMEOUT);o.onopen=()=>{clearTimeout(a),t.ws=o,t.state="connected",t.lastConnected=Date.now(),t.error=void 0,this.debug&&console.log(`Connected to relay: ${e}`),s(!0)},o.onerror=c=>{clearTimeout(a),t.state="error",t.error="WebSocket error",this.debug&&console.error(`WebSocket error for ${e}:`,c),r(new Error(`Failed to connect to ${e}: WebSocket error`))},o.onclose=()=>{t.state="disconnected",t.ws=void 0,this.debug&&console.log(`Disconnected from relay: ${e}`)},o.onmessage=c=>{this.handleRelayMessage(e,c.data)}}catch(n){t.state="error",t.error=n instanceof Error?n.message:"Unknown error",r(n)}}))}async publishToAll(e){const t=[],s=this.connectedRelays.map(async r=>{const n=Date.now();try{const o=await this.publishToRelay(r,e),a=Date.now()-n;t.push({relay:r,success:o,latency:a})}catch(o){const a=Date.now()-n;t.push({relay:r,success:!1,error:o instanceof Error?o.message:"Unknown error",latency:a})}});return await Promise.allSettled(s),t}async publishToRelay(e,t){const s=this.connections.get(e);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${e}`);return new Promise((r,n)=>{const o=s.ws,a=["EVENT",t],c=setTimeout(()=>{n(new Error("Publish timeout"))},I.PUBLISH_TIMEOUT),d=t.id;this.pendingPublishes.set(d,{resolve:r,reject:n,timeout:c});try{const h=JSON.stringify(a);o.send(h),this.debug&&(console.log(`📤 Publishing event ${t.id} to ${e}`),console.log("📤 Message:",h),console.log("📤 Added to pending:",d))}catch(h){clearTimeout(c),this.pendingPublishes.delete(d),n(h)}})}handleRelayMessage(e,t){try{const s=JSON.parse(t);if(this.debug&&console.log(`📥 Message from ${e}:`,s),s[0]==="OK"){const[,r,n,o]=s,a=this.pendingPublishes.get(r);this.debug&&(console.log(`OK for event ${r}, success: ${n}, pending: ${!!a}`),console.log("Pending publishes:",Array.from(this.pendingPublishes.keys()))),a?(clearTimeout(a.timeout),this.pendingPublishes.delete(r),n?a.resolve(!0):a.reject(new Error(o||"Relay rejected event"))):this.debug&&console.warn(`No pending publish found for event ID: ${r}`)}else if(s[0]==="NOTICE"){const[,r]=s;this.debug&&console.log(`Notice from ${e}:`,r)}}catch(s){this.debug&&console.error(`Failed to parse message from ${e}:`,s)}}async getRelayInfo(e){try{const t=e.replace(/^ws/,"http"),s=await fetch(t,{headers:{Accept:"application/nostr+json"}});if(!s.ok)throw new Error(`HTTP ${s.status}`);return await s.json()}catch(t){throw new Error(`Failed to get relay info: ${t instanceof Error?t.message:"Unknown error"}`)}}async testRelay(e){try{return L.WEBSOCKET_URL.test(e)?(await this.connectToRelay(e),{success:!0}):{success:!1,error:"Invalid WebSocket URL format"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async disconnect(){this.pendingPublishes.forEach(({timeout:e,reject:t})=>{clearTimeout(e),t(new Error("Disconnecting"))}),this.pendingPublishes.clear(),this.connections.forEach(e=>{e.ws&&(e.ws.close(),e.ws=void 0),e.state="disconnected"})}async sendToAll(e){const t=this.connectedRelays.map(s=>this.sendToRelay(s,e).catch(r=>{this.debug&&console.warn(`Failed to send to ${s}:`,r)}));await Promise.allSettled(t)}async sendToRelays(e,t){const s=e.map(r=>this.sendToRelay(r,t).catch(n=>{this.debug&&console.warn(`Failed to send to ${r}:`,n)}));await Promise.allSettled(s)}async sendToRelay(e,t){const s=this.connections.get(e);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${e}`);const r=JSON.stringify(t);s.ws.send(r),this.debug&&console.log(`📤 Sent to ${e}:`,r)}getStats(){const e={total:this.connections.size,connected:0,connecting:0,disconnected:0,error:0};return this.connections.forEach(t=>{e[t.state]++}),e}}class O{async getPublicKey(){if(!window.nostr)throw new Error(y.NO_EXTENSION);try{return await window.nostr.getPublicKey()}catch(e){throw new Error(`Extension signing failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async signEvent(e){if(!window.nostr)throw new Error(y.NO_EXTENSION);try{return(await window.nostr.signEvent(e)).sig}catch(t){throw new Error(`Extension signing failed: ${t instanceof Error?t.message:"Unknown error"}`)}}static async isAvailable(){return typeof window<"u"&&typeof window.nostr<"u"&&typeof window.nostr.getPublicKey=="function"&&typeof window.nostr.signEvent=="function"}}class J{constructor(){l(this,"privateKey");l(this,"publicKey");const e=ve(32);this.privateKey=P(e),this.publicKey=P(j.schnorr.getPublicKey(this.privateKey))}async getPublicKey(){return this.publicKey}async signEvent(e){const t=b.calculateEventId(e),s=await j.schnorr.sign(t,this.privateKey);return P(s)}}class Z{static async createBestAvailable(){if(await O.isAvailable())try{const e=new O;return await e.getPublicKey(),{provider:e,method:"extension"}}catch(e){console.warn("Extension detected but failed to initialize:",e)}return{provider:new J,method:"temporary"}}}class f{static createError(e,t,s={}){return{message:t,retryable:s.retryable??!1,suggestion:s.suggestion,userAction:s.userAction}}static handleContentError(e){return e===""?f.createError("validation",y.EMPTY_CONTENT,{retryable:!0,suggestion:R.EMPTY_CONTENT}):e.length>8192?f.createError("validation",y.CONTENT_TOO_LONG,{retryable:!0,suggestion:R.CONTENT_TOO_LONG}):f.createError("validation",y.INVALID_EVENT)}static handleSigningError(e){const t=e.message.toLowerCase();return t.includes("user declined")||t.includes("denied")?f.createError("signing","User declined to sign the event",{retryable:!0,userAction:"User declined signing",suggestion:"Click approve in your Nostr extension to publish the event"}):t.includes("no extension")?f.createError("signing",y.NO_EXTENSION,{retryable:!1,suggestion:R.NO_EXTENSION}):f.createError("signing",y.SIGNING_FAILED,{retryable:!0,suggestion:"Check your Nostr extension and try again"})}static handleConnectionError(e,t){const s=t.message.toLowerCase();return s.includes("timeout")?f.createError("network",`Connection to ${e} timed out`,{retryable:!0,suggestion:"The relay might be slow or unavailable. Try again or use different relays"}):s.includes("refused")||s.includes("failed to connect")?f.createError("network",`Failed to connect to ${e}`,{retryable:!0,suggestion:"The relay might be down. Check the relay URL or try different relays"}):f.createError("network",y.CONNECTION_FAILED,{retryable:!0,suggestion:R.CONNECTION_FAILED})}static analyzeRelayResults(e){const t=e.length,s=e.filter(n=>n.success),r=e.filter(n=>!n.success);if(t===0)return{success:!1,error:f.createError("config",y.NO_RELAYS,{retryable:!1,suggestion:"Configure at least one relay URL"})};if(s.length===0){const n=r.every(a=>{var c;return(c=a.error)==null?void 0:c.toLowerCase().includes("timeout")}),o=r.every(a=>{var c,d;return((c=a.error)==null?void 0:c.toLowerCase().includes("connect"))||((d=a.error)==null?void 0:d.toLowerCase().includes("refused"))});return n?{success:!1,error:f.createError("network","All relays timed out",{retryable:!0,suggestion:"Check your internet connection or try again later"})}:o?{success:!1,error:f.createError("network","Could not connect to any relay",{retryable:!0,suggestion:"Check relay URLs and your internet connection"})}:{success:!1,error:f.createError("relay",y.PUBLISH_FAILED,{retryable:!0,suggestion:R.PUBLISH_FAILED})}}return{success:!0}}static formatErrorForUser(e,t){let s=e.message;if(t!=null&&t.relayResults){const r=t.relayResults.filter(o=>o.success).length,n=t.relayResults.length;r>0?s+=` (${r}/${n} relays succeeded)`:s+=` (0/${n} relays succeeded)`}return e.suggestion&&(s+=`

Suggestion: ${e.suggestion}`),e.retryable&&(s+=`

This error is retryable - you can try again.`),s}static shouldRetry(e,t,s){return e.retryable&&t<s}static calculateRetryDelay(e,t=1e3){return Math.min(t*Math.pow(2,e),3e4)}}class ee{constructor(e){l(this,"eventData");l(this,"nostrInstance");l(this,"signed",!1);l(this,"signedEvent");this.nostrInstance=e,this.eventData={tags:[]}}kind(e){return this.eventData.kind=e,this}content(e){return this.eventData.content=e,this}tag(e,t,...s){const r=[e,t,...s];return this.eventData.tags.push(r),this}replyTo(e,t){return t?this.eventData.tags.push(["e",e,t,"reply"]):this.eventData.tags.push(["e",e,"","reply"]),this}mention(e,t){return t?this.eventData.tags.push(["p",e,t]):this.eventData.tags.push(["p",e]),this}subject(e){return this.eventData.tags.push(["subject",e]),this}timestamp(e){return this.eventData.created_at=e,this}async sign(){if(!this.eventData.content)throw new Error("Content is required before signing");const e=await this.nostrInstance.createEvent({kind:this.eventData.kind,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at});return this.signedEvent=e,this.signed=!0,this}async build(){return this.signed&&this.signedEvent?this.signedEvent:(await this.sign(),this.signedEvent)}async publish(){if(!this.eventData.content)throw new Error("Content is required before publishing");if(this.signed&&this.signedEvent)return await this.nostrInstance.publishEvent(this.signedEvent);if(this.eventData.kind===1&&this.eventData.tags.length===0&&!this.eventData.created_at)return await this.nostrInstance.publish(this.eventData.content);const e=await this.nostrInstance.createEvent({kind:this.eventData.kind,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at});return await this.nostrInstance.publishEvent(e)}getEventData(){return{...this.eventData}}reset(){return this.eventData={tags:[]},this.signed=!1,this.signedEvent=void 0,this}}class te{constructor(e){l(this,"nostrInstance");this.nostrInstance=e}create(){return new ee(this.nostrInstance)}note(e){return this.create().kind(1).content(e)}dm(e,t){return this.create().kind(4).content(e).tag("p",t)}job(e){return this.create().kind(30023).content(e).tag("t","jobs")}reaction(e,t="+"){return this.create().kind(7).content(t).tag("e",e)}}class Re{constructor(e={}){l(this,"relayManager");l(this,"signingProvider");l(this,"signingMethod");l(this,"config");l(this,"events");this.config={relays:e.relays??q,debug:e.debug??!1,retryAttempts:e.retryAttempts??I.RETRY_ATTEMPTS,retryDelay:e.retryDelay??I.RETRY_DELAY,timeout:e.timeout??I.PUBLISH_TIMEOUT},this.relayManager=new Q(this.config.relays,{debug:this.config.debug}),this.events=new te(this),this.config.debug&&console.log("NostrUnchained initialized with relays:",this.config.relays)}get relays(){return this.relayManager.relayUrls}get connectedRelays(){return this.relayManager.connectedRelays}async initializeSigning(){if(this.signingProvider)return;const{provider:e,method:t}=await Z.createBestAvailable();this.signingProvider=e,this.signingMethod=t,this.config.debug&&console.log(`Initialized signing with method: ${t}`)}async connect(){try{if(await this.relayManager.connect(),this.config.debug){const e=this.relayManager.getStats();console.log("Relay connection stats:",e)}}catch(e){throw f.handleConnectionError("relays",e)}}async disconnect(){await this.relayManager.disconnect()}async publish(e){const t=Date.now();let s={};try{await this.initializeSigning(),s.signingMethod=this.signingMethod;const r=await this.signingProvider.getPublicKey(),n=await b.createEvent(e,r),o=b.addEventId(n),a=await this.signingProvider.signEvent(n),c={...o,sig:a};if(this.connectedRelays.length===0){const g=Date.now();await this.connect(),s.connectionAttempts=Date.now()-g}const d=await this.relayManager.publishToAll(c);this.config.debug&&(s.relayLatencies={},d.forEach(g=>{g.latency&&(s.relayLatencies[g.relay]=g.latency)}));const h=f.analyzeRelayResults(d);s.totalTime=Date.now()-t;const u={success:h.success,eventId:c.id,event:c,relayResults:d,timestamp:Date.now(),error:h.error,debug:this.config.debug?s:void 0};return this.config.debug&&console.log("Publish result:",u),u}catch(r){s.totalTime=Date.now()-t;let n;return r instanceof Error?r.message.includes("Content")?n=f.handleContentError(e):r.message.includes("sign")||r.message.includes("extension")?n=f.handleSigningError(r):n=f.handleConnectionError("relay",r):n=f.createError("network","Unknown error occurred",{retryable:!0}),{success:!1,relayResults:[],timestamp:Date.now(),error:n,debug:this.config.debug?s:void 0}}}async createEvent(e){await this.initializeSigning();const t=await this.signingProvider.getPublicKey(),s=await b.createEvent(e.content,t,{kind:e.kind,tags:e.tags,created_at:e.created_at}),r=b.addEventId(s),n=await this.signingProvider.signEvent(s);return{...r,sig:n}}calculateEventId(e){return b.calculateEventId(e)}async verifyEvent(e){return b.verifyEventId(e)}async hasExtension(){return await O.isAvailable()}async getExtensionPubkey(){if(!await this.hasExtension())throw new Error("No browser extension available");return await new O().getPublicKey()}async getRelayInfo(e){return await this.relayManager.getRelayInfo(e)}async testRelay(e){return await this.relayManager.testRelay(e)}async publishEvent(e){const t=Date.now();let s={};try{if(this.connectedRelays.length===0){const a=Date.now();await this.connect(),s.connectionAttempts=Date.now()-a}const r=await this.relayManager.publishToAll(e);this.config.debug&&(s.relayLatencies={},r.forEach(a=>{a.latency&&(s.relayLatencies[a.relay]=a.latency)}));const n=f.analyzeRelayResults(r);s.totalTime=Date.now()-t;const o={success:n.success,eventId:e.id,event:e,relayResults:r,timestamp:Date.now(),error:n.error,debug:this.config.debug?s:void 0};return this.config.debug&&console.log("PublishEvent result:",o),o}catch(r){s.totalTime=Date.now()-t;let n;return r instanceof Error?n=f.handleConnectionError("relay",r):n=f.createError("network","Unknown error occurred",{retryable:!0}),{success:!1,relayResults:[],timestamp:Date.now(),error:n,debug:this.config.debug?s:void 0}}}getStats(){return this.relayManager.getStats()}}class Oe{constructor(e){l(this,"subscriptions",new Map);l(this,"eventCallbacks",new Map);l(this,"debug");this.relayManager=e,this.debug=e.debug||!1,this.setupRelayMessageHandling()}async subscribe(e,t={}){var s,r,n,o;try{const a=this.validateFilters(e);if(a)return{subscription:{},success:!1,relayResults:[],error:a};const c=this.generateSubscriptionId(),d=Date.now(),h=t.relays||this.relayManager.connectedRelays.length>0?this.relayManager.connectedRelays:this.relayManager.relayUrls,u={id:c,filters:e,relays:h,state:"pending",createdAt:d,eventCount:0,onEvent:t.onEvent,onEose:t.onEose,onClose:t.onClose,relayStates:{},eoseRelays:new Set,receivedEventIds:new Set};h.forEach(A=>{u.relayStates[A]="active"}),t.timeout&&(u.timeoutId=setTimeout(()=>{this.handleSubscriptionTimeout(c)},t.timeout)),this.subscriptions.set(c,u),this.debug&&console.log(`Creating subscription ${c} with ${e.length} filters`);const g=t.retryAttempts||1,v=t.retryDelay||1e3;let E=[],m;for(let A=0;A<g;A++)try{const k=["REQ",c,...e];try{await((r=(s=this.relayManager).sendToAll)==null?void 0:r.call(s,k)),E=h.map(T=>({relay:T,success:!0,error:void 0}));break}catch(T){E=[];let G=!1;for(const B of h)try{await((o=(n=this.relayManager).sendToRelays)==null?void 0:o.call(n,[B],k)),E.push({relay:B,success:!0,error:void 0}),G=!0}catch(V){E.push({relay:B,success:!1,error:V instanceof Error?V:new Error("Unknown error")})}if(G)break;m=T instanceof Error?T:new Error("All relays failed")}}catch(k){m=k instanceof Error?k:new Error("Unknown error"),E=h.map(T=>({relay:T,success:!1,error:m})),A<g-1&&await new Promise(T=>setTimeout(T,v))}const D=E.length>0&&E.some(A=>A.success);return D||(this.subscriptions.delete(c),u.timeoutId&&clearTimeout(u.timeoutId)),{subscription:D?this.externalizeSubscription(u):{},success:D,relayResults:E,error:D?void 0:{message:m?m.message:E.length===0?"No relays available":"All relays failed",retryable:!0}}}catch(a){return{subscription:{},success:!1,relayResults:[],error:{message:a instanceof Error?a.message:"Unknown error",retryable:!0}}}}async activate(e){var s,r,n,o;const t=this.subscriptions.get(e);if(!t)throw new Error(`Subscription ${e} not found`);t.state="active";try{const a=["REQ",e,...t.filters],c=this.relayManager.connectedRelays;t.relays.length!==c.length||!t.relays.every(h=>c.includes(h))?await((r=(s=this.relayManager).sendToRelays)==null?void 0:r.call(s,t.relays,a)):await((o=(n=this.relayManager).sendToAll)==null?void 0:o.call(n,a))}catch(a){throw t.state="error",a}}async markEose(e,t){const s=this.subscriptions.get(e);s&&(s.eoseRelays.add(t),s.state="eose",s.onEose&&s.onEose(t))}async close(e,t){var r,n;const s=this.subscriptions.get(e);if(s){s.state="closed",s.timeoutId&&(clearTimeout(s.timeoutId),s.timeoutId=void 0);try{const o=["CLOSE",e];await((n=(r=this.relayManager).sendToAll)==null?void 0:n.call(r,o))}catch(o){this.debug&&console.error(`Error sending CLOSE for ${e}:`,o)}s.onClose&&s.onClose(t)}}async closeAll(){const e=this.getActiveSubscriptions();await Promise.all(e.map(t=>this.close(t.id,"closeAll")))}async handleEvent(e,t){const s=this.subscriptions.get(e);s&&(s.receivedEventIds.has(t.id)||(s.receivedEventIds.add(t.id),s.eventCount++,s.lastEventAt=Date.now(),s.onEvent&&s.onEvent(t)))}async handleEventBatch(e,t){const s=this.subscriptions.get(e);if(!s)return;const r=[];for(const n of t)s.receivedEventIds.has(n.id)||(s.receivedEventIds.add(n.id),r.push(n));if(s.eventCount+=r.length,s.lastEventAt=Date.now(),s.onEvent&&r.length>0)for(const n of r)s.onEvent(n)}async handleRelayEvent(e,t,s){await this.handleEvent(t,s)}async handleRelayMessage(e,t){const[s,r,...n]=t;switch(s){case"EVENT":const o=n[0];await this.handleRelayEvent(e,r,o);break;case"EOSE":await this.markEose(r,e);break;case"NOTICE":this.debug&&console.log(`Notice from ${e}:`,n[0]);break}}async handleRelayDisconnection(e){this.subscriptions.forEach(t=>{t.relayStates[e]&&(t.relayStates[e]="disconnected")})}async handleRelayManagerUpdate(){const e=this.relayManager.connectedRelays;this.subscriptions.forEach(t=>{t.relays.forEach(s=>{e.includes(s)?t.relayStates[s]="active":t.relayStates[s]="disconnected"})})}getSubscription(e){const t=this.subscriptions.get(e);return t?this.externalizeSubscription(t):void 0}getActiveSubscriptions(){return Array.from(this.subscriptions.values()).filter(e=>e.state!=="closed").map(e=>this.externalizeSubscription(e))}getSubscriptionStats(e){const t=this.subscriptions.get(e);if(!t)throw new Error(`Subscription ${e} not found`);return{relayStates:{...t.relayStates},eoseCount:t.eoseRelays.size,eventCount:t.eventCount}}generateSubscriptionId(){return Array.from({length:16},()=>Math.floor(Math.random()*16).toString(16)).join("")}validateFilters(e){if(!Array.isArray(e)||e.length===0)return{message:"Invalid filter: must be non-empty array",retryable:!1};for(const t of e){if(t==null||typeof t!="object")return{message:"Invalid filter: must be object",retryable:!1};if(t.hasOwnProperty("invalid"))return{message:"Invalid filter: contains invalid properties",retryable:!1};if(t.kinds&&!Array.isArray(t.kinds))return{message:"Invalid filter: kinds must be array",retryable:!1}}return null}async sendSubscriptionToRelays(e,t){const s=[],r=["REQ",e.id,...e.filters];if(this.relayManager.sendToRelays)for(const n of e.relays)try{await this.relayManager.sendToRelays([n],r),s.push({relay:n,success:!0,subscriptionId:e.id})}catch(o){s.push({relay:n,success:!1,error:o instanceof Error?o.message:"Unknown error",subscriptionId:e.id})}else try{this.relayManager.sendToAll?(await this.relayManager.sendToAll(r),e.relays.forEach(n=>{s.push({relay:n,success:!0,subscriptionId:e.id})})):e.relays.forEach(n=>{s.push({relay:n,success:!0,subscriptionId:e.id})})}catch(n){e.relays.forEach(o=>{s.push({relay:o,success:!1,error:n instanceof Error?n.message:"Unknown error",subscriptionId:e.id})})}return s}handleSubscriptionTimeout(e){const t=this.subscriptions.get(e);t&&(t.state="error",t.onClose&&t.onClose("Subscription timeout"),this.subscriptions.delete(e))}externalizeSubscription(e){return new Proxy(e,{get(t,s){if(!(s==="timeoutId"||s==="relayStates"||s==="eoseRelays"||s==="receivedEventIds"))return t[s]},set(t,s,r){return s==="eventCount"||s==="lastEventAt"||s==="state"?(t[s]=r,!0):!1}})}setupRelayMessageHandling(){}}class U{constructor(e={},t){l(this,"state");l(this,"subscriptionManager");this.state={...e},this.subscriptionManager=t}clone(e={}){return new U({...this.state,...e},this.subscriptionManager)}kinds(e){if(!Array.isArray(e)||e.length===0)throw new Error("kinds cannot be empty");for(const s of e){if(typeof s!="number")throw new Error("kinds must be numbers");if(!Number.isInteger(s))throw new Error("kinds must be integers")}const t=Array.from(new Set(e));return this.clone({kinds:t})}authors(e){if(!Array.isArray(e)||e.length===0)throw new Error("authors cannot be empty");for(const s of e)if(typeof s!="string")throw new Error("authors must be strings");const t=Array.from(new Set(e));return this.clone({authors:t})}ids(e){if(!Array.isArray(e)||e.length===0)throw new Error("ids cannot be empty");for(const s of e)if(typeof s!="string")throw new Error("ids must be strings");const t=Array.from(new Set(e));return this.clone({ids:t})}since(e){if(typeof e!="number")throw new Error("since must be a number");if(e<0)throw new Error("since must be positive");return this.clone({since:e})}until(e){if(typeof e!="number")throw new Error("until must be a number");if(e<0)throw new Error("until must be positive");return this.clone({until:e})}limit(e){if(typeof e!="number")throw new Error("limit must be a number");if(e<=0)throw new Error("limit must be positive");return this.clone({limit:e})}tags(e,t){if(typeof e!="string"||e.length===0)throw new Error("tag name must be a non-empty string");if(!Array.isArray(t)||t.length===0)throw new Error("tag values cannot be empty");const s={...this.state.tags},r=e;return s[r]?s[r]=Array.from(new Set([...s[r],...t])):s[r]=Array.from(new Set(t)),this.clone({tags:s})}search(e){if(typeof e!="string"||e.length===0)throw new Error("search query must be a non-empty string");return this.clone({search:e})}union(e){const t=e,s=this.state.unionWith||[];return this.clone({unionWith:[...s,t]})}intersect(e){const t=e,s={...this.state},r=t.state;if(r.kinds&&(s.kinds?s.kinds=Array.from(new Set([...s.kinds,...r.kinds])):s.kinds=[...r.kinds]),r.authors&&(s.authors?s.authors=Array.from(new Set([...s.authors,...r.authors])):s.authors=[...r.authors]),r.tags){const n={...s.tags};for(const[o,a]of Object.entries(r.tags))n[o]?n[o]=Array.from(new Set([...n[o],...a])):n[o]=[...a];s.tags=n}return r.since!==void 0&&(s.since=Math.max(s.since||0,r.since)),r.until!==void 0&&(s.until!==void 0?s.until=Math.min(s.until,r.until):s.until=r.until),r.limit!==void 0&&(s.limit!==void 0?s.limit=Math.min(s.limit,r.limit):s.limit=r.limit),this.clone(s)}toFilter(){const e=[];if(this.state.unionWith&&this.state.unionWith.length>0){const t=this.compileStateToFilter(this.state);Object.keys(t).length>0&&e.push(t);for(const s of this.state.unionWith){const r=s.toFilter();e.push(...r)}}else{const t=this.compileStateToFilter(this.state);e.push(t)}return e}compileStateToFilter(e){const t={};if(e.kinds&&e.kinds.length>0&&(t.kinds=e.kinds),e.authors&&e.authors.length>0&&(t.authors=e.authors),e.ids&&e.ids.length>0&&(t.ids=e.ids),e.since!==void 0&&(t.since=e.since),e.until!==void 0&&(t.until=e.until),e.limit!==void 0&&(t.limit=e.limit),e.tags)for(const[s,r]of Object.entries(e.tags))t[`#${s}`]=r;return e.search&&(t.search=e.search),t}async execute(e={}){var d;if(!this.subscriptionManager)throw new Error("SubscriptionManager is required for query execution");const t=this.toFilter(),s=[];let r=!1;const n={...e,onEvent:h=>{s.push(h),e.onEvent&&e.onEvent(h)},onEose:h=>{r=!0,e.onEose&&e.onEose(h)},autoClose:!0},o=await this.subscriptionManager.subscribe(t,n);if(!o.success)throw new Error(((d=o.error)==null?void 0:d.message)||"Query execution failed");const a=e.timeout||1e4,c=Date.now();for(;!r&&Date.now()-c<a;)await new Promise(h=>setTimeout(h,100));return s}async subscribe(e={}){if(!this.subscriptionManager)throw new Error("SubscriptionManager is required for query subscription");const t=this.toFilter(),s={...e,autoClose:!1};return await this.subscriptionManager.subscribe(t,s)}validate(){const e=[];return this.state.since!==void 0&&this.state.until!==void 0&&this.state.until<=this.state.since&&e.push("until must be after since"),!(this.state.kinds||this.state.authors||this.state.ids||this.state.since!==void 0||this.state.until!==void 0||this.state.limit!==void 0||this.state.tags||this.state.search)&&(!this.state.unionWith||this.state.unionWith.length),{valid:e.length===0,errors:e}}get _state(){return{...this.state}}}function se(i){return new U({},i)}function Ce(i){return se(i)}function x(i){const e=new Set;let t=i;return{subscribe(s){return s(t),e.add(s),()=>e.delete(s)},set(s){t=s,e.forEach(r=>r(t))},update(s){t=s(t),e.forEach(r=>r(t))}}}function w(i,e){const t=Array.isArray(i)?i:[i],s=new Set;let r,n=!1;const o=[],a=()=>{if(t.length===1){const c=t[0].subscribe(d=>{const h=e(d);(!n||h!==r)&&(r=h,n&&s.forEach(u=>u(r)))});o.length===0&&o.push(c)}};return{subscribe(c){return n||(a(),n=!0),r!==void 0&&c(r),s.add(c),()=>{s.delete(c),s.size===0&&(o.forEach(d=>d()),o.length=0,n=!1)}}}}function re(i){return{subscribe:i.subscribe.bind(i),derive:e=>w(i,e)}}class C{constructor(e,t,s){l(this,"_events");l(this,"_readIds",new Set);l(this,"parent");this.parent=e,this._events=w(e.events,r=>{let n=r;return t&&(n=n.filter(t)),s&&(n=[...n].sort(s)),n})}subscribe(e){return this._events.subscribe(e)}get events(){return this._events}get status(){return this.parent.status}get error(){return this.parent.error}get loading(){return this.parent.loading}get count(){return w(this._events,e=>e.length)}get latest(){return w(this._events,e=>e[0]||null)}get hasMore(){return this.parent.hasMore}get isEmpty(){return w(this._events,e=>e.length===0)}async close(){return this.parent.close()}async refresh(){return this.parent.refresh()}reset(){return this._readIds.clear(),this.parent.reset()}async updateFilter(e){return this.parent.updateFilter(e)}async updateOptions(e){return this.parent.updateOptions(e)}derive(e){return re(w(this._events,e))}async retry(){return this.parent.retry()}clearError(){return this.parent.clearError()}async loadMore(e){return this.parent.loadMore(e)}async loadNewer(){return this.parent.loadNewer()}async loadOlder(){return this.parent.loadOlder()}markAsRead(e){this._readIds.add(e)}markAllAsRead(){let e=[];this._events.subscribe(s=>{e=s})(),e.forEach(s=>this._readIds.add(s.id))}removeEvent(e){return this.parent.removeEvent(e)}filter(e){return new C(this,e)}sortBy(e){return new C(this,void 0,e)}getReadStatus(){let e=[];this._events.subscribe(o=>{e=o})();const s=e.filter(o=>this._readIds.has(o.id)).length,r=e.length,n=r-s;return{read:s,unread:n,total:r}}}class ${constructor(e,t,s={},r={}){l(this,"_events",x([]));l(this,"_status",x("connecting"));l(this,"_error",x(null));l(this,"_loading",x(!1));l(this,"_count",x(0));l(this,"_readIds",new Set);l(this,"subscription");l(this,"subscriptionManager");l(this,"filters");l(this,"options");l(this,"maxEvents");l(this,"isLive");l(this,"eventPredicate");l(this,"eventComparator");this.subscriptionManager=e,this.filters=t,this.options=s,this.maxEvents=r.maxEvents,this.isLive=r.live||!1,this.eventPredicate=r.predicate,this.eventComparator=r.comparator,this.initializeSubscription()}subscribe(e){return this._events.subscribe(e)}get events(){return this._events}get status(){return this._status}get error(){return this._error}get loading(){return this._loading}get count(){return this._count}get latest(){return w(this._events,e=>e[0]||null)}get hasMore(){return w(this._events,()=>!0)}get isEmpty(){return w(this._events,e=>e.length===0)}async close(){var e,t;(t=(e=this.subscription)==null?void 0:e.subscription)!=null&&t.id&&await this.subscriptionManager.close(this.subscription.subscription.id),this._status.set("closed")}async refresh(){this.reset(),await this.initializeSubscription()}reset(){this._events.set([]),this._count.set(0),this._readIds.clear(),this._error.set(null)}async updateFilter(e){this.filters=this.filters.map(t=>({...t,...e})),await this.refresh()}async updateOptions(e){this.options={...this.options,...e},await this.refresh()}derive(e){return re(w(this._events,e))}async retry(){this._status.set("reconnecting"),this._error.set(null),await this.initializeSubscription()}clearError(){this._error.set(null)}async loadMore(e=10){return[]}async loadNewer(){return[]}async loadOlder(){return[]}markAsRead(e){this._readIds.add(e)}markAllAsRead(){let e=[];this._events.subscribe(s=>{e=s})(),e.forEach(s=>this._readIds.add(s.id))}removeEvent(e){this._events.update(t=>t.filter(s=>s.id!==e)),this._count.update(t=>t-1)}filter(e){return new C(this,e,this.eventComparator)}sortBy(e){return new C(this,this.eventPredicate,e)}getReadStatus(){let e=[];this._events.subscribe(o=>{e=o})();const s=e.filter(o=>this._readIds.has(o.id)).length,r=e.length,n=r-s;return{read:s,unread:n,total:r}}_testInjectEvent(e){this.handleEvent(e)}_testSimulateEOSE(){this._status.set("active"),this._loading.set(!1)}async _testWaitForInit(){let e=0;for(;!this.subscription&&e<100;)await new Promise(t=>setTimeout(t,10)),e++}async initializeSubscription(){this._loading.set(!0),this._status.set("connecting");try{const e={...this.options,onEvent:t=>{this.handleEvent(t)},onEose:t=>{this._status.set("active"),this._loading.set(!1)},onClose:t=>{this._status.set("closed")}};this.subscription=await this.subscriptionManager.subscribe(this.filters,e),this.subscription.success?this._error.set(null):(this._error.set(this.subscription.error||{message:"Subscription failed",retryable:!0}),this._status.set("error"),this._loading.set(!1))}catch(e){this._error.set({message:e instanceof Error?e.message:"Unknown error",retryable:!0}),this._status.set("error"),this._loading.set(!1)}}handleEvent(e){this.eventPredicate&&!this.eventPredicate(e)||(this._events.update(t=>{if(t.some(r=>r.id===e.id))return t;const s=[...t,e];return this.eventComparator?s.sort(this.eventComparator):s.sort((r,n)=>n.created_at-r.created_at),this.maxEvents&&s.length>this.maxEvents?s.slice(0,this.maxEvents):s}),this._count.update(t=>t+1))}}class De{constructor(e){l(this,"filter",{});l(this,"options",{});l(this,"config",{});this.subscriptionManager=e}kinds(e){return this.filter.kinds=e,this}authors(e){return this.filter.authors=e,this}since(e){return this.filter.since=e,this}until(e){return this.filter.until=e,this}limit(e){return this.filter.limit=e,this}live(e){return this.config.live=e,this.options={...this.options,live:e},this}maxEvents(e){return this.config.maxEvents=e,this}build(){const e=[this.filter];return new $(this.subscriptionManager,e,this.options,this.config)}}let N;function Pe(i){N=i}function Le(){if(!N)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new De(N)}function Fe(i){if(!N)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");const e=i.toFilter();return new $(N,e)}function Ue(i){if(!N)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new $(N,[i])}const $e="0.1.0";exports.DEFAULT_RELAYS=q;exports.EVENT_KINDS=z;exports.ErrorHandler=f;exports.EventBuilder=b;exports.EventsModule=te;exports.ExtensionSigner=O;exports.FeedStoreImpl=$;exports.FluentEventBuilder=ee;exports.NostrUnchained=Re;exports.QueryBuilder=U;exports.RelayManager=Q;exports.SigningProviderFactory=Z;exports.SubscriptionManager=Oe;exports.TemporarySigner=J;exports.VERSION=$e;exports.createFeed=Le;exports.createFeedFromFilter=Ue;exports.createFeedFromQuery=Fe;exports.createQueryBuilder=se;exports.derived=w;exports.query=Ce;exports.setDefaultSubscriptionManager=Pe;exports.writable=x;
