"use strict";var ms=Object.create;var zt=Object.defineProperty;var bs=Object.getOwnPropertyDescriptor;var ws=Object.getOwnPropertyNames;var vs=Object.getPrototypeOf,Es=Object.prototype.hasOwnProperty;var Ss=(o,t,e)=>t in o?zt(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var ks=(o,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of ws(t))!Es.call(o,r)&&r!==e&&zt(o,r,{get:()=>t[r],enumerable:!(s=bs(t,r))||s.enumerable});return o};var As=(o,t,e)=>(e=o!=null?ms(vs(o)):{},ks(t||!o||!o.__esModule?zt(e,"default",{value:o,enumerable:!0}):e,o));var l=(o,t,e)=>Ss(o,typeof t!="symbol"?t+"":t,e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Pe=require("@noble/secp256k1");function _s(o){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(o){for(const e in o)if(e!=="default"){const s=Object.getOwnPropertyDescriptor(o,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:()=>o[e]})}}return t.default=o,Object.freeze(t)}const dt=_s(Pe),lt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ms(o){return o instanceof Uint8Array||ArrayBuffer.isView(o)&&o.constructor.name==="Uint8Array"}function Yt(o){if(!Number.isSafeInteger(o)||o<0)throw new Error("positive integer expected, got "+o)}function gt(o,...t){if(!Ms(o))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(o.length))throw new Error("Uint8Array expected of length "+t+", got length="+o.length)}function ie(o){if(typeof o!="function"||typeof o.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Yt(o.outputLen),Yt(o.blockLen)}function Dt(o,t=!0){if(o.destroyed)throw new Error("Hash instance has been destroyed");if(t&&o.finished)throw new Error("Hash#digest() has already been called")}function Ps(o,t){gt(o);const e=t.outputLen;if(o.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function wt(...o){for(let t=0;t<o.length;t++)o[t].fill(0)}function qt(o){return new DataView(o.buffer,o.byteOffset,o.byteLength)}function tt(o,t){return o<<32-t|o>>>t}const Te=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ts=Array.from({length:256},(o,t)=>t.toString(16).padStart(2,"0"));function D(o){if(gt(o),Te)return o.toHex();let t="";for(let e=0;e<o.length;e++)t+=Ts[o[e]];return t}const st={_0:48,_9:57,A:65,F:70,a:97,f:102};function ge(o){if(o>=st._0&&o<=st._9)return o-st._0;if(o>=st.A&&o<=st.F)return o-(st.A-10);if(o>=st.a&&o<=st.f)return o-(st.a-10)}function ct(o){if(typeof o!="string")throw new Error("hex string expected, got "+typeof o);if(Te)return Uint8Array.fromHex(o);const t=o.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(e);for(let r=0,i=0;r<e;r++,i+=2){const n=ge(o.charCodeAt(i)),a=ge(o.charCodeAt(i+1));if(n===void 0||a===void 0){const c=o[i]+o[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}s[r]=n*16+a}return s}function Is(o){if(typeof o!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(o))}function vt(o){return typeof o=="string"&&(o=Is(o)),gt(o),o}function It(...o){let t=0;for(let s=0;s<o.length;s++){const r=o[s];gt(r),t+=r.length}const e=new Uint8Array(t);for(let s=0,r=0;s<o.length;s++){const i=o[s];e.set(i,r),r+=i.length}return e}class Ie{}function Rs(o){const t=s=>o().update(vt(s)).digest(),e=o();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>o(),t}function ht(o=32){if(lt&&typeof lt.getRandomValues=="function")return lt.getRandomValues(new Uint8Array(o));if(lt&&typeof lt.randomBytes=="function")return Uint8Array.from(lt.randomBytes(o));throw new Error("crypto.getRandomValues must be defined")}function Cs(o,t,e,s){if(typeof o.setBigUint64=="function")return o.setBigUint64(t,e,s);const r=BigInt(32),i=BigInt(4294967295),n=Number(e>>r&i),a=Number(e&i),c=s?4:0,u=s?0:4;o.setUint32(t+c,n,s),o.setUint32(t+u,a,s)}function xs(o,t,e){return o&t^~o&e}function Ns(o,t,e){return o&t^o&e^t&e}class Ds extends Ie{constructor(t,e,s,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=qt(this.buffer)}update(t){Dt(this),t=vt(t),gt(t);const{view:e,buffer:s,blockLen:r}=this,i=t.length;for(let n=0;n<i;){const a=Math.min(r-this.pos,i-n);if(a===r){const c=qt(t);for(;r<=i-n;n+=r)this.process(c,n);continue}s.set(t.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===r&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Dt(this),Ps(t,this),this.finished=!0;const{buffer:e,view:s,blockLen:r,isLE:i}=this;let{pos:n}=this;e[n++]=128,wt(this.buffer.subarray(n)),this.padOffset>r-n&&(this.process(s,0),n=0);for(let d=n;d<r;d++)e[d]=0;Cs(s,r-8,BigInt(this.length*8),i),this.process(s,0);const a=qt(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,h[d],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const s=t.slice(0,e);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:s,length:r,finished:i,destroyed:n,pos:a}=this;return t.destroyed=n,t.finished=i,t.length=r,t.pos=a,r%e&&t.buffer.set(s),t}clone(){return this._cloneInto()}}const it=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ls=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array(64);class Fs extends Ds{constructor(t=32){super(64,t,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){const{A:t,B:e,C:s,D:r,E:i,F:n,G:a,H:c}=this;return[t,e,s,r,i,n,a,c]}set(t,e,s,r,i,n,a,c){this.A=t|0,this.B=e|0,this.C=s|0,this.D=r|0,this.E=i|0,this.F=n|0,this.G=a|0,this.H=c|0}process(t,e){for(let d=0;d<16;d++,e+=4)nt[d]=t.getUint32(e,!1);for(let d=16;d<64;d++){const f=nt[d-15],p=nt[d-2],g=tt(f,7)^tt(f,18)^f>>>3,y=tt(p,17)^tt(p,19)^p>>>10;nt[d]=y+nt[d-7]+g+nt[d-16]|0}let{A:s,B:r,C:i,D:n,E:a,F:c,G:u,H:h}=this;for(let d=0;d<64;d++){const f=tt(a,6)^tt(a,11)^tt(a,25),p=h+f+xs(a,c,u)+Ls[d]+nt[d]|0,y=(tt(s,2)^tt(s,13)^tt(s,22))+Ns(s,r,i)|0;h=u,u=c,c=a,a=n+p|0,n=i,i=r,r=s,s=p+y|0}s=s+this.A|0,r=r+this.B|0,i=i+this.C|0,n=n+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(s,r,i,n,a,c,u,h)}roundClean(){wt(nt)}destroy(){this.set(0,0,0,0,0,0,0,0),wt(this.buffer)}}const $s=Rs(()=>new Fs),et=$s,Re=["ws://umbrel.local:4848","wss://relay.damus.io"],Z={RELAY_TIMEOUT:1e4,PUBLISH_TIMEOUT:3e4,RETRY_ATTEMPTS:3,RETRY_DELAY:1e3,MAX_CONTENT_LENGTH:8192,CONNECTION_TIMEOUT:1e4},Jt={METADATA:0,TEXT_NOTE:1,RECOMMEND_SERVER:2,CONTACT_LIST:3,ENCRYPTED_DM:4,DELETE:5},O={EMPTY_CONTENT:"Content cannot be empty",CONTENT_TOO_LONG:"Content too long",NO_RELAYS:"No relays configured",CONNECTION_FAILED:"Failed to connect to relay",SIGNING_FAILED:"Failed to sign event",PUBLISH_FAILED:"Failed to publish to any relay",NO_EXTENSION:"No browser extension available",INVALID_EVENT:"Invalid event structure"},pt={EMPTY_CONTENT:"Add some content to your message",CONTENT_TOO_LONG:`Keep your message under ${Z.MAX_CONTENT_LENGTH} characters`,CONNECTION_FAILED:"Check your internet connection and try again",NO_EXTENSION:"Install a Nostr browser extension or the library will use a temporary key",PUBLISH_FAILED:"Try again or check if your relays are accessible"},Rt={HEX_64:/^[a-f0-9]{64}$/,HEX_128:/^[a-f0-9]{128}$/,WEBSOCKET_URL:/^wss?:\/\/.+/};class _{static createTextNote(t,e){return{pubkey:e,created_at:Math.floor(Date.now()/1e3),kind:Jt.TEXT_NOTE,tags:[],content:t}}static calculateEventId(t){const e=JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]),s=new TextEncoder().encode(e),r=et(s);return D(r)}static addEventId(t){const e=_.calculateEventId(t);return{...t,id:e}}static validateEvent(t){const e=[];if(t.pubkey||e.push("Missing pubkey"),t.created_at||e.push("Missing created_at"),typeof t.kind!="number"&&e.push("Missing or invalid kind"),Array.isArray(t.tags)||e.push("Missing or invalid tags"),typeof t.content!="string"&&e.push("Missing or invalid content"),t.pubkey&&!Rt.HEX_64.test(t.pubkey)&&e.push("Invalid pubkey format (must be 64-character hex string)"),t.id&&!Rt.HEX_64.test(t.id)&&e.push("Invalid event ID format (must be 64-character hex string)"),t.sig&&!Rt.HEX_128.test(t.sig)&&e.push("Invalid signature format (must be 128-character hex string)"),t.content===""&&!this.isEmptyContentAllowed(t.kind)&&e.push(O.EMPTY_CONTENT),t.content&&t.content.length>Z.MAX_CONTENT_LENGTH&&e.push(O.CONTENT_TOO_LONG),t.created_at){const s=Math.floor(Date.now()/1e3),r=s-3600,i=s+3600;(t.created_at<r||t.created_at>i)&&e.push("Timestamp is too far in the past or future")}return t.tags&&(Array.isArray(t.tags)?t.tags.forEach((s,r)=>{Array.isArray(s)?s.forEach((i,n)=>{typeof i!="string"&&e.push(`Tag ${r}[${n}] must be a string`)}):e.push(`Tag ${r} must be an array`)}):e.push("Tags must be an array")),{valid:e.length===0,errors:e}}static validateContent(t,e){const s=[];return t===""&&!this.isEmptyContentAllowed(e)&&s.push(O.EMPTY_CONTENT),t.length>Z.MAX_CONTENT_LENGTH&&s.push(O.CONTENT_TOO_LONG),{valid:s.length===0,errors:s}}static isEmptyContentAllowed(t){return t?[3,5,6,7,10002,34550,4550,27235,1063,3e4,30001,30002,30003,1985,1984].includes(t):!1}static verifyEventId(t){return _.calculateEventId({pubkey:t.pubkey,created_at:t.created_at,kind:t.kind,tags:t.tags,content:t.content})===t.id}static async createEvent(t,e,s={}){const r=_.validateContent(t,s.kind);if(!r.valid)throw new Error(`Invalid content: ${r.errors.join(", ")}`);const i={pubkey:e,created_at:s.created_at??Math.floor(Date.now()/1e3),kind:s.kind??Jt.TEXT_NOTE,tags:s.tags??[],content:t},n=_.validateEvent(i);if(!n.valid)throw new Error(`Invalid event: ${n.errors.join(", ")}`);return i}}async function Os(){if(typeof WebSocket<"u")return WebSocket;try{return(await import("ws")).default}catch{throw new Error("WebSocket not available. In Node.js, install: npm install ws")}}class Ce{constructor(t,e={}){l(this,"connections",new Map);l(this,"debug");l(this,"messageHandler");l(this,"authEventFactory");l(this,"onAuthStateChange");l(this,"publishTimeout");l(this,"maxReconnectAttempts",5);l(this,"baseReconnectDelay",1e3);l(this,"maxReconnectDelay",3e4);l(this,"reconnectEnabled",!0);l(this,"pendingPublishes",new Map);this.debug=e.debug??!1,this.publishTimeout=e.publishTimeout,t.forEach(s=>{this.connections.set(s,{url:s,state:"disconnected"})})}configureAuth(t){this.authEventFactory=t.authEventFactory,this.onAuthStateChange=t.onAuthStateChange}get relayUrls(){return Array.from(this.connections.keys())}get connectedRelays(){return Array.from(this.connections.entries()).filter(([t,e])=>e.state==="connected").map(([t,e])=>t)}addRelay(t,e={}){return this.connections.has(t)?!1:(this.connections.set(t,{url:t,state:"disconnected",temporary:!!e.temporary}),this.debug&&console.log(`Added ${e.temporary?"temporary ":""}relay: ${t}`),!0)}addRelays(t,e={}){const s=[];for(const r of t)this.connections.has(r)||(this.connections.set(r,{url:r,state:"disconnected",temporary:!!e.temporary}),s.push(r));return this.debug&&s.length&&console.log(`Added ${e.temporary?"temporary ":""}relays:`,s),s}async ensureConnected(t){const e=t.map(async s=>{const r=this.connections.get(s);if(!r)throw new Error(`Relay ${s} not configured`);r.state!=="connected"&&await this.connectToRelay(s)});await Promise.allSettled(e)}async disconnectRelay(t){const e=this.connections.get(t);if(e){if(e.ws){try{e.ws.close()}catch{}e.ws=void 0}e.state="disconnected"}}async disconnectRelays(t){await Promise.allSettled(t.map(e=>this.disconnectRelay(e)))}removeRelay(t){const e=this.connections.get(t);if(e){try{e.ws&&e.ws.close()}catch{}this.connections.delete(t),this.debug&&console.log(`Removed relay: ${t}`)}}removeRelays(t){for(const e of t)this.removeRelay(e)}async connect(){const t=this.relayUrls.map(e=>this.connectToRelay(e).catch(s=>(this.debug&&console.warn(`Failed to connect to ${e}:`,s),!1)));if(await Promise.allSettled(t),this.connectedRelays.length===0)throw new Error("Failed to connect to any relay")}async connectToRelay(t){const e=this.connections.get(t);if(!e)throw new Error(`Relay ${t} not configured`);return e.state==="connected"?!0:(e.state="connecting",new Promise(async(s,r)=>{try{const i=await Os(),n=new i(t),a=setTimeout(()=>{n.close(),e.state="error",e.error="Connection timeout",r(new Error(`Connection to ${t} timed out`))},Z.CONNECTION_TIMEOUT);n.onopen=()=>{clearTimeout(a),e.ws=n,e.state="connected",e.lastConnected=Date.now(),e.error=void 0,this.debug&&console.log(`Connected to relay: ${t}`),s(!0)},n.onerror=c=>{clearTimeout(a),e.state="error",e.error="WebSocket error",this.debug&&console.error(`WebSocket error for ${t}:`,c),r(new Error(`Failed to connect to ${t}: WebSocket error`))},n.onclose=c=>{e.state="disconnected",e.ws=void 0,this.debug&&console.log(`Disconnected from relay: ${t}`,c.code,c.reason),this.reconnectEnabled&&c.code!==1e3&&this.scheduleReconnection(t)},n.onmessage=c=>{this.handleRelayMessage(t,c.data)}}catch(i){e.state="error",e.error=i instanceof Error?i.message:"Unknown error",r(i)}}))}async publishToRelays(t,e,s){const r=[],i=!!(s!=null&&s.resolveOnFirstOk),n=Math.max(1,(s==null?void 0:s.minAcks)??1),a=(s==null?void 0:s.overallTimeoutMs)??this.publishTimeout??Z.PUBLISH_TIMEOUT;if(i){let u=0,h;const d=new Promise(p=>{h=p}),f=setTimeout(()=>{try{h(r.slice())}catch{}},a);return e.forEach(async p=>{const g=Date.now();try{const y=await this.publishToRelay(p,t),b=Date.now()-g;if(r.push({relay:p,success:y,latency:b}),y&&(u++,u>=n)){try{clearTimeout(f)}catch{}h(r.slice())}}catch(y){const b=Date.now()-g;r.push({relay:p,success:!1,error:y instanceof Error?y.message:"Unknown error",latency:b})}}),await d}const c=e.map(async u=>{const h=Date.now();try{const d=await this.publishToRelay(u,t),f=Date.now()-h;r.push({relay:u,success:d,latency:f})}catch(d){const f=Date.now()-h;r.push({relay:u,success:!1,error:d instanceof Error?d.message:"Unknown error",latency:f})}});return await Promise.allSettled(c),r}async publishToAll(t){const e=[],s=this.connectedRelays.map(async r=>{const i=Date.now();try{const n=await this.publishToRelay(r,t),a=Date.now()-i;e.push({relay:r,success:n,latency:a})}catch(n){const a=Date.now()-i;e.push({relay:r,success:!1,error:n instanceof Error?n.message:"Unknown error",latency:a})}});return await Promise.allSettled(s),e}async publishToRelay(t,e){const s=this.connections.get(t);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${t}`);return new Promise((r,i)=>{const n=s.ws,a=["EVENT",e],c=setTimeout(()=>{const h=`${e.id}|${t}`;this.pendingPublishes.delete(h),i(new Error("Publish timeout"))},this.publishTimeout??Z.PUBLISH_TIMEOUT),u=`${e.id}|${t}`;this.pendingPublishes.set(u,{resolve:r,reject:i,timeout:c,originalEvent:e,retries:0,awaitingAuth:!1});try{const h=JSON.stringify(a);n.send(h),this.debug&&(console.log(`📤 Publishing event ${e.id} to ${t}`),console.log("📤 Message:",h),console.log("📤 Added to pending:",u))}catch(h){clearTimeout(c);const d=`${e.id}|${t}`;this.pendingPublishes.delete(d),i(h)}})}isAuthRequiredError(t){if(typeof t!="string")return!1;const e=t.toLowerCase();return e.includes("auth-required")||e.includes("restricted")||e.includes("nip-42")||e.includes("nip42")}retryPendingAfterAuth(t){const e=this.connections.get(t);if(!e||e.state!=="connected"||!e.ws)return;const s=e.ws;this.pendingPublishes.forEach((r,i)=>{const[n,a]=i.split("|");if(a===t&&r.awaitingAuth){try{clearTimeout(r.timeout)}catch{}r.timeout=setTimeout(()=>{this.pendingPublishes.delete(i),r.reject(new Error("Publish timeout after AUTH"))},this.publishTimeout??Z.PUBLISH_TIMEOUT);try{const c=["EVENT",r.originalEvent];s.send(JSON.stringify(c)),r.awaitingAuth=!1,r.retries=(r.retries||0)+1,this.debug&&console.log(`🔁 Re-publishing event ${n} to ${t} after AUTH`)}catch(c){this.pendingPublishes.delete(i),r.reject(c)}}})}handleRelayMessage(t,e){var s;try{const r=JSON.parse(e);if(this.debug&&console.log(`📥 Message from ${t}:`,r),r[0]==="OK"){const[,i,n,a]=r,c=`${i}|${t}`,u=this.pendingPublishes.get(c);if(this.debug){console.log(`OK for event ${i} @ ${t}, success: ${n}, pending: ${!!u}`);const h=Array.from(this.pendingPublishes.keys());console.log("Pending publishes:",h)}if(u)if(n)clearTimeout(u.timeout),this.pendingPublishes.delete(c),u.resolve(!0);else if(this.isAuthRequiredError(a)){if(this.debug&&console.log(`🔐 Auth required for ${t} on event ${i}:`,a),(u.retries||0)>=1){clearTimeout(u.timeout),this.pendingPublishes.delete(c),u.reject(new Error("Relay requires AUTH but retry already attempted"));return}u.awaitingAuth=!0;try{clearTimeout(u.timeout)}catch{}u.timeout=setTimeout(()=>{this.pendingPublishes.delete(c),u.reject(new Error("Publish timeout waiting for AUTH"))},this.publishTimeout??Z.PUBLISH_TIMEOUT),this.tryAuthenticate(t)}else clearTimeout(u.timeout),this.pendingPublishes.delete(c),u.reject(new Error(a||"Relay rejected event"));else{const h=this.connections.get(t);if(h&&h.lastAuthEventId===i)h.isAuthenticated=!!n,this.debug&&console.log(`🔐 AUTH ${n?"succeeded":"failed"} for ${t}${a?" ("+a+")":""}`),(s=this.onAuthStateChange)==null||s.call(this,t,{authenticated:!!n,reason:n?void 0:a}),n&&this.retryPendingAfterAuth(t);else if(this.debug){const d=n?"already resolved (duplicate OK)":this.isAuthRequiredError(a)?"AUTH OK not matching pending":"late/unsolicited OK";console.log(`ℹ️ OK for ${i} @ ${t} without pending - ${d}${a?`: ${a}`:""}`)}}}else if(r[0]==="NOTICE"){const[,i]=r;this.debug&&console.log(`Notice from ${t}:`,i),typeof i=="string"&&(i.startsWith("auth-required:")||i.startsWith("restricted:"))&&(this.debug&&console.log("NIP-42 hint via NOTICE:",i),this.tryAuthenticate(t))}else if(r[0]==="EVENT"||r[0]==="EOSE")this.messageHandler?this.messageHandler(t,r):this.debug&&console.log(`No message handler registered for ${r[0]} message`);else if(r[0]==="AUTH"){const[,i]=r,n=this.connections.get(t);n&&(n.lastAuthChallenge=i,n.isAuthenticated=!1),this.debug&&console.log(`🔐 NIP-42 challenge from ${t}:`,i),this.tryAuthenticate(t)}else if(r[0]==="CLOSED"){const[,,i]=r;typeof i=="string"&&(i.startsWith("auth-required:")||i.startsWith("restricted:"))&&(this.debug&&console.log(`🔐 NIP-42 CLOSED hint from ${t}:`,i),this.tryAuthenticate(t))}}catch(r){this.debug&&console.error(`Failed to parse message from ${t}:`,r)}}async tryAuthenticate(t){var r,i;const e=this.connections.get(t);if(!e||e.state!=="connected"||!e.ws||!this.authEventFactory)return;const s=e.lastAuthChallenge;if(!s){this.debug&&console.log("NIP-42: No challenge stored for",t);return}try{const n=await this.authEventFactory({relay:t,challenge:s});e.lastAuthEventId=n.id;const a=["AUTH",n];e.ws.send(JSON.stringify(a)),this.debug&&console.log(`📤 Sent AUTH to ${t}`),(r=this.onAuthStateChange)==null||r.call(this,t,{authenticated:!1,challenge:s})}catch(n){this.debug&&console.error("NIP-42 AUTH send failed:",n),(i=this.onAuthStateChange)==null||i.call(this,t,{authenticated:!1,challenge:s,reason:n.message})}}async getRelayInfo(t){try{const e=t.replace(/^ws/,"http"),s=await fetch(e,{headers:{Accept:"application/nostr+json"}});if(!s.ok)throw new Error(`HTTP ${s.status}`);return await s.json()}catch(e){throw new Error(`Failed to get relay info: ${e instanceof Error?e.message:"Unknown error"}`)}}async testRelay(t){try{return Rt.WEBSOCKET_URL.test(t)?(await this.connectToRelay(t),{success:!0}):{success:!1,error:"Invalid WebSocket URL format"}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async disconnect(){this.pendingPublishes.forEach(({timeout:t,reject:e})=>{try{clearTimeout(t)}catch{}try{e(new Error("Disconnecting"))}catch{}}),this.pendingPublishes.clear(),this.connections.forEach(t=>{t.ws&&(t.ws.close(),t.ws=void 0),t.state="disconnected"})}async sendToAll(t){const e=this.connectedRelays.map(s=>this.sendToRelay(s,t).catch(r=>{this.debug&&console.warn(`Failed to send to ${s}:`,r)}));await Promise.allSettled(e)}async sendToRelays(t,e){const s=t.map(r=>this.sendToRelay(r,e).catch(i=>{this.debug&&console.warn(`Failed to send to ${r}:`,i)}));await Promise.allSettled(s)}async sendToRelay(t,e){const s=this.connections.get(t);if(!s||s.state!=="connected"||!s.ws)throw new Error(`Not connected to relay: ${t}`);const r=JSON.stringify(e);s.ws.send(r),this.debug&&console.log(`📤 Sent to ${t}:`,r)}setMessageHandler(t){this.messageHandler=t}getStats(){const t={total:this.connections.size,connected:0,connecting:0,disconnected:0,error:0};return this.connections.forEach(e=>{t[e.state]++}),t}scheduleReconnection(t){const e=this.connections.get(t);if(!e)return;if(e.reconnectTimeout&&(clearTimeout(e.reconnectTimeout),e.reconnectTimeout=void 0),e.reconnectAttempts===void 0&&(e.reconnectAttempts=0),e.reconnectAttempts>=this.maxReconnectAttempts){this.debug&&console.warn(`Max reconnection attempts reached for relay: ${t}`),e.state="error",e.error=`Max reconnection attempts (${this.maxReconnectAttempts}) exceeded`;return}const r=Math.min(this.baseReconnectDelay*Math.pow(2,e.reconnectAttempts),this.maxReconnectDelay)+Math.random()*1e3;this.debug&&console.log(`Scheduling reconnection to ${t} in ${Math.round(r)}ms (attempt ${e.reconnectAttempts+1}/${this.maxReconnectAttempts})`),e.reconnectTimeout=setTimeout(()=>{this.attemptReconnection(t)},r)}async attemptReconnection(t){const e=this.connections.get(t);if(e){e.reconnectAttempts=(e.reconnectAttempts||0)+1,e.lastReconnectAttempt=Date.now(),this.debug&&console.log(`Attempting reconnection to ${t} (attempt ${e.reconnectAttempts})`);try{await this.connectToRelay(t)&&(e.reconnectAttempts=0,e.reconnectTimeout=void 0,this.debug&&console.log(`Successfully reconnected to relay: ${t}`))}catch(s){this.debug&&console.warn(`Reconnection attempt failed for ${t}:`,s),e.reconnectAttempts<this.maxReconnectAttempts?this.scheduleReconnection(t):(e.state="error",e.error=`Reconnection failed after ${this.maxReconnectAttempts} attempts`)}}}setReconnectionEnabled(t){if(this.reconnectEnabled=t,!t)for(const e of this.connections.values())e.reconnectTimeout&&(clearTimeout(e.reconnectTimeout),e.reconnectTimeout=void 0)}configureReconnection(t){t.maxAttempts!==void 0&&(this.maxReconnectAttempts=Math.max(1,t.maxAttempts)),t.baseDelay!==void 0&&(this.baseReconnectDelay=Math.max(100,t.baseDelay)),t.maxDelay!==void 0&&(this.maxReconnectDelay=Math.max(this.baseReconnectDelay,t.maxDelay))}async reconnectRelay(t){const e=this.connections.get(t);if(!e)throw new Error(`Relay ${t} not configured`);return e.reconnectTimeout&&(clearTimeout(e.reconnectTimeout),e.reconnectTimeout=void 0),e.reconnectAttempts=0,this.connectToRelay(t)}getReconnectionStatus(){const t={};for(const[e,s]of this.connections.entries())if(t[e]={attempts:s.reconnectAttempts||0,lastAttempt:s.lastReconnectAttempt},s.reconnectTimeout){const r=Date.now(),i=s.lastReconnectAttempt||r,n=Math.min(this.baseReconnectDelay*Math.pow(2,(s.reconnectAttempts||0)-1),this.maxReconnectDelay),a=i+n;t[e].nextAttemptIn=Math.max(0,a-r)}return t}}class Et{constructor(){l(this,"isExtension",!0);l(this,"cachedPublicKey")}async getPublicKey(){if(!window.nostr)throw new Error(O.NO_EXTENSION);try{try{typeof window.nostr.enable=="function"&&await window.nostr.enable()}catch{}const t=await window.nostr.getPublicKey();return this.cachedPublicKey=t,t}catch(t){throw new Error(`Extension signing failed: ${t instanceof Error?t.message:"Unknown error"}`)}}getPublicKeySync(){return this.cachedPublicKey||null}async signEvent(t){if(!window.nostr)throw new Error(O.NO_EXTENSION);try{return(await window.nostr.signEvent(t)).sig}catch(e){throw new Error(`Extension signing failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async capabilities(){var e;const t=typeof window<"u"&&!!((e=window.nostr)!=null&&e.nip44)&&typeof window.nostr.nip44.encrypt=="function"&&typeof window.nostr.nip44.decrypt=="function";return{nip44Encrypt:t,nip44Decrypt:t}}async nip44Encrypt(t,e){var s,r;if(!((r=(s=window.nostr)==null?void 0:s.nip44)!=null&&r.encrypt))throw new Error("NIP-44 encrypt not supported by extension");return window.nostr.nip44.encrypt(t,e)}async nip44Decrypt(t,e){var s,r;if(!((r=(s=window.nostr)==null?void 0:s.nip44)!=null&&r.decrypt))throw new Error("NIP-44 decrypt not supported by extension");return window.nostr.nip44.decrypt(t,e)}static async isAvailable(){return typeof window<"u"&&typeof window.nostr<"u"&&typeof window.nostr.getPublicKey=="function"&&typeof window.nostr.signEvent=="function"}}class ft{constructor(){l(this,"privateKey");l(this,"publicKey");const t=ht(32);this.privateKey=D(t),this.publicKey=D(dt.schnorr.getPublicKey(this.privateKey))}async getPublicKey(){return this.publicKey}getPublicKeySync(){return this.publicKey}async signEvent(t){const e=_.calculateEventId(t),s=await dt.schnorr.sign(e,this.privateKey);return D(s)}async capabilities(){return{nip44Encrypt:!0,nip44Decrypt:!0}}async nip44Encrypt(t,e){const{NIP44Crypto:s}=await Promise.resolve().then(()=>Zt),r=s.deriveConversationKey(this.privateKey,t),i=s.encrypt(e,r);if(!i||typeof i.payload!="string")throw new Error("NIP-44 encrypt failed");return i.payload}async nip44Decrypt(t,e){const{NIP44Crypto:s}=await Promise.resolve().then(()=>Zt),r=s.deriveConversationKey(this.privateKey,t),i=s.decrypt(e,r);if(!i||!i.isValid)throw new Error("NIP-44 decrypt failed");return i.plaintext}}class Bs extends ft{}class Us extends ft{}class xe{static async createBestAvailable(){if(await Et.isAvailable())try{const t=new Et;return await t.getPublicKey(),{provider:t,method:"extension"}}catch(t){console.warn("Extension detected but failed to initialize:",t)}return{provider:new ft,method:"temporary"}}}class F{static createError(t,e,s={}){return{message:e,retryable:s.retryable??!1,suggestion:s.suggestion,userAction:s.userAction}}static handleContentError(t){return t===""?F.createError("validation",O.EMPTY_CONTENT,{retryable:!0,suggestion:pt.EMPTY_CONTENT}):t.length>8192?F.createError("validation",O.CONTENT_TOO_LONG,{retryable:!0,suggestion:pt.CONTENT_TOO_LONG}):F.createError("validation",O.INVALID_EVENT)}static handleSigningError(t){const e=t.message.toLowerCase();return e.includes("user declined")||e.includes("denied")?F.createError("signing","User declined to sign the event",{retryable:!0,userAction:"User declined signing",suggestion:"Click approve in your Nostr extension to publish the event"}):e.includes("no extension")?F.createError("signing",O.NO_EXTENSION,{retryable:!1,suggestion:pt.NO_EXTENSION}):F.createError("signing",O.SIGNING_FAILED,{retryable:!0,suggestion:"Check your Nostr extension and try again"})}static handleConnectionError(t,e){const s=e.message.toLowerCase();return s.includes("timeout")?F.createError("network",`Connection to ${t} timed out`,{retryable:!0,suggestion:"The relay might be slow or unavailable. Try again or use different relays"}):s.includes("refused")||s.includes("failed to connect")?F.createError("network",`Failed to connect to ${t}`,{retryable:!0,suggestion:"The relay might be down. Check the relay URL or try different relays"}):F.createError("network",O.CONNECTION_FAILED,{retryable:!0,suggestion:pt.CONNECTION_FAILED})}static analyzeRelayResults(t){const e=t.length,s=t.filter(i=>i.success),r=t.filter(i=>!i.success);if(e===0)return{success:!1,error:F.createError("config",O.NO_RELAYS,{retryable:!1,suggestion:"Configure at least one relay URL"})};if(s.length===0){const i=r.every(a=>{var c;return(c=a.error)==null?void 0:c.toLowerCase().includes("timeout")}),n=r.every(a=>{var c,u;return((c=a.error)==null?void 0:c.toLowerCase().includes("connect"))||((u=a.error)==null?void 0:u.toLowerCase().includes("refused"))});return i?{success:!1,error:F.createError("network","All relays timed out",{retryable:!0,suggestion:"Check your internet connection or try again later"})}:n?{success:!1,error:F.createError("network","Could not connect to any relay",{retryable:!0,suggestion:"Check relay URLs and your internet connection"})}:{success:!1,error:F.createError("relay",O.PUBLISH_FAILED,{retryable:!0,suggestion:pt.PUBLISH_FAILED})}}return{success:!0}}static formatErrorForUser(t,e){let s=t.message;if(e!=null&&e.relayResults){const r=e.relayResults.filter(n=>n.success).length,i=e.relayResults.length;r>0?s+=` (${r}/${i} relays succeeded)`:s+=` (0/${i} relays succeeded)`}return t.suggestion&&(s+=`

Suggestion: ${t.suggestion}`),t.retryable&&(s+=`

This error is retryable - you can try again.`),s}static shouldRetry(t,e,s){return t.retryable&&e<s}static calculateRetryDelay(t,e=1e3){return Math.min(e*Math.pow(2,t),3e4)}}class Ct{constructor(t){l(this,"eventData");l(this,"nostrInstance");l(this,"signed",!1);l(this,"signedEvent");l(this,"targetRelays");this.nostrInstance=t,this.eventData={tags:[]}}contentWarning(t){return t&&t.length>0?this.eventData.tags.push(["content-warning",t]):this.eventData.tags.push(["content-warning"]),this}attachMedia(t,e){const s=this.eventData.content||"",r=!s.includes(t);this.eventData.content=r?s?`${s} ${t}`:t:s;const i=[];if(i.push(`url ${t}`),e!=null&&e.mimeType&&i.push(`m ${e.mimeType}`),e!=null&&e.blurhash&&i.push(`blurhash ${e.blurhash}`),e!=null&&e.dim&&i.push(`dim ${e.dim}`),e!=null&&e.alt&&i.push(`alt ${e.alt}`),e!=null&&e.sha256&&i.push(`x ${e.sha256}`),e!=null&&e.fallbacks&&e.fallbacks.length)for(const n of e.fallbacks)i.push(`fallback ${n}`);return this.eventData.tags.push(["imeta",...i]),this}kind(t){return this.eventData.kind=t,this}content(t){return this.eventData.content=t,this}tag(t,e,...s){const r=[t,e,...s];return this.eventData.tags.push(r),this}tags(t){return this.eventData.tags.push(...t),this}hashtag(t){return this.eventData.tags.push(["t",t]),this}replyTo(t,e){return e?this.eventData.tags.push(["e",t,e,"reply"]):this.eventData.tags.push(["e",t,"","reply"]),this}mention(t,e){return e?this.eventData.tags.push(["p",t,e]):this.eventData.tags.push(["p",t]),this}subject(t){return this.eventData.tags.push(["subject",t]),this}timestamp(t){return this.eventData.created_at=t,this}toRelays(...t){const e=(t||[]).map(s=>(s||"").trim().replace(/\/+$/,"")).filter(Boolean);return this.targetRelays=e,this}toRelayList(t){const e=(t||[]).map(s=>(s||"").trim().replace(/\/+$/,"")).filter(Boolean);return this.targetRelays=e,this}async sign(){const t=this.eventData.kind||1;if(!new Set([3,5,6,7,10002,1984,1985,3e4,30001,30002,30003,34550,4550,27235,1063]).has(t)&&(!this.eventData.content||this.eventData.content.length===0))throw new Error("Content is required before signing");const r=this.nostrInstance.signingProvider;if(!r)throw new Error("No signing provider available. Call initializeSigning() first.");const i={pubkey:await r.getPublicKey(),kind:this.eventData.kind||1,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at||Math.floor(Date.now()/1e3)},n=_.validateEvent(i);if(!n.valid)throw new Error(`Invalid event: ${n.errors.join(", ")}`);const a=_.calculateEventId(i),c={...i,id:a,sig:await r.signEvent({...i,id:a})};return this.signedEvent=c,this.signed=!0,this}async build(){return this.signed&&this.signedEvent?this.signedEvent:(await this.sign(),this.signedEvent)}async publish(){const t=this.eventData.kind||1;if(!new Set([3,5,6,7,10002,1984,1985,3e4,30001,30002,30003,34550,4550,27235,1063]).has(t)&&(!this.eventData.content||this.eventData.content.length===0))throw new Error("Content is required before publishing");if(this.signed&&this.signedEvent){if(this.targetRelays&&this.targetRelays.length)return await this.nostrInstance.publishSignedToRelaysSmart(this.signedEvent,this.targetRelays);const a=await this.nostrInstance.relayManager.publishToAll(this.signedEvent),c=a.some(u=>u.success);return{success:c,eventId:c?this.signedEvent.id:void 0,event:c?this.signedEvent:void 0,relayResults:a,timestamp:Date.now(),error:c?void 0:{message:"Failed to publish to any relay",code:"PUBLISH_FAILED",retryable:!0}}}const r=this.nostrInstance.signingProvider;if(!r)throw new Error("No signing provider available. Call initializeSigning() first.");const n={pubkey:await r.getPublicKey(),kind:this.eventData.kind||1,content:this.eventData.content,tags:this.eventData.tags,created_at:this.eventData.created_at||Math.floor(Date.now()/1e3)};return this.targetRelays&&this.targetRelays.length?await this.nostrInstance.publishToRelaysSmart(n,this.targetRelays):await this.nostrInstance.publish(n)}getEventData(){return{...this.eventData}}reset(){return this.eventData={tags:[]},this.signed=!1,this.signedEvent=void 0,this}}class Ne{constructor(t){l(this,"nostrInstance");this.nostrInstance=t}create(){return new Ct(this.nostrInstance)}kind(t){return new Ct(this.nostrInstance).kind(t)}content(t){return new Ct(this.nostrInstance).content(t)}note(t){return this.create().kind(1).content(t)}dm(t,e){return this.create().kind(4).content(t).tag("p",e)}job(t){return this.create().kind(30023).content(t).tag("t","jobs")}reaction(t,e="+"){return this.create().kind(7).content(e).tag("e",t)}deletion(t,e){return this.create().kind(5).content(e||"").tag("e",t,"","deletion")}async publish(t){return await this.nostrInstance.publish(t)}}function rt(o){const t=new Set;let e=o;return{subscribe(s){return s(e),t.add(s),()=>t.delete(s)},set(s){e=s,t.forEach(r=>r(e))},update(s){e=s(e),t.forEach(r=>r(e))}}}function T(o,t){const e=Array.isArray(o)?o:[o],s=new Set;let r,i=!1;const n=[],a=()=>{if(e.length===1){const c=e[0].subscribe(u=>{const h=t(u);(!i||h!==r)&&(r=h,i&&s.forEach(d=>d(r)))});n.length===0&&n.push(c)}};return{subscribe(c){return i||(a(),i=!0),r!==void 0&&c(r),s.add(c),()=>{s.delete(c),s.size===0&&(n.forEach(u=>u()),n.length=0,i=!1)}}}}function De(o){return{subscribe:o.subscribe.bind(o),derive:t=>T(o,t)}}class St{constructor(t,e,s){l(this,"_events");l(this,"_readIds",new Set);l(this,"parent");this.parent=t,this._events=T(t.events,r=>{let i=r;return e&&(i=i.filter(e)),s&&(i=[...i].sort(s)),i})}subscribe(t){return this._events.subscribe(t)}get events(){return this._events}get status(){return this.parent.status}get error(){return this.parent.error}get loading(){return this.parent.loading}get count(){return T(this._events,t=>t.length)}get latest(){return T(this._events,t=>t[0]||null)}get hasMore(){return this.parent.hasMore}get isEmpty(){return T(this._events,t=>t.length===0)}async close(){return this.parent.close()}async refresh(){return this.parent.refresh()}reset(){return this._readIds.clear(),this.parent.reset()}async updateFilter(t){return this.parent.updateFilter(t)}async updateOptions(t){return this.parent.updateOptions(t)}derive(t){return De(T(this._events,t))}async retry(){return this.parent.retry()}clearError(){return this.parent.clearError()}async loadMore(t){return this.parent.loadMore(t)}async loadNewer(){return this.parent.loadNewer()}async loadOlder(){return this.parent.loadOlder()}markAsRead(t){this._readIds.add(t)}markAllAsRead(){let t=[];this._events.subscribe(s=>{t=s})(),t.forEach(s=>this._readIds.add(s.id))}removeEvent(t){return this.parent.removeEvent(t)}filter(t){return new St(this,t)}sortBy(t){return new St(this,void 0,t)}getReadStatus(){let t=[];this._events.subscribe(n=>{t=n})();const s=t.filter(n=>this._readIds.has(n.id)).length,r=t.length,i=r-s;return{read:s,unread:i,total:r}}}class Kt{constructor(t,e,s={},r={}){l(this,"_events",rt([]));l(this,"_status",rt("connecting"));l(this,"_error",rt(null));l(this,"_loading",rt(!1));l(this,"_count",rt(0));l(this,"_readIds",new Set);l(this,"subscription");l(this,"subscriptionManager");l(this,"filters");l(this,"options");l(this,"maxEvents");l(this,"isLive");l(this,"eventPredicate");l(this,"eventComparator");this.subscriptionManager=t,this.filters=e,this.options=s,this.maxEvents=r.maxEvents,this.isLive=r.live||!1,this.eventPredicate=r.predicate,this.eventComparator=r.comparator,this.initializeSubscription()}subscribe(t){return this._events.subscribe(t)}get events(){return this._events}get status(){return this._status}get error(){return this._error}get loading(){return this._loading}get count(){return this._count}get latest(){return T(this._events,t=>t[0]||null)}get hasMore(){return T(this._events,()=>!0)}get isEmpty(){return T(this._events,t=>t.length===0)}async close(){var t,e;(e=(t=this.subscription)==null?void 0:t.subscription)!=null&&e.cleanup&&this.subscription.subscription.cleanup(),this._status.set("closed")}async refresh(){this.reset(),await this.initializeSubscription()}reset(){this._events.set([]),this._count.set(0),this._readIds.clear(),this._error.set(null)}async updateFilter(t){this.filters=this.filters.map(e=>({...e,...t})),await this.refresh()}async updateOptions(t){this.options={...this.options,...t},await this.refresh()}derive(t){return De(T(this._events,t))}async retry(){this._status.set("reconnecting"),this._error.set(null),await this.initializeSubscription()}clearError(){this._error.set(null)}async loadMore(t=10){return[]}async loadNewer(){return[]}async loadOlder(){return[]}markAsRead(t){this._readIds.add(t)}markAllAsRead(){let t=[];this._events.subscribe(s=>{t=s})(),t.forEach(s=>this._readIds.add(s.id))}removeEvent(t){this._events.update(e=>e.filter(s=>s.id!==t)),this._count.update(e=>e-1)}filter(t){return new St(this,t,this.eventComparator)}sortBy(t){return new St(this,this.eventPredicate,t)}getReadStatus(){let t=[];this._events.subscribe(n=>{t=n})();const s=t.filter(n=>this._readIds.has(n.id)).length,r=t.length,i=r-s;return{read:s,unread:i,total:r}}_testInjectEvent(t){this.handleEvent(t)}_testSimulateEOSE(){this._status.set("active"),this._loading.set(!1)}async _testWaitForInit(){let t=0;for(;!this.subscription&&t<100;)await new Promise(e=>setTimeout(e,10)),t++}async initializeSubscription(){this._loading.set(!0),this._status.set("connecting");try{const t={...this.options,onEvent:r=>{this.handleEvent(r)},onEose:r=>{this._status.set("active"),this._loading.set(!1)},onClose:r=>{this._status.set("closed")}},e=await this.subscriptionManager.getOrCreateSubscription(this.filters),s=e.addListener({onEvent:t.onEvent,onEose:t.onEose,onClose:t.onClose,onError:t.onError});this.subscription={success:!0,subscription:{id:e.key,cleanup:()=>e.removeListener(s)},relayResults:[],error:void 0},this.subscription.success?this._error.set(null):(this._error.set(this.subscription.error||{message:"Subscription failed",retryable:!0}),this._status.set("error"),this._loading.set(!1))}catch(t){this._error.set({message:t instanceof Error?t.message:"Unknown error",retryable:!0}),this._status.set("error"),this._loading.set(!1)}}handleEvent(t){this.eventPredicate&&!this.eventPredicate(t)||(this._events.update(e=>{if(e.some(r=>r.id===t.id))return e;const s=[...e,t];return this.eventComparator?s.sort(this.eventComparator):s.sort((r,i)=>i.created_at-r.created_at),this.maxEvents&&s.length>this.maxEvents?s.slice(0,this.maxEvents):s}),this._count.update(e=>e+1))}}class Ks{constructor(t){l(this,"filter",{});l(this,"options",{});l(this,"config",{});this.subscriptionManager=t}kinds(t){return this.filter.kinds=t,this}authors(t){return this.filter.authors=t,this}since(t){return this.filter.since=t,this}until(t){return this.filter.until=t,this}limit(t){return this.filter.limit=t,this}live(t){return this.config.live=t,this.options={...this.options,live:t},this}maxEvents(t){return this.config.maxEvents=t,this}build(){const t=[this.filter];return new Kt(this.subscriptionManager,t,this.options,this.config)}}let ut;function Hs(o){ut=o}function Ws(){if(!ut)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new Ks(ut)}function zs(o){if(!ut)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");const t=o.toFilter();return new Kt(ut,t)}function qs(o){if(!ut)throw new Error("Default SubscriptionManager not set. Call setDefaultSubscriptionManager first.");return new Kt(ut,[o])}class v extends Error{constructor(t,e,s){super(t),this.code=e,this.details=s,this.name="NIP59Error"}}var E=(o=>(o.INVALID_RUMOR="INVALID_RUMOR",o.SEAL_CREATION_FAILED="SEAL_CREATION_FAILED",o.GIFT_WRAP_CREATION_FAILED="GIFT_WRAP_CREATION_FAILED",o.EPHEMERAL_KEY_GENERATION_FAILED="EPHEMERAL_KEY_GENERATION_FAILED",o.TIMESTAMP_RANDOMIZATION_FAILED="TIMESTAMP_RANDOMIZATION_FAILED",o.DECRYPTION_FAILED="DECRYPTION_FAILED",o.INVALID_GIFT_WRAP="INVALID_GIFT_WRAP",o.INVALID_SEAL="INVALID_SEAL",o.NO_RECIPIENTS="NO_RECIPIENTS",o.INVALID_RECIPIENT="INVALID_RECIPIENT",o.INVALID_PRIVATE_KEY="INVALID_PRIVATE_KEY",o))(E||{});const Q={SEAL_KIND:13,GIFT_WRAP_KIND:1059,MAX_TIMESTAMP_AGE_SECONDS:2*24*60*60,MIN_TIMESTAMP_AGE_SECONDS:0};class Lt{static async createSealWithSigner(t,e,s){try{if(this.validateRumor(t),this.validatePublicKey(s),!e||typeof e.nip44Encrypt!="function")throw new v("Signer must provide nip44Encrypt capability",E.SEAL_CREATION_FAILED);if(typeof e.signEvent!="function")throw new v("Signer must provide signEvent capability",E.SEAL_CREATION_FAILED);const r=JSON.stringify(t),i=await e.nip44Encrypt(s,r),n=t.pubkey,a={pubkey:n,created_at:Math.floor(Date.now()/1e3),kind:Q.SEAL_KIND,tags:[],content:i},c=this.calculateEventId(a),u={...a,id:c},h=await e.signEvent(u);return{id:c,pubkey:n,created_at:a.created_at,kind:Q.SEAL_KIND,tags:[],content:i,sig:h}}catch(r){throw r instanceof v?r:new v(`Seal creation (with signer) failed: ${r.message}`,E.SEAL_CREATION_FAILED,r)}}static validateRumor(t){if(!t||typeof t!="object")throw new v("Rumor must be a valid object",E.INVALID_RUMOR);if(typeof t.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(t.pubkey))throw new v("Rumor must have valid pubkey",E.INVALID_RUMOR);if(typeof t.created_at!="number"||t.created_at<=0)throw new v("Rumor must have valid created_at timestamp",E.INVALID_RUMOR);if(typeof t.kind!="number"||t.kind<0||t.kind>65535)throw new v("Rumor must have valid kind",E.INVALID_RUMOR);if(!Array.isArray(t.tags))throw new v("Rumor must have valid tags array",E.INVALID_RUMOR);if(typeof t.content!="string")throw new v("Rumor must have valid content string",E.INVALID_RUMOR)}static isValidRumor(t){return t&&typeof t=="object"&&typeof t.pubkey=="string"&&typeof t.created_at=="number"&&typeof t.kind=="number"&&Array.isArray(t.tags)&&typeof t.content=="string"}static validatePublicKey(t){if(typeof t!="string"||!/^[0-9a-f]{64}$/i.test(t))throw new v("Invalid public key format",E.SEAL_CREATION_FAILED)}static calculateEventId(t){const e=JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]),s=et(new TextEncoder().encode(e));return Array.from(s).map(r=>r.toString(16).padStart(2,"0")).join("")}}const Vs=Object.freeze(Object.defineProperty({__proto__:null,SealCreator:Lt},Symbol.toStringTag,{value:"Module"}));class Le extends Ie{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,ie(t);const s=vt(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(s.length>r?t.create().update(s).digest():s);for(let n=0;n<i.length;n++)i[n]^=54;this.iHash.update(i),this.oHash=t.create();for(let n=0;n<i.length;n++)i[n]^=106;this.oHash.update(i),wt(i)}update(t){return Dt(this),this.iHash.update(t),this}digestInto(t){Dt(this),gt(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:s,finished:r,destroyed:i,blockLen:n,outputLen:a}=this;return t=t,t.finished=r,t.destroyed=i,t.blockLen=n,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const kt=(o,t,e)=>new Le(o,t).update(e).digest();kt.create=(o,t)=>new Le(o,t);function js(o,t,e){return ie(o),kt(o,vt(e),vt(t))}const Vt=Uint8Array.from([0]),fe=Uint8Array.of();function Gs(o,t,e,s=32){ie(o),Yt(s);const r=o.outputLen;if(s>255*r)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(s/r);e===void 0&&(e=fe);const n=new Uint8Array(i*r),a=kt.create(o,t),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let h=0;h<i;h++)Vt[0]=h+1,c.update(h===0?fe:u).update(e).update(Vt).digestInto(u),n.set(u,r*h),a._cloneInto(c);return a.destroy(),c.destroy(),wt(u,Vt),n.slice(0,s)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Ys(o){return o instanceof Uint8Array||ArrayBuffer.isView(o)&&o.constructor.name==="Uint8Array"}function ye(o){if(typeof o!="boolean")throw new Error(`boolean expected, not ${o}`)}function jt(o){if(!Number.isSafeInteger(o)||o<0)throw new Error("positive integer expected, got "+o)}function _t(o,...t){if(!Ys(o))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(o.length))throw new Error("Uint8Array expected of length "+t+", got length="+o.length)}function ot(o){return new Uint32Array(o.buffer,o.byteOffset,Math.floor(o.byteLength/4))}function Js(...o){for(let t=0;t<o.length;t++)o[t].fill(0)}function Xs(o,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(o,t)}function Zs(o,t){if(o.length!==t.length)return!1;let e=0;for(let s=0;s<o.length;s++)e|=o[s]^t[s];return e===0}function pe(o){return Uint8Array.from(o)}const Fe=o=>Uint8Array.from(o.split("").map(t=>t.charCodeAt(0))),Qs=Fe("expand 16-byte k"),tr=Fe("expand 32-byte k"),er=ot(Qs),sr=ot(tr);function S(o,t){return o<<t|o>>>32-t}function Xt(o){return o.byteOffset%4===0}const Mt=64,rr=16,$e=2**32-1,me=new Uint32Array;function ir(o,t,e,s,r,i,n,a){const c=r.length,u=new Uint8Array(Mt),h=ot(u),d=Xt(r)&&Xt(i),f=d?ot(r):me,p=d?ot(i):me;for(let g=0;g<c;n++){if(o(t,e,s,h,n,a),n>=$e)throw new Error("arx: counter overflow");const y=Math.min(Mt,c-g);if(d&&y===Mt){const b=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let m=0,w;m<rr;m++)w=b+m,p[w]=f[w]^h[m];g+=Mt;continue}for(let b=0,m;b<y;b++)m=g+b,i[m]=r[m]^u[b];g+=y}}function nr(o,t){const{allowShortKeys:e,extendNonceFn:s,counterLength:r,counterRight:i,rounds:n}=Xs({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof o!="function")throw new Error("core must be a function");return jt(r),jt(n),ye(i),ye(e),(a,c,u,h,d=0)=>{_t(a),_t(c),_t(u);const f=u.length;if(h===void 0&&(h=new Uint8Array(f)),_t(h),jt(d),d<0||d>=$e)throw new Error("arx: counter overflow");if(h.length<f)throw new Error(`arx: output (${h.length}) is shorter than data (${f})`);const p=[];let g=a.length,y,b;if(g===32)p.push(y=pe(a)),b=sr;else if(g===16&&e)y=new Uint8Array(32),y.set(a),y.set(a,16),b=er,p.push(y);else throw new Error(`arx: invalid 32-byte key, got length=${g}`);Xt(c)||p.push(c=pe(c));const m=ot(y);if(s){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(b,m,ot(c.subarray(0,16)),m),c=c.subarray(16)}const w=16-r;if(w!==c.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const A=new Uint8Array(12);A.set(c,i?0:12-c.length),c=A,p.push(c)}const k=ot(c);return ir(o,b,m,k,u,h,d,n),Js(...p),h}}function or(o,t,e,s,r,i=20){let n=o[0],a=o[1],c=o[2],u=o[3],h=t[0],d=t[1],f=t[2],p=t[3],g=t[4],y=t[5],b=t[6],m=t[7],w=r,k=e[0],A=e[1],M=e[2],P=n,I=a,R=c,C=u,$=h,x=d,N=f,B=p,U=g,K=y,H=b,W=m,z=w,q=k,V=A,j=M;for(let de=0;de<i;de+=2)P=P+$|0,z=S(z^P,16),U=U+z|0,$=S($^U,12),P=P+$|0,z=S(z^P,8),U=U+z|0,$=S($^U,7),I=I+x|0,q=S(q^I,16),K=K+q|0,x=S(x^K,12),I=I+x|0,q=S(q^I,8),K=K+q|0,x=S(x^K,7),R=R+N|0,V=S(V^R,16),H=H+V|0,N=S(N^H,12),R=R+N|0,V=S(V^R,8),H=H+V|0,N=S(N^H,7),C=C+B|0,j=S(j^C,16),W=W+j|0,B=S(B^W,12),C=C+B|0,j=S(j^C,8),W=W+j|0,B=S(B^W,7),P=P+x|0,j=S(j^P,16),H=H+j|0,x=S(x^H,12),P=P+x|0,j=S(j^P,8),H=H+j|0,x=S(x^H,7),I=I+N|0,z=S(z^I,16),W=W+z|0,N=S(N^W,12),I=I+N|0,z=S(z^I,8),W=W+z|0,N=S(N^W,7),R=R+B|0,q=S(q^R,16),U=U+q|0,B=S(B^U,12),R=R+B|0,q=S(q^R,8),U=U+q|0,B=S(B^U,7),C=C+$|0,V=S(V^C,16),K=K+V|0,$=S($^K,12),C=C+$|0,V=S(V^C,8),K=K+V|0,$=S($^K,7);let L=0;s[L++]=n+P|0,s[L++]=a+I|0,s[L++]=c+R|0,s[L++]=u+C|0,s[L++]=h+$|0,s[L++]=d+x|0,s[L++]=f+N|0,s[L++]=p+B|0,s[L++]=g+U|0,s[L++]=y+K|0,s[L++]=b+H|0,s[L++]=m+W|0,s[L++]=w+z|0,s[L++]=k+q|0,s[L++]=A+V|0,s[L++]=M+j|0}const be=nr(or,{counterRight:!1,counterLength:4,allowShortKeys:!1}),ar={saltInfo:"nip44-v2"};class G extends Error{constructor(t,e,s){super(t),this.code=e,this.details=s,this.name="NIP44Error"}}var Y=(o=>(o.INVALID_KEY="INVALID_KEY",o.INVALID_NONCE="INVALID_NONCE",o.INVALID_PAYLOAD="INVALID_PAYLOAD",o.ENCRYPTION_FAILED="ENCRYPTION_FAILED",o.DECRYPTION_FAILED="DECRYPTION_FAILED",o.MAC_VERIFICATION_FAILED="MAC_VERIFICATION_FAILED",o.INVALID_PLAINTEXT_LENGTH="INVALID_PLAINTEXT_LENGTH",o.PADDING_ERROR="PADDING_ERROR",o))(Y||{});class X{static deriveConversationKey(t,e){try{const s=t.replace(/^0x/,"");let r=e.replace(/^0x/,"");if(r.length===66&&(r.startsWith("02")||r.startsWith("03"))&&(r=r.slice(2)),s.length!==64)throw new G("Invalid private key length",Y.INVALID_KEY);if(r.length!==64)throw new G("Invalid public key length - expected 32-byte x-coordinate",Y.INVALID_KEY);const i=new Uint8Array(32);for(let u=0;u<32;u++)i[u]=parseInt(s.substr(u*2,2),16);const a=Pe.getSharedSecret(i,"02"+r).subarray(1,33);return js(et,a,"nip44-v2")}catch(s){throw s instanceof G?s:new G(`Key derivation failed: ${s.message}`,Y.INVALID_KEY,s)}}static deriveMessageKeys(t,e){try{if(t.length!==32)throw new G("Invalid conversation key length",Y.INVALID_KEY);if(e.length!==this.NONCE_SIZE)throw new G("Invalid nonce length",Y.INVALID_NONCE);const s=Gs(et,t,e,76);return{chachaKey:s.subarray(0,32),chachaNonce:s.subarray(32,44),hmacKey:s.subarray(44,76)}}catch(s){throw new G(`Message key derivation failed: ${s.message}`,Y.ENCRYPTION_FAILED,s)}}static calculatePaddedContentLength(t){if(t<0||t>65536)throw new G("Invalid plaintext length",Y.INVALID_PLAINTEXT_LENGTH);if(t===0||t<=32)return 32;const e=1<<Math.floor(Math.log2(t-1))+1;let s;return e<=256?s=32:s=e/8,s*(Math.floor((t-1)/s)+1)}static calculatePaddedLength(t){return this.calculatePaddedContentLength(t)}static applyPadding(t){const e=t.length,s=this.calculatePaddedContentLength(e),r=new Uint8Array(s);return r.set(t,0),r}static formatForEncryption(t){const e=t.length,s=this.applyPadding(t),r=2+s.length,i=new Uint8Array(r);return new DataView(i.buffer).setUint16(0,e,!1),i.set(s,2),i}static applyNIP44Formatting(t){const e=t.length,s=this.applyPadding(t),r=2+s.length,i=new Uint8Array(r);return new DataView(i.buffer).setUint16(0,e,!1),i.set(s,2),i}static removePadding(t){if(t.length>=2){const r=new DataView(t.buffer).getUint16(0,!1);if(r<=t.length-2&&r>0)return t.subarray(2,2+r)}let e=t.length;for(;e>0&&t[e-1]===0;)e--;return t.subarray(0,e)}static generateNonce(){return ht(this.NONCE_SIZE)}static encrypt(t,e,s){try{if(t==null)throw new G("Plaintext cannot be null or undefined",Y.INVALID_PLAINTEXT_LENGTH);const r=new TextEncoder().encode(t),i=s||this.generateNonce(),n=this.deriveMessageKeys(e,i),a=this.formatForEncryption(r),c=be(n.chachaKey,n.chachaNonce,a),u=It(i,c),h=kt(et,n.hmacKey,u),d=new Uint8Array([this.VERSION]),f=It(d,i,c,h);return{payload:typeof Buffer<"u"?Buffer.from(f).toString("base64"):btoa(String.fromCharCode(...f)),nonce:i}}catch(r){throw r instanceof G?r:new G(`Encryption failed: ${r.message}`,Y.ENCRYPTION_FAILED,r)}}static decrypt(t,e){try{const s=typeof Buffer<"u"?new Uint8Array(Buffer.from(t,"base64")):(()=>{const m=atob(t),w=new Uint8Array(m.length);for(let k=0;k<m.length;k++)w[k]=m.charCodeAt(k);return w})(),r=this.VERSION_SIZE+this.NONCE_SIZE+this.MAC_SIZE;if(s.length<r)throw new G("Payload too short",Y.INVALID_PAYLOAD);let i=0;const n=s[i];if(i+=this.VERSION_SIZE,n!==this.VERSION)throw new G(`Unsupported version: ${n}`,Y.INVALID_PAYLOAD);const a=s.slice(i,i+this.NONCE_SIZE);i+=this.NONCE_SIZE;const c=s.slice(i,-this.MAC_SIZE),u=s.slice(-this.MAC_SIZE),h=this.deriveMessageKeys(e,a),d=It(a,c),f=kt(et,h.hmacKey,d);if(!Zs(f,u))return{plaintext:"",isValid:!1};const g=be(h.chachaKey,h.chachaNonce,c),y=this.removePadding(g);return{plaintext:new TextDecoder().decode(y),isValid:!0}}catch{return{plaintext:"",isValid:!1}}}static encryptWithNonce(t,e,s){return this.encrypt(t,e,s).payload}static validatePayload(t){try{const e=typeof Buffer<"u"?new Uint8Array(Buffer.from(t,"base64")):(()=>{const r=atob(t),i=new Uint8Array(r.length);for(let n=0;n<r.length;n++)i[n]=r.charCodeAt(n);return i})(),s=this.VERSION_SIZE+this.NONCE_SIZE+1;return!(e.length<s||e[0]!==this.VERSION)}catch{return!1}}}l(X,"VERSION",2),l(X,"SALT",new TextEncoder().encode(ar.saltInfo)),l(X,"NONCE_SIZE",32),l(X,"CHACHA_KEY_SIZE",32),l(X,"CHACHA_NONCE_SIZE",12),l(X,"HMAC_KEY_SIZE",32),l(X,"MAC_SIZE",32),l(X,"VERSION_SIZE",1);const Zt=Object.freeze(Object.defineProperty({__proto__:null,NIP44Crypto:X},Symbol.toStringTag,{value:"Module"}));class xt{static generateEphemeralKeyPair(){try{const t=ht(32),e=Array.from(t).map(n=>n.toString(16).padStart(2,"0")).join(""),r=dt.getPublicKey(e,!1).slice(1,33),i=Array.from(r).map(n=>n.toString(16).padStart(2,"0")).join("");return{privateKey:e,publicKey:i}}catch(t){throw new v(`Ephemeral key generation failed: ${t.message}`,E.EPHEMERAL_KEY_GENERATION_FAILED,t)}}static generateMultipleEphemeralKeyPairs(t){if(t<=0)throw new v("Key pair count must be greater than 0",E.EPHEMERAL_KEY_GENERATION_FAILED);const e=[];for(let s=0;s<t;s++)e.push(this.generateEphemeralKeyPair());return e}static validateEphemeralKeyPair(t){try{if(!/^[0-9a-f]{64}$/i.test(t.privateKey)||!/^[0-9a-f]{64}$/i.test(t.publicKey))return!1;const s=dt.getPublicKey(t.privateKey,!1).slice(1,33),r=Array.from(s).map(i=>i.toString(16).padStart(2,"0")).join("");return t.publicKey.toLowerCase()===r.toLowerCase()}catch{return!1}}static clearEphemeralKeyPair(t){try{const e=ht(32).reduce((s,r)=>s+r.toString(16).padStart(2,"0"),"");t.privateKey=e,t.publicKey=e}catch{}}static generateGiftWrapNonce(){return ht(32)}}class Qt{static generateRandomizedTimestamp(t=Q.MAX_TIMESTAMP_AGE_SECONDS){try{if(t<0)throw new v("Max age seconds cannot be negative",E.TIMESTAMP_RANDOMIZATION_FAILED);const e=Math.floor(Date.now()/1e3);if(t===0)return e;const s=this.generateSecureRandomOffset(t);return e-s}catch(e){throw e instanceof v?e:new v(`Timestamp randomization failed: ${e.message}`,E.TIMESTAMP_RANDOMIZATION_FAILED,e)}}static generateSecureRandomOffset(t){const e=ht(4),s=new DataView(e.buffer).getUint32(0,!1);return Math.floor(s/4294967295*t)}static generateMultipleRandomizedTimestamps(t,e=Q.MAX_TIMESTAMP_AGE_SECONDS){if(t<=0)throw new v("Timestamp count must be greater than 0",E.TIMESTAMP_RANDOMIZATION_FAILED);const s=[];for(let r=0;r<t;r++)s.push(this.generateRandomizedTimestamp(e));return s}static validateGiftWrapTimestamp(t,e=Q.MAX_TIMESTAMP_AGE_SECONDS){try{const s=Math.floor(Date.now()/1e3),r=s-e,i=s+60;return t>=r&&t<=i}catch{return!1}}static getRecommendedMaxAge(){return Q.MAX_TIMESTAMP_AGE_SECONDS}static calculateTimestampEntropy(t){return t<=0?0:Math.log2(t)}static generateTimestampInWindow(t,e){if(t>=e)throw new v("Window start must be before window end",E.TIMESTAMP_RANDOMIZATION_FAILED);const s=e-t,r=this.generateSecureRandomOffset(s);return t+r}}class Ft{static async createGiftWrap(t,e,s,r){try{this.validateSeal(t),this.validateRecipient(e);const i=s||xt.generateEphemeralKeyPair();if(!xt.validateEphemeralKeyPair(i))throw new v("Invalid ephemeral key pair",E.GIFT_WRAP_CREATION_FAILED);const n=r||Qt.generateRandomizedTimestamp(),a=JSON.stringify(t),c=X.deriveConversationKey(i.privateKey,e.pubkey),u=X.encrypt(a,c),h=e.relayHint?["p",e.pubkey,e.relayHint]:["p",e.pubkey],d={pubkey:i.publicKey,created_at:n,kind:Q.GIFT_WRAP_KIND,tags:[h],content:u.payload},f=this.calculateEventId(d),p=await this.signEvent(d,f,i.privateKey);return{giftWrap:{id:f,pubkey:i.publicKey,created_at:n,kind:Q.GIFT_WRAP_KIND,tags:[h],content:u.payload,sig:p},ephemeralKeyPair:i,recipient:e.pubkey}}catch(i){throw i instanceof v?i:new v(`Gift wrap creation failed: ${i.message}`,E.GIFT_WRAP_CREATION_FAILED,i)}}static async createMultipleGiftWraps(t,e){if(!e||e.length===0)throw new v("At least one recipient is required",E.NO_RECIPIENTS);const s=[],r=xt.generateMultipleEphemeralKeyPairs(e.length),i=Qt.generateMultipleRandomizedTimestamps(e.length);for(let n=0;n<e.length;n++){const a=await this.createGiftWrap(t,e[n],r[n],i[n]);s.push(a)}return s}static validateSeal(t){if(!t||typeof t!="object")throw new v("Seal must be a valid object",E.INVALID_SEAL);if(t.kind!==Q.SEAL_KIND)throw new v("Seal must have kind 13",E.INVALID_SEAL);if(!Array.isArray(t.tags)||t.tags.length!==0)throw new v("Seal must have empty tags array",E.INVALID_SEAL);if(typeof t.content!="string")throw new v("Seal must have valid content string",E.INVALID_SEAL)}static validateRecipient(t){if(!t||typeof t!="object")throw new v("Recipient must be a valid object",E.INVALID_RECIPIENT);if(typeof t.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(t.pubkey))throw new v("Recipient must have valid pubkey",E.INVALID_RECIPIENT);if(t.relayHint&&typeof t.relayHint!="string")throw new v("Recipient relay hint must be a string if provided",E.INVALID_RECIPIENT)}static isValidGiftWrap(t){return t&&typeof t=="object"&&t.kind===Q.GIFT_WRAP_KIND&&typeof t.pubkey=="string"&&typeof t.content=="string"&&Array.isArray(t.tags)&&t.tags.length>0&&Array.isArray(t.tags[0])&&t.tags[0][0]==="p"&&typeof t.tags[0][1]=="string"}static isValidSeal(t){return t&&typeof t=="object"&&t.kind===Q.SEAL_KIND&&typeof t.pubkey=="string"&&typeof t.content=="string"&&Array.isArray(t.tags)&&t.tags.length===0}static calculateEventId(t){const e=JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]),s=new TextEncoder().encode(e),r=et(s);return D(r)}static async signEvent(t,e,s){try{const r=await dt.schnorr.sign(e,s);return D(r)}catch(r){throw new v("Failed to sign gift wrap event",E.GIFT_WRAP_CREATION_FAILED,r)}}static getRecipientFromGiftWrap(t){try{return t.tags.length>0&&t.tags[0][0]==="p"?t.tags[0][1]:null}catch{return null}}static getRelayHintFromGiftWrap(t){try{return t.tags.length>0&&t.tags[0][0]==="p"&&t.tags[0].length>2?t.tags[0][2]:null}catch{return null}}}const cr=Object.freeze(Object.defineProperty({__proto__:null,GiftWrapCreator:Ft},Symbol.toStringTag,{value:"Module"}));class at{static async createGiftWrappedDM(t,e,s,r,i){try{this.validateCreateDMInputs(t,e,s);const n=this.createRumor(t,e,r),a=[];for(const u of s.recipients){const h=await Lt.createSealWithSigner(n,i,u.pubkey),d=s.maxTimestampAge===0?Math.floor(Date.now()/1e3):void 0,f=await Ft.createGiftWrap(h,{pubkey:u.pubkey,relayHint:u.relayHint||s.relayHint},void 0,d);a.push(f)}const c=await Lt.createSealWithSigner(n,i,s.recipients[0].pubkey);return{rumor:n,seal:c,giftWraps:a,senderPrivateKey:void 0}}catch(n){throw n instanceof v?n:new v(`Gift wrap protocol failed: ${n.message}`,E.GIFT_WRAP_CREATION_FAILED,n)}}static createRumor(t,e,s){const r=[];return s&&r.push(["subject",s]),{pubkey:e,created_at:Math.floor(Date.now()/1e3),kind:14,tags:r,content:t}}static async createBatchGiftWraps(t){const e=[];for(const s of t){const r=await this.createGiftWrappedDM(s.message,s.senderPrivateKey,s.config);e.push(r)}return e}static filterGiftWrapsForRecipient(t,e){return t.filter(s=>Ft.getRecipientFromGiftWrap(s)===e)}static async decryptMultipleGiftWraps(t,e){const s=[];for(const r of t){const i=await this.decryptGiftWrappedDM(r,e);i.isValid&&s.push(i)}return s}static validateCreateDMInputs(t,e,s){if(typeof t!="string")throw new v("Message must be a string",E.INVALID_RUMOR);if(typeof e!="string"||!/^[0-9a-f]{64}$/i.test(e))throw new v("Invalid sender private key format",E.SEAL_CREATION_FAILED);if(!s||!Array.isArray(s.recipients)||s.recipients.length===0)throw new v("At least one recipient is required",E.NO_RECIPIENTS);for(const r of s.recipients)if(!r||typeof r.pubkey!="string"||!/^[0-9a-f]{64}$/i.test(r.pubkey))throw new v("Invalid recipient public key format",E.INVALID_RECIPIENT)}static getPublicKeyFromPrivate(t){try{const e=new Uint8Array(t.match(/.{1,2}/g).map(n=>parseInt(n,16))),r=dt.getPublicKey(e,!1).slice(1,33);return Array.from(r).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(e){throw new v("Failed to derive public key from private key",E.SEAL_CREATION_FAILED,e)}}static createSimpleConfig(t,e){return{recipients:[{pubkey:t,relayHint:e}],relayHint:e}}static createMultiRecipientConfig(t,e){return{recipients:t.map(s=>({pubkey:s,relayHint:e})),relayHint:e}}static getProtocolStats(t){const e=t.length,s=t.reduce((c,u)=>c+u.giftWraps.length,0),r=Math.floor(Date.now()/1e3),i=t.flatMap(c=>c.giftWraps.map(u=>r-u.giftWrap.created_at)),n=i.length>0?i.reduce((c,u)=>c+u,0)/i.length:0,a=new Set(t.flatMap(c=>c.giftWraps.map(u=>u.recipient)));return{totalMessages:e,totalGiftWraps:s,averageTimestampAge:n,uniqueRecipients:a.size}}static async unwrapGiftWrap(t,e){try{if(!t||t.kind!==1059)return null;if(e&&e.startsWith("0x")&&(e=e.slice(2)),!/^[0-9a-f]{64}$/i.test(e))throw new v("Invalid recipient private key format",E.INVALID_PRIVATE_KEY);const{SealCreator:s}=await Promise.resolve().then(()=>Vs),{NIP44Crypto:r}=await Promise.resolve().then(()=>Zt),i=r.deriveConversationKey(e,t.pubkey),n=r.decrypt(t.content,i);if(!n||!n.isValid)return null;const a=JSON.parse(n.plaintext);if(!a||a.kind!==13)return null;const c=r.deriveConversationKey(e,a.pubkey),u=r.decrypt(a.content,c);if(!u||!u.isValid)return null;const h=JSON.parse(u.plaintext);return!h||typeof h.kind!="number"?null:h}catch(s){return console.error("Failed to unwrap gift wrapped DM:",s),null}}}const ur=Object.freeze(Object.defineProperty({__proto__:null,GiftWrapProtocol:at},Symbol.toStringTag,{value:"Module"}));class Oe{constructor(t){l(this,"_state");l(this,"subscription");l(this,"config");l(this,"messages");l(this,"status");l(this,"latest");l(this,"error");l(this,"subject");this.config=t,this._state=rt({messages:[],status:"connecting",latest:null,isTyping:!1,error:null,subject:t.subject}),this.messages=T(this._state,e=>e.messages),this.status=T(this._state,e=>e.status),this.latest=T(this._state,e=>e.latest),this.error=T(this._state,e=>e.error),this.subject=T(this._state,e=>e.subject),this.initializeSubscription()}wrapSigner(){var r,i;const t=this,e=(r=t.config)==null?void 0:r.relayManager,s=(e==null?void 0:e.signingProvider)||t.signer||((i=t.nostr)==null?void 0:i.signingProvider);return{nip44Encrypt:async(n,a)=>{if(!(s!=null&&s.nip44Encrypt))throw new Error("Signer missing nip44Encrypt");return s.nip44Encrypt(n,a)},signEvent:async n=>{if(!(s!=null&&s.signEvent))throw new Error("Signer missing signEvent");return s.signEvent(n)}}}async send(t,e){var s,r;try{this.config.debug&&console.log("📤 DMConversation.send called:",{content:t.substring(0,20)+"...",subject:e,recipientPubkey:this.config.recipientPubkey.substring(0,8)+"...",hasSenderPrivateKey:!!this.config.senderPrivateKey,senderPrivateKeyLength:(s=this.config.senderPrivateKey)==null?void 0:s.length}),this.updateStatus("active");const i=this.generateMessageId(),n=Math.floor(Date.now()/1e3),a={id:i,content:t,senderPubkey:this.config.senderPubkey,recipientPubkey:this.config.recipientPubkey,timestamp:n,isFromMe:!0,status:"sending",subject:e||this.getCurrentSubject()};this.addMessage(a);const c=at.createSimpleConfig(this.config.recipientPubkey,(r=this.config.relayHints)==null?void 0:r[0]);this.config.debug&&console.log("🎁 Creating gift wrap with config:",c);const u=await at.createGiftWrappedDM(t,this.config.senderPubkey,c,e,this.wrapSigner());this.config.debug&&console.log("🎁 Gift wrap result:",{hasRumor:!!u.rumor,hasSeal:!!u.seal,giftWrapCount:u.giftWraps.length});let h=!1,d;for(const f of u.giftWraps)try{this.config.debug&&console.log("📡 Publishing gift wrap:",{id:f.giftWrap.id,kind:f.giftWrap.kind,tags:f.giftWrap.tags});const p=await this.config.relayManager.publishToAll(f.giftWrap);this.config.debug&&console.log("📡 Publish result:",p),p.some(y=>y.success)&&(h=!0,a.eventId=f.giftWrap.id)}catch(p){d=p instanceof Error?p.message:"Publishing failed",this.config.debug&&console.error("❌ Publish error:",p)}if(h)return this.updateMessageStatus(i,"sent"),this.config.debug&&console.log(`✅ DM sent successfully: ${i}`),{success:!0,messageId:i};{this.updateMessageStatus(i,"failed");const f=d||"Failed to publish to any relay";return this.setError(f),this.config.debug&&console.error(`❌ DM send failed: ${f}`),{success:!1,error:f,messageId:i}}}catch(i){const n=i instanceof Error?i.message:"Unknown error sending message";return this.setError(n),this.config.debug&&console.error("❌ Exception in send:",i),{success:!1,error:n}}}updateSubject(t){this._state.update(e=>({...e,subject:t}))}clearHistory(){this._state.update(t=>({...t,messages:[],latest:null}))}async close(){var t,e;(e=(t=this.subscription)==null?void 0:t.subscription)!=null&&e.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.updateStatus("disconnected")}async retry(){var t,e;(e=(t=this.subscription)==null?void 0:t.subscription)!=null&&e.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.setError(null),await this.initializeSubscription()}async handleDecryptedEvent(t){this.config.debug&&console.log("📨 Processing decrypted event in conversation:",t.id),await this.handleIncomingEvent(t)}async initializeSubscription(){var t;try{this.updateStatus("connecting");const e={kinds:[1059],"#p":[this.config.senderPubkey],limit:100},s={onEvent:r=>this.handleIncomingEvent(r),onEose:()=>{this.updateStatus("active"),this.config.debug&&console.log(`DM conversation subscription active for ${this.config.recipientPubkey}`)},onClose:r=>{this.updateStatus("disconnected"),r&&this.setError(`Subscription closed: ${r}`)}};if(this.subscription=await this.config.subscriptionManager.subscribe([e],s),!this.subscription.success){const r=((t=this.subscription.error)==null?void 0:t.message)||"Failed to create subscription";this.setError(r),this.updateStatus("error")}}catch(e){const s=e instanceof Error?e.message:"Failed to initialize subscription";this.setError(s),this.updateStatus("error")}}async handleIncomingEvent(t){try{if(t.kind!==1059)return;const e=await at.decryptGiftWrappedDM(t,this.config.senderPrivateKey);if(!e.isValid||!e.rumor){this.config.debug&&console.log("Failed to decrypt gift wrap or not for us");return}if(e.senderPubkey!==this.config.recipientPubkey){this.config.debug&&console.log("Message not from conversation partner");return}const s={id:this.generateMessageId(),content:e.rumor.content,senderPubkey:e.senderPubkey,recipientPubkey:this.config.senderPubkey,timestamp:e.rumor.created_at,isFromMe:!1,eventId:t.id,status:"received",subject:this.extractSubjectFromRumor(e.rumor)};this.getCurrentMessages().some(n=>n.eventId===t.id||n.content===s.content&&Math.abs(n.timestamp-s.timestamp)<5)||(this.addMessage(s),this.config.debug&&console.log(`Received DM from ${e.senderPubkey}: ${s.content}`))}catch(e){this.config.debug&&console.error("Error handling incoming DM event:",e)}}addMessage(t){this._state.update(e=>{const s=[...e.messages,t];return s.sort((r,i)=>r.timestamp-i.timestamp),{...e,messages:s,latest:s[s.length-1]||null}})}updateMessageStatus(t,e){this._state.update(s=>({...s,messages:s.messages.map(r=>r.id===t?{...r,status:e}:r)}))}updateStatus(t){this._state.update(e=>({...e,status:t}))}setError(t){this._state.update(e=>({...e,error:t}))}getCurrentSubject(){let t;return this.subject.subscribe(s=>{t=s})(),t}extractSubjectFromRumor(t){var s;const e=(s=t.tags)==null?void 0:s.find(r=>r[0]==="subject");return e==null?void 0:e[1]}getCurrentMessages(){let t=[];return this.messages.subscribe(s=>{t=s})(),t}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}subscribe(t){return this.messages.subscribe(t)}}class Be{constructor(t){l(this,"_state");l(this,"subscription");l(this,"config");l(this,"roomId");l(this,"messages");l(this,"status");l(this,"latest");l(this,"subject");l(this,"participants");l(this,"error");var e;this.config=t,this.roomId=this.generateRoomId(),this._state=rt({messages:[],status:"connecting",latest:null,subject:((e=t.options)==null?void 0:e.subject)||"Group Chat",participants:[...t.participants,t.senderPubkey],isTyping:!1,error:null}),this.messages=T(this._state,s=>s.messages),this.status=T(this._state,s=>s.status),this.latest=T(this._state,s=>s.latest),this.subject=T(this._state,s=>s.subject),this.participants=T(this._state,s=>s.participants),this.error=T(this._state,s=>s.error),this.initializeSubscription()}async send(t){var e,s;try{this.updateStatus("active");const r=this.generateMessageId(),i=Math.floor(Date.now()/1e3),n=this.getCurrentSubject(),a=this.getCurrentParticipants(),c={id:r,content:t,senderPubkey:this.config.senderPubkey,recipientPubkey:"",timestamp:i,isFromMe:!0,status:"sending",subject:n,participants:a};this.addMessage(c);const h={recipients:a.filter(g=>g!==this.config.senderPubkey).map(g=>({pubkey:g})),relayHint:(s=(e=this.config.options)==null?void 0:e.relayHints)==null?void 0:s[0]},d=await at.createGiftWrappedDM(t,this.config.senderPrivateKey,h);let f=!1,p;for(const g of d.giftWraps)try{(await this.config.relayManager.publishToAll(g.giftWrap)).some(m=>m.success)&&(f=!0,c.eventId=g.giftWrap.id)}catch(y){p=y instanceof Error?y.message:"Publishing failed"}if(f)return this.updateMessageStatus(r,"sent"),this.config.debug&&console.log(`Room message sent successfully: ${r}`),{success:!0,messageId:r};{this.updateMessageStatus(r,"failed");const g=p||"Failed to publish to any relay";return this.setError(g),{success:!1,error:g,messageId:r}}}catch(r){const i=r instanceof Error?r.message:"Unknown error sending message";return this.setError(i),{success:!1,error:i}}}async updateSubject(t){try{return this._state.update(e=>({...e,subject:t})),{success:!0}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Failed to update subject"}}}async addParticipant(t){try{return this.getCurrentParticipants().includes(t)?{success:!1,error:"Participant already in room"}:(this._state.update(s=>({...s,participants:[...s.participants,t]})),{success:!0})}catch(e){return{success:!1,error:e instanceof Error?e.message:"Failed to add participant"}}}async removeParticipant(t){try{return this.getCurrentParticipants().includes(t)?t===this.config.senderPubkey?{success:!1,error:"Cannot remove yourself from room"}:(this._state.update(s=>({...s,participants:s.participants.filter(r=>r!==t)})),{success:!0}):{success:!1,error:"Participant not in room"}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Failed to remove participant"}}}clearHistory(){this._state.update(t=>({...t,messages:[],latest:null}))}async close(){var t,e;(e=(t=this.subscription)==null?void 0:t.subscription)!=null&&e.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.updateStatus("disconnected")}async retry(){var t,e;(e=(t=this.subscription)==null?void 0:t.subscription)!=null&&e.id&&await this.config.subscriptionManager.close(this.subscription.subscription.id),this.setError(null),await this.initializeSubscription()}async initializeSubscription(){var t;try{this.updateStatus("connecting");const e={kinds:[1059],"#p":[this.config.senderPubkey],limit:100},s={onEvent:r=>this.handleIncomingEvent(r),onEose:()=>{this.updateStatus("active"),this.config.debug&&console.log(`Room subscription active: ${this.roomId}`)},onClose:r=>{this.updateStatus("disconnected"),r&&this.setError(`Subscription closed: ${r}`)}};if(this.subscription=await this.config.subscriptionManager.subscribe([e],s),!this.subscription.success){const r=((t=this.subscription.error)==null?void 0:t.message)||"Failed to create subscription";this.setError(r),this.updateStatus("error")}}catch(e){const s=e instanceof Error?e.message:"Failed to initialize subscription";this.setError(s),this.updateStatus("error")}}async handleIncomingEvent(t){try{if(t.kind!==1059)return;const e=await at.decryptGiftWrappedDM(t,this.config.senderPrivateKey);if(!e.isValid||!e.rumor){this.config.debug&&console.log("Failed to decrypt gift wrap or not for us");return}const s=this.getCurrentParticipants();if(!s.includes(e.senderPubkey)){this.config.debug&&console.log("Message not from room participant");return}const r=this.extractSubjectFromRumor(e.rumor),i=this.getCurrentSubject(),n={id:this.generateMessageId(),content:e.rumor.content,senderPubkey:e.senderPubkey,recipientPubkey:"",timestamp:e.rumor.created_at,isFromMe:!1,eventId:t.id,status:"received",subject:r||i,participants:s};this.getCurrentMessages().some(u=>u.eventId===t.id||u.content===n.content&&Math.abs(u.timestamp-n.timestamp)<5)||(this.addMessage(n),this.config.debug&&console.log(`Received room message from ${e.senderPubkey}: ${n.content}`))}catch(e){this.config.debug&&console.error("Error handling incoming room event:",e)}}addMessage(t){this._state.update(e=>{const s=[...e.messages,t];return s.sort((r,i)=>r.timestamp-i.timestamp),{...e,messages:s,latest:s[s.length-1]||null}})}updateMessageStatus(t,e){this._state.update(s=>({...s,messages:s.messages.map(r=>r.id===t?{...r,status:e}:r)}))}updateStatus(t){this._state.update(e=>({...e,status:t}))}setError(t){this._state.update(e=>({...e,error:t}))}getCurrentSubject(){let t="";return this.subject.subscribe(s=>{t=s})(),t}getCurrentParticipants(){let t=[];return this.participants.subscribe(s=>{t=s})(),t}getCurrentMessages(){let t=[];return this.messages.subscribe(s=>{t=s})(),t}extractSubjectFromRumor(t){var s;const e=(s=t.tags)==null?void 0:s.find(r=>r[0]==="subject");return e==null?void 0:e[1]}generateRoomId(){const e=[...this.config.participants,this.config.senderPubkey].sort().join(",");return`room_${Date.now()}_${e.slice(0,16)}`}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}subscribe(t){return this.messages.subscribe(t)}}class Ue{constructor(t){l(this,"conversations",new Map);l(this,"rooms",new Map);l(this,"config");l(this,"_senderPubkey",null);l(this,"_senderPrivateKey",null);l(this,"parentNostr");l(this,"_conversationList",rt([]));l(this,"conversations$");this.config=t,this.parentNostr=t.parent,this.conversations$=this._conversationList,this.config.signingProvider&&this.initializeSender()}with(t){return this.shouldUseUniversalDM()?this.delegateToUniversalDM(t):this.withLegacy(t)}async withLegacy(t){const e=this.normalizePubkey(t);let s=this.conversations.get(e);return s||(s=await this.createConversation(e),this.conversations.set(e,s),this.updateConversationList(),this.config.debug&&console.log(`Created new DM conversation with ${e}`)),s}async room(t,e){if(this.shouldUseUniversalDM()){const s=this.getUniversalDMInstance();if(s&&typeof s.room=="function")return s.room(t,e)}return this.roomLegacy(t,e)}async roomLegacy(t,e){const s=t.map(n=>this.normalizePubkey(n)),r=this.generateRoomId(s);let i=this.rooms.get(r);return i||(i=await this.createRoom(s,e),this.rooms.set(r,i),this.updateConversationList(),this.config.debug&&console.log(`Created new DM room: ${r} with ${s.length} participants`)),i}getConversations(){if(this.shouldUseUniversalDM()){const s=this.getUniversalDMInstance();if(s&&typeof s.summaries=="function")return s.summaries().map(i=>({pubkey:i.pubkey,latestMessage:null,lastActivity:0,isActive:!0,subject:i.subject,participants:i.participants,type:i.type}))}let t=[];return this.conversations$.subscribe(s=>{t=s})(),t}async closeConversation(t){const e=this.normalizePubkey(t),s=this.conversations.get(e);s&&(await s.close(),this.conversations.delete(e),this.updateConversationList(),this.config.debug&&console.log(`Closed DM conversation with ${e}`))}async closeRoom(t){const e=this.rooms.get(t);e&&(await e.close(),this.rooms.delete(t),this.updateConversationList(),this.config.debug&&console.log(`Closed DM room: ${t}`))}async closeAll(){const t=Array.from(this.conversations.values()).map(s=>s.close()),e=Array.from(this.rooms.values()).map(s=>s.close());await Promise.all([...t,...e]),this.conversations.clear(),this.rooms.clear(),this.updateConversationList(),this.config.debug&&console.log("Closed all DM conversations and rooms")}async updateSigningProvider(t){this.config.signingProvider=t;try{await this.initializeSender()}catch(e){this.config.debug&&console.error("Failed to update signing provider:",e)}}async startInboxSubscription(){if(!this._senderPubkey)throw new Error("Sender public key not available. Ensure signing provider is initialized.");try{const t={kinds:[1059],"#p":[this._senderPubkey],limit:50};await this.config.subscriptionManager.subscribe([t],{onEvent:e=>this.handleGlobalInboxEvent(e),onEose:()=>{this.config.debug&&console.log("Global DM inbox subscription active")}})}catch(t){throw this.config.debug&&console.error("Failed to start global inbox subscription:",t),t}}async initializeSender(){try{if(!this.config.signingProvider){this.config.debug&&console.log("DM module: No signing provider available yet");return}this._senderPubkey=await this.config.signingProvider.getPublicKey(),this.config.debug&&console.log(`DM module initialized for pubkey: ${this._senderPubkey}`)}catch(t){this.config.debug&&console.error("Failed to initialize sender credentials:",t)}}async createConversation(t){if(!this._senderPubkey)throw new Error("Sender public key not available. Call nostr.publish() or another method first to initialize signing.");const e=await this.getPrivateKeySecurely(),s={recipientPubkey:t,senderPrivateKey:e,senderPubkey:this._senderPubkey,subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,debug:this.config.debug},r=new Oe(s);return this.setupConversationReactivity(r),r}async createRoom(t,e){if(!this._senderPubkey)throw new Error("Sender public key not available. Call nostr.publish() or another method first to initialize signing.");const s=await this.getPrivateKeySecurely(),r={participants:t,senderPrivateKey:s,senderPubkey:this._senderPubkey,subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,options:e,debug:this.config.debug},i=new Be(r);return this.setupRoomReactivity(i),i}setupConversationReactivity(t){t.latest.subscribe(()=>{this.updateConversationList()}),t.subject.subscribe(()=>{this.updateConversationList()})}setupRoomReactivity(t){t.latest.subscribe(()=>{this.updateConversationList()}),t.subject.subscribe(()=>{this.updateConversationList()}),t.participants.subscribe(()=>{this.updateConversationList()})}updateConversationList(){const t=[];this.conversations.forEach((e,s)=>{let r=null,i="disconnected",n;const a=e.latest.subscribe(h=>{r=h}),c=e.status.subscribe(h=>{i=h}),u=e.subject.subscribe(h=>{n=h});a(),c(),u(),t.push({pubkey:s,latestMessage:r,lastActivity:(r==null?void 0:r.timestamp)||0,isActive:i==="active"||i==="connecting",subject:n,type:"conversation"})}),this.rooms.forEach((e,s)=>{let r=null,i="disconnected",n="",a=[];const c=e.latest.subscribe(f=>{r=f}),u=e.status.subscribe(f=>{i=f}),h=e.subject.subscribe(f=>{n=f}),d=e.participants.subscribe(f=>{a=f});c(),u(),h(),d(),t.push({pubkey:s,latestMessage:r,lastActivity:(r==null?void 0:r.timestamp)||0,isActive:i==="active"||i==="connecting",subject:n,participants:a,type:"room"})}),t.sort((e,s)=>s.lastActivity-e.lastActivity),this._conversationList.set(t)}async handleGlobalInboxEvent(t){this.config.debug&&console.log("🎁 Processing gift wrap event:",t.id);try{const{GiftWrapProtocol:e}=await Promise.resolve().then(()=>ur),s=await this.getPrivateKeySecurely(),r=await e.unwrapGiftWrap(t,s);if(r){const i=r.pubkey;if(this.config.debug&&console.log("✅ Decrypted event (kind "+r.kind+") from:",i.substring(0,8)+"..."),r.kind===4||r.kind===14){let n=this.conversations.get(i);n||(this.config.debug&&console.log("🆕 Auto-creating conversation with:",i.substring(0,8)+"..."),n=await this.with(i)),n&&typeof n.handleDecryptedEvent=="function"&&n.handleDecryptedEvent(r),this.updateConversationList(),this.config.debug&&console.log("🔄 Updated conversations, total:",this.conversations.size)}else this.config.debug&&console.log("🔮 Received encrypted event kind "+r.kind+" - not a DM, caching for future use")}}catch(e){this.config.debug&&console.error("❌ Failed to process gift wrap event:",e)}}normalizePubkey(t){if(t.startsWith("npub"))throw new Error("npub format not yet supported, please use hex pubkey");if(!/^[0-9a-f]{64}$/i.test(t))throw new Error("Invalid pubkey format. Expected 64-character hex string");return t.toLowerCase()}async getPrivateKeySecurely(){throw new Error("Raw private key access removed. Use SigningProvider.nip44Encrypt/Decrypt.")}generateRoomId(t){return[...t,this._senderPubkey].sort().join(",")}shouldUseUniversalDM(){return!!this.getUniversalDMInstance()}getUniversalDMInstance(){var t;return(t=this.parentNostr)==null?void 0:t.universalDM}delegateToUniversalDM(t){var r;const e=this.getUniversalDMInstance();if(!e)throw new Error("Universal DM Module not available");this.config.debug&&console.log("🎯 Delegating to Universal DM Module (cache-based) for:",t.substring(0,16)+"...");const s=e.with(t);return this.config.debug&&console.log("🔍 Result from universalDM.with():",{result:!!s,hasMessages:!!(s!=null&&s.messages),hasSubscribe:typeof(s==null?void 0:s.subscribe),hasSend:typeof(s==null?void 0:s.send),constructor:(r=s==null?void 0:s.constructor)==null?void 0:r.name}),s}}class we{constructor(t,e,s){l(this,"store");l(this,"myPubkey");l(this,"otherPubkey");l(this,"nostr");l(this,"_status","connecting");l(this,"statusCallbacks",[]);l(this,"messageCache",[]);var r,i;this.nostr=t,this.myPubkey=(e||"").toLowerCase(),this.otherPubkey=(s||"").toLowerCase(),console.log("🚀 UniversalDMConversation constructor:",{myPubkey:e.substring(0,16)+"...",otherPubkey:s.substring(0,16)+"...",hasQueryMethod:typeof this.nostr.query=="function"});try{this.nostr.startUniversalGiftWrapSubscription().catch(()=>{}),this.store=this.nostr.query().kinds([14]).authors([this.myPubkey,this.otherPubkey]).tags("p",[this.myPubkey,this.otherPubkey]).execute(),console.log("✅ Store created successfully:",typeof this.store,(i=(r=this.store)==null?void 0:r.constructor)==null?void 0:i.name),setTimeout(()=>{console.log("🔍 Cache state after store init:",{currentEvents:this.store.current.length,eventKinds:this.store.current.map(n=>n.kind),eventIds:this.store.current.map(n=>{var a;return((a=n.id)==null?void 0:a.slice(0,8))+"..."})})},1e3)}catch(n){console.error("❌ Failed to create store:",n),this.store={subscribe:()=>()=>{},current:[]}}this.subscribe(()=>{}),setTimeout(()=>{this._status="active",this.notifyStatusChange()},100)}get messages(){return console.log("📧 messages getter called, store exists?",!!this.store),this.store?(console.log("✅ Returning",this.messageCache.length,"cached messages"),this.messageCache):(console.error("❌ No store in messages getter"),[])}subscribe(t){return t(this.messageCache),this.store.subscribe(async e=>{const s=await this.convertEventsToMessages(e),i=[...this.messageCache,...s].filter((n,a,c)=>c.findIndex(u=>u.eventId===n.eventId||u.content===n.content&&Math.abs(u.timestamp-n.timestamp)<5)===a);i.sort((n,a)=>n.timestamp-a.timestamp),this.messageCache=i,t(i)})}async send(t,e){var s;if(!t||t.trim().length===0)return{success:!1,error:"Message content cannot be empty"};if(!this.isValidPubkey(this.otherPubkey))return{success:!1,error:"Invalid recipient pubkey format"};try{const r=this.nostr.signingProvider,i=await(((s=r==null?void 0:r.capabilities)==null?void 0:s.call(r))??{nip44Encrypt:!1,nip44Decrypt:!1}),n={pubkey:this.myPubkey,created_at:Math.floor(Date.now()/1e3),kind:14,tags:e?[["subject",e]]:[],content:t};if(i.nip44Encrypt&&typeof r.nip44Encrypt=="function"){const a=async g=>{const y=await r.nip44Encrypt(g,JSON.stringify(n)),b={pubkey:this.myPubkey,created_at:Math.floor(Date.now()/1e3),kind:13,tags:[],content:y},m=_.calculateEventId(b),w=await r.signEvent(b);return{...b,id:m,sig:w}},[c,u]=await Promise.all([a(this.otherPubkey),a(this.myPubkey)]),{GiftWrapCreator:h}=await Promise.resolve().then(()=>cr),[d,f]=await Promise.all([h.createGiftWrap(c,{pubkey:this.otherPubkey},void 0,Math.floor(Date.now()/1e3)),h.createGiftWrap(u,{pubkey:this.myPubkey},void 0,Math.floor(Date.now()/1e3))]),[p]=await Promise.all([this.nostr.publishSigned(d.giftWrap),this.nostr.publishSigned(f.giftWrap).catch(()=>({success:!1}))]);if(p.success){const g=d.giftWrap,y={id:g.id,content:t,senderPubkey:this.myPubkey,recipientPubkey:this.otherPubkey,timestamp:g.created_at,isFromMe:!0,eventId:g.id,status:"sent",subject:e,sender:this.myPubkey};return this.messageCache.push(y),this.messageCache.sort((b,m)=>b.timestamp-m.timestamp),{success:!0,messageId:g.id}}return{success:!1,error:"Failed to publish to recipient"}}else return{success:!1,error:"Signer does not support NIP-44 encryption"}}catch(r){return{success:!1,error:r instanceof Error?r.message:"Unknown error"}}}async convertEventsToMessages(t){const e=[];for(const s of t){if(s.kind!==14)continue;const r=s.pubkey===this.myPubkey,i=s.tags.some(a=>a[0]==="p"&&a[1]===this.otherPubkey);(s.tags.some(a=>a[0]==="p"&&a[1]===this.myPubkey)||r&&i)&&e.push({id:s.id,content:s.content,senderPubkey:s.pubkey,recipientPubkey:r?this.otherPubkey:this.myPubkey,timestamp:s.created_at,isFromMe:r,eventId:s.id,status:r?"sent":"received",subject:this.getSubjectFromEvent(s),sender:s.pubkey})}return e.sort((s,r)=>s.timestamp-r.timestamp)}getRecipientFromEvent(t){const e=t.tags.find(s=>s[0]==="p");return(e==null?void 0:e[1])||""}getSubjectFromEvent(t){const e=t.tags.find(s=>s[0]==="subject");return e==null?void 0:e[1]}getSubjectFromRumor(t){var s;const e=(s=t.tags)==null?void 0:s.find(r=>r[0]==="subject");return e==null?void 0:e[1]}get status(){const t=this;return{subscribe:e=>(e(t._status),t.statusCallbacks.push(e),()=>{const s=t.statusCallbacks.indexOf(e);s>-1&&t.statusCallbacks.splice(s,1)}),get current(){return t._status}}}get latest(){const t=this;return{subscribe:e=>t.messages.subscribe(s=>{e(s[s.length-1])}),get current(){return t.messageCache[t.messageCache.length-1]}}}get subject(){const t=this;return{subscribe:e=>t.store.subscribe(s=>{const r=s.filter(i=>i.tags.some(n=>n[0]==="subject")).sort((i,n)=>n.created_at-i.created_at)[0];e(r?t.getSubjectFromEvent(r):void 0)}),get current(){const s=t.store.current.filter(r=>r.tags.some(i=>i[0]==="subject")).sort((r,i)=>i.created_at-r.created_at)[0];return s?t.getSubjectFromEvent(s):void 0}}}async close(){this._status="disconnected",this.notifyStatusChange()}notifyStatusChange(){this.statusCallbacks.forEach(t=>t(this._status))}isValidPubkey(t){return typeof t=="string"&&t.length===64&&/^[0-9a-f]{64}$/i.test(t)}}/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ke(o){return o instanceof Uint8Array||ArrayBuffer.isView(o)&&o.constructor.name==="Uint8Array"}function He(o,t){return Array.isArray(t)?t.length===0?!0:o?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function lr(o){if(typeof o!="function")throw new Error("function expected");return!0}function At(o,t){if(typeof t!="string")throw new Error(`${o}: string expected`);return!0}function We(o){if(!Number.isSafeInteger(o))throw new Error(`invalid integer: ${o}`)}function te(o){if(!Array.isArray(o))throw new Error("array expected")}function ze(o,t){if(!He(!0,t))throw new Error(`${o}: array of strings expected`)}function qe(o,t){if(!He(!1,t))throw new Error(`${o}: array of numbers expected`)}function hr(...o){const t=i=>i,e=(i,n)=>a=>i(n(a)),s=o.map(i=>i.encode).reduceRight(e,t),r=o.map(i=>i.decode).reduce(e,t);return{encode:s,decode:r}}function dr(o){const t=typeof o=="string"?o.split(""):o,e=t.length;ze("alphabet",t);const s=new Map(t.map((r,i)=>[r,i]));return{encode:r=>(te(r),r.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${o}`);return t[i]})),decode:r=>(te(r),r.map(i=>{At("alphabet.decode",i);const n=s.get(i);if(n===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${o}`);return n}))}}function gr(o=""){return At("join",o),{encode:t=>(ze("join.decode",t),t.join(o)),decode:t=>(At("join.decode",t),t.split(o))}}const Ve=(o,t)=>t===0?o:Ve(t,o%t),$t=(o,t)=>o+(t-Ve(o,t)),Nt=(()=>{let o=[];for(let t=0;t<40;t++)o.push(2**t);return o})();function ee(o,t,e,s){if(te(o),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(e<=0||e>32)throw new Error(`convertRadix2: wrong to=${e}`);if($t(t,e)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${e} carryBits=${$t(t,e)}`);let r=0,i=0;const n=Nt[t],a=Nt[e]-1,c=[];for(const u of o){if(We(u),u>=n)throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);if(r=r<<t|u,i+t>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${t}`);for(i+=t;i>=e;i-=e)c.push((r>>i-e&a)>>>0);const h=Nt[i];if(h===void 0)throw new Error("invalid carry");r&=h-1}if(r=r<<e-i&a,!s&&i>=t)throw new Error("Excess padding");if(!s&&r>0)throw new Error(`Non-zero padding: ${r}`);return s&&i>0&&c.push(r>>>0),c}function fr(o,t=!1){if(We(o),o<=0||o>32)throw new Error("radix2: bits should be in (0..32]");if($t(8,o)>32||$t(o,8)>32)throw new Error("radix2: carry overflow");return{encode:e=>{if(!Ke(e))throw new Error("radix2.encode input should be Uint8Array");return ee(Array.from(e),8,o,!t)},decode:e=>(qe("radix2.decode",e),Uint8Array.from(ee(e,o,8,t)))}}function ve(o){return lr(o),function(...t){try{return o.apply(null,t)}catch{}}}const se=hr(dr("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),gr("")),Ee=[996825010,642813549,513874426,1027748829,705979059];function mt(o){const t=o>>25;let e=(o&33554431)<<5;for(let s=0;s<Ee.length;s++)(t>>s&1)===1&&(e^=Ee[s]);return e}function Se(o,t,e=1){const s=o.length;let r=1;for(let i=0;i<s;i++){const n=o.charCodeAt(i);if(n<33||n>126)throw new Error(`Invalid prefix (${o})`);r=mt(r)^n>>5}r=mt(r);for(let i=0;i<s;i++)r=mt(r)^o.charCodeAt(i)&31;for(let i of t)r=mt(r)^i;for(let i=0;i<6;i++)r=mt(r);return r^=e,se.encode(ee([r%Nt[30]],30,5,!1))}function yr(o){const t=o==="bech32"?1:734539939,e=fr(5),s=e.decode,r=e.encode,i=ve(s);function n(d,f,p=90){At("bech32.encode prefix",d),Ke(f)&&(f=Array.from(f)),qe("bech32.encode",f);const g=d.length;if(g===0)throw new TypeError(`Invalid prefix length ${g}`);const y=g+7+f.length;if(p!==!1&&y>p)throw new TypeError(`Length ${y} exceeds limit ${p}`);const b=d.toLowerCase(),m=Se(b,f,t);return`${b}1${se.encode(f)}${m}`}function a(d,f=90){At("bech32.decode input",d);const p=d.length;if(p<8||f!==!1&&p>f)throw new TypeError(`invalid string length: ${p} (${d}). Expected (8..${f})`);const g=d.toLowerCase();if(d!==g&&d!==d.toUpperCase())throw new Error("String must be lowercase or uppercase");const y=g.lastIndexOf("1");if(y===0||y===-1)throw new Error('Letter "1" must be present between prefix and data only');const b=g.slice(0,y),m=g.slice(y+1);if(m.length<6)throw new Error("Data must be at least 6 characters long");const w=se.decode(m).slice(0,-6),k=Se(b,w,t);if(!m.endsWith(k))throw new Error(`Invalid checksum in ${d}: expected "${k}"`);return{prefix:b,words:w}}const c=ve(a);function u(d){const{prefix:f,words:p}=a(d,!1);return{prefix:f,words:p,bytes:s(p)}}function h(d,f){return n(d,r(f))}return{encode:n,decode:a,encodeFromBytes:h,decodeToBytes:u,decodeUnsafe:c,fromWords:s,fromWordsUnsafe:i,toWords:r}}const Ot=yr("bech32"),je=5e3,Bt=new TextEncoder,Pt=new TextDecoder;function pr(o){const t=new Uint8Array(4);return t[0]=o>>24&255,t[1]=o>>16&255,t[2]=o>>8&255,t[3]=o&255,t}function Gt(o){const t={};let e=o;for(;e.length>0&&!(e.length<2);){const s=e[0],r=e[1];if(e.length<2+r)break;const i=e.slice(2,2+r);e=e.slice(2+r),t[s]=t[s]||[],t[s].push(i)}return t}function ne(o){const t=[];return Object.entries(o).reverse().forEach(([e,s])=>{s.forEach(r=>{const i=new Uint8Array(r.length+2);i.set([parseInt(e)],0),i.set([r.length],1),i.set(r,2),t.push(i)})}),It(...t)}function Ht(o,t){const e=Ot.toWords(t);return Ot.encode(o,e,je)}function oe(o,t){return Ht(o,t)}function yt(o){var r,i,n,a,c,u,h;if(o.toLowerCase().startsWith("nostr:")){const f=o.slice(6).split("?")[0];return yt(f)}const{prefix:t,words:e}=Ot.decode(o,je),s=new Uint8Array(Ot.fromWords(e));switch(t){case"nprofile":{const d=Gt(s);if(!((r=d[0])!=null&&r[0]))throw new Error("missing TLV 0 for nprofile");if(d[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:D(d[0][0]),relays:d[1]?d[1].map(f=>Pt.decode(f)):[]}}}case"nevent":{const d=Gt(s);if(!((i=d[0])!=null&&i[0]))throw new Error("missing TLV 0 for nevent");if(d[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(d[2]&&d[2][0]&&d[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(d[3]&&d[3][0]&&d[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:D(d[0][0]),relays:d[1]?d[1].map(f=>Pt.decode(f)):[],author:(n=d[2])!=null&&n[0]?D(d[2][0]):void 0,kind:(a=d[3])!=null&&a[0]?parseInt(D(d[3][0]),16):void 0}}}case"naddr":{const d=Gt(s);if(!((c=d[0])!=null&&c[0]))throw new Error("missing TLV 0 for naddr");if(!((u=d[2])!=null&&u[0]))throw new Error("missing TLV 2 for naddr");if(d[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((h=d[3])!=null&&h[0]))throw new Error("missing TLV 3 for naddr");if(d[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:Pt.decode(d[0][0]),pubkey:D(d[2][0]),kind:parseInt(D(d[3][0]),16),relays:d[1]?d[1].map(f=>Pt.decode(f)):[]}}}case"nsec":return{type:t,data:s};case"npub":case"note":return{type:t,data:D(s)};default:throw new Error(`Unknown prefix ${t}`)}}function Ge(o){return typeof o=="string"&&o.toLowerCase().startsWith("nostr:")}function mr(o){if(!Ge(o))throw new Error("Invalid Nostr URI: must start with nostr:");const t=o.slice(6),[e,s=""]=t.split("?"),r=yt(e),i={};if(s.length>0)for(const n of s.split("&")){if(!n)continue;const a=n.indexOf("="),c=decodeURIComponent(a>=0?n.slice(0,a):n),u=decodeURIComponent(a>=0?n.slice(a+1):"");i[c]===void 0?i[c]=u:Array.isArray(i[c])?i[c].push(u):i[c]=[i[c],u]}return{decoded:r,params:i}}function br(o,t){const e=typeof o=="string"?o:(()=>{switch(o.type){case"npub":return`npub1${o.data.slice(4)}`;case"nsec":return"nsec1";case"note":return`note1${o.data.slice(4)}`;case"nprofile":return ae(o.data);case"nevent":return ce(o.data);case"naddr":return ue(o.data);default:throw new Error("Unsupported DecodedResult")}})(),s=t?Object.entries(t).flatMap(([r,i])=>Array.isArray(i)?i.map(n=>`${encodeURIComponent(r)}=${encodeURIComponent(n)}`):[`${encodeURIComponent(r)}=${encodeURIComponent(i)}`]).join("&"):"";return s?`nostr:${e}?${s}`:`nostr:${e}`}function Ye(o){return oe("nsec",o)}function Je(o){return oe("npub",ct(o))}function Xe(o){return oe("note",ct(o))}function ae(o){const t=ne({0:[ct(o.pubkey)],1:(o.relays||[]).map(e=>Bt.encode(e))});return Ht("nprofile",t)}function ce(o){let t;o.kind!==void 0&&(t=pr(o.kind));const e=ne({0:[ct(o.id)],1:(o.relays||[]).map(s=>Bt.encode(s)),2:o.author?[ct(o.author)]:[],3:t?[new Uint8Array(t)]:[]});return Ht("nevent",e)}function ue(o){const t=new ArrayBuffer(4);new DataView(t).setUint32(0,o.kind,!1);const e=ne({0:[Bt.encode(o.identifier)],1:(o.relays||[]).map(s=>Bt.encode(s)),2:[ct(o.pubkey)],3:[new Uint8Array(t)]});return Ht("naddr",e)}function wr(o){const t=o.startsWith("0x")?o.slice(2):o;if(!/^[0-9a-fA-F]{64}$/.test(t))throw new Error("Invalid hex pubkey: must be 64 hex characters");return Je(t)}function vr(o){const t=o.startsWith("0x")?o.slice(2):o;if(!/^[0-9a-fA-F]{64}$/.test(t))throw new Error("Invalid hex privkey: must be 64 hex characters");return Ye(ct(t))}function Er(o){const t=o.startsWith("0x")?o.slice(2):o;if(!/^[0-9a-fA-F]{64}$/.test(t))throw new Error("Invalid hex event id: must be 64 hex characters");return Xe(t)}function le(o){if(!o.startsWith("npub1"))throw new Error('Invalid npub: must start with "npub1"');const t=yt(o);if(t.type!=="npub")throw new Error('Invalid npub: decoded type is not "npub"');return t.data}function Ze(o){if(!o.startsWith("nsec1"))throw new Error('Invalid nsec: must start with "nsec1"');const t=yt(o);if(t.type!=="nsec")throw new Error('Invalid nsec: decoded type is not "nsec"');return D(t.data)}function Qe(o){if(!o.startsWith("note1"))throw new Error('Invalid note: must start with "note1"');const t=yt(o);if(t.type!=="note")throw new Error('Invalid note: decoded type is not "note"');return t.data}function Sr(o,t){const e=o.startsWith("0x")?o.slice(2):o;if(!/^[0-9a-fA-F]{64}$/.test(e))throw new Error("Invalid hex pubkey: must be 64 hex characters");return ae({pubkey:e,relays:t})}function kr(o,t,e,s){const r=o.startsWith("0x")?o.slice(2):o;if(!/^[0-9a-fA-F]{64}$/.test(r))throw new Error("Invalid hex event id: must be 64 hex characters");let i;if(e&&(i=e.startsWith("0x")?e.slice(2):e,!/^[0-9a-fA-F]{64}$/.test(i)))throw new Error("Invalid hex author pubkey: must be 64 hex characters");return ce({id:r,relays:t,author:i,kind:s})}function ts(o,t,e,s){const r=t.startsWith("0x")?t.slice(2):t;if(!/^[0-9a-fA-F]{64}$/.test(r))throw new Error("Invalid hex pubkey: must be 64 hex characters");return ue({identifier:o,pubkey:r,kind:e,relays:s})}function es(o){if(!o||typeof o!="string")return!1;const t=o.startsWith("0x")?o.slice(2):o;return/^[0-9a-fA-F]{64}$/.test(t)}function ss(o){if(!o||typeof o!="string"||!o.startsWith("npub1"))return!1;try{return le(o),!0}catch{return!1}}function Ar(o){if(!o||typeof o!="string"||!o.startsWith("nsec1"))return!1;try{return Ze(o),!0}catch{return!1}}function _r(o){if(!o||typeof o!="string"||!o.startsWith("note1"))return!1;try{return Qe(o),!0}catch{return!1}}class Mr{constructor(t,e){l(this,"conversationCache",new Map);l(this,"roomCache",new Map);this.nostr=t,this.initialMyPubkey=e}with(t){const e=this.convertToHex(t),s=this.normalizePubkey(e),r=this.conversationCache.get(s);if(r)return r;if(!this.isValidPubkey(s)){console.warn("⚠️ Invalid pubkey format, creating conversation that will fail gracefully:",t.substring(0,16)+"...");const n=new we(this.nostr,this.getMyPubkey(),s);return this.conversationCache.set(s,n),n}this.nostr.startUniversalGiftWrapSubscription().catch(n=>{console.warn("⚠️ Failed to start gift wrap subscription for DMs:",n)});const i=new we(this.nostr,this.getMyPubkey(),s);return this.conversationCache.set(s,i),i}convertToHex(t){if(!t||typeof t!="string"||es(t))return t;if(ss(t))try{return le(t)}catch(e){return console.warn("⚠️ Failed to convert npub to hex:",e),t}return t}isValidPubkey(t){return typeof t=="string"&&t.length===64&&/^[0-9a-f]{64}$/i.test(t)}normalizePubkey(t){return t.toLowerCase()}generateRoomId(t){return[...t,this.getMyPubkey().toLowerCase()].sort().join(",")}room(t,e){const s=t.map(a=>a.toLowerCase()),r=this.generateRoomId(s),i=this.roomCache.get(r);if(i)return i;this.nostr.startUniversalGiftWrapSubscription().catch(a=>{console.warn("⚠️ Failed to start gift wrap subscription for DM room:",a)});const n=new Pr(this.nostr,this.getMyPubkey(),s,e);return this.roomCache.set(r,n),n}get conversations(){return Array.from(this.conversationCache.values())}getMyPubkey(){var s;const t=this.nostr.signingProvider,e=(s=t==null?void 0:t.getPublicKeySync)==null?void 0:s.call(t);return e&&typeof e=="string"&&/^[0-9a-f]{64}$/i.test(e)?e.toLowerCase():this.initialMyPubkey.toLowerCase()}summaries(){var e;const t=[];for(const[s,r]of this.conversationCache.entries())t.push({pubkey:s,type:"conversation"});for(const[s,r]of this.roomCache.entries())t.push({pubkey:s,type:"room",participants:s.split(","),subject:(e=r.options)==null?void 0:e.subject});return t}}class Pr{constructor(t,e,s,r){l(this,"store");this.nostr=t,this.myPubkey=e,this.roomParticipants=s,this.options=r,this.store=this.nostr.query().kinds([14]).tags("p",[this.myPubkey,...this.roomParticipants]).execute()}subscribe(t){return this.store.subscribe(t)}get messages(){return this.store.current}async send(t){try{return{success:!0}}catch{return{success:!1}}}get participants(){return[this.myPubkey,...this.roomParticipants]}async addParticipant(t){return{success:!0}}async removeParticipant(t){return{success:!0}}}class Tr{constructor(t,e){this.nostr=t,this.debug=e,this.debug&&console.log("🎯 ReactionModule initialized with Clean Architecture")}to(t){return this.startReactionSubscription(t),this.nostr.query().kinds([7]).tags("e",[t]).execute().map(e=>this.aggregateReactions(e,t))}myReaction(t){const e=this.nostr.me;return e?this.nostr.query().kinds([7]).authors([e]).tags("e",[t]).limit(1).execute().map(s=>{var r;return((r=s[0])==null?void 0:r.content)||null}):this.createNullStore()}async react(t,e="+"){var s;try{const r=await this.getTargetEvent(t);if(!r)return{success:!1,error:"Target event not found"};const i=await this.nostr.events.reaction(t,e).tag("p",r.pubkey).publish();return this.debug&&console.log(`ReactionModule: Published reaction "${e}" to event ${t.substring(0,8)}...`),{success:i.success,eventId:i.eventId,error:(s=i.error)==null?void 0:s.message}}catch(r){return{success:!1,error:r instanceof Error?r.message:"Failed to publish reaction"}}}async unreact(t){var e;try{const s=await this.nostr.getPublicKey();let i=this.nostr.query().kinds([7]).authors([s]).tags("e",[t]).execute().current||[];if((!i||i.length===0)&&(await this.nostr.sub().kinds([7]).authors([s]).tags("e",[t]).limit(100).execute(),await new Promise(u=>setTimeout(u,300)),i=this.nostr.query().kinds([7]).authors([s]).tags("e",[t]).limit(100).execute().current||[],!i||i.length===0))return{success:!1,error:"No reaction found to remove"};const n=i[0];let a=this.nostr.events.deletion(n.id,"User removed reaction");for(let u=1;u<i.length;u++)a=a.tag("e",i[u].id);this.debug&&console.log("ReactionModule.unreact: deleting all my reactions for target",{targetEventId:t.substring(0,8)+"...",count:i.length});const c=await a.publish();return this.debug&&console.log(`ReactionModule: Deleted reaction to event ${t.substring(0,8)}...`),{success:c.success,error:(e=c.error)==null?void 0:e.message}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Failed to remove reaction"}}}async startReactionSubscription(t){try{await this.nostr.sub().kinds([7]).tags("e",[t]).limit(100).execute()}catch(e){this.debug&&console.warn("Failed to start reaction subscription:",e)}}async startMyReactionSubscription(t,e){}async getTargetEvent(t){await this.nostr.sub().ids([t]).limit(1).execute(),await new Promise(r=>setTimeout(r,500));const s=this.nostr.query().ids([t]).limit(1).execute().current;return s&&s.length>0?s[0]:null}aggregateReactions(t,e){const s={};let r=0,i=!1,n;const a=this.nostr.me;return t.filter(c=>c&&typeof c=="object").forEach(c=>{if(c.kind!==7)return;const u=c.content||"+",h=c.pubkey;s[u]||(s[u]={type:u,count:0,authors:[]}),s[u].count++,s[u].authors.push(h),r++,a&&h===a&&(i=!0,n=u)}),{targetEventId:e,totalCount:r,reactions:s,userReacted:i,userReactionType:n}}createNullStore(){return this.nostr.query().kinds([7]).authors([""]).limit(1).execute().map(()=>null)}}class Ir{constructor(t){l(this,"_d");l(this,"_title");l(this,"_summary");l(this,"_image");l(this,"_content");l(this,"_hashtags",[]);this.nostr=t}identifier(t){return this._d=t,this}title(t){return this._title=t,this}summary(t){return this._summary=t,this}image(t){return this._image=t,this}content(t){return this._content=t??"",this}hashtag(t){return t&&this._hashtags.push(t),this}async publish(){if(!this._d)throw new Error("Article identifier (d) is required");if(!this._content)throw new Error("Article content must not be empty");const t=this.nostr.events.create().kind(30023).content(this._content).tag("d",this._d);this._title&&t.tag("title",this._title),this._summary&&t.tag("summary",this._summary),this._image&&t.tag("image",this._image);for(const e of this._hashtags)t.hashtag(e);return await t.publish()}}class rs{constructor(t,e){this.nostr=t,this.debug=e,this.debug&&console.log("📝 ContentModule initialized with Clean Architecture")}article(){return new Ir(this.nostr)}getArticle(t,e){return this.nostr.sub().kinds([30023]).authors([t]).execute().catch(()=>{}),this.nostr.query().kinds([30023]).authors([t]).execute().map(s=>s.filter(i=>i.tags.some(n=>n[0]==="d"&&n[1]===e)).sort((i,n)=>n.created_at-i.created_at)[0]??null)}articles(t,e){this.nostr.sub().kinds([30023]).authors([t]).execute().catch(()=>{});let s=this.nostr.query().kinds([30023]).authors([t]);return e!=null&&e.limit&&(s=s.limit(e.limit)),s.execute().map(r=>r.sort((i,n)=>n.created_at-i.created_at))}async naddrForArticle(t,e,s){return ts(e,t,30023,s)}notes(t={}){const e={kinds:[1],limit:t.limit||50,...t};this.startContentSubscription(e);let s=this.nostr.query().kinds([1]);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute()}reposts(t={}){const e={kinds:[6],limit:t.limit||50,...t};this.startContentSubscription(e);let s=this.nostr.query().kinds([6]);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute()}feed(t={}){const e={kinds:[1,6],limit:t.limit||50,...t};this.startContentSubscription(e);let s=this.nostr.query().kinds([1,6]);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute().map(r=>this.sortByCreatedAt(r))}summary(t){return this.startContentSubscription({authors:t,kinds:[1,6]}),this.nostr.query().kinds([1,6]).authors(t).execute().map(e=>this.aggregateContentSummary(e))}async publishNote(t){var e;try{const s=await this.nostr.events.note(t).publish();return this.debug&&console.log(`ContentModule: Published note "${t.substring(0,50)}..."`),{success:s.success,eventId:s.eventId,error:(e=s.error)==null?void 0:e.message}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Failed to publish note"}}}async repost(t,e){var s;try{const r=await this.getEvent(t);if(!r)return{success:!1,error:"Original event not found"};const i=await this.nostr.events.create().kind(6).content("").tag("e",t,e||"").tag("p",r.pubkey).publish();return this.debug&&console.log(`ContentModule: Reposted event ${t.substring(0,8)}...`),{success:i.success,eventId:i.eventId,error:(s=i.error)==null?void 0:s.message}}catch(r){return{success:!1,error:r instanceof Error?r.message:"Failed to publish repost"}}}async startContentSubscription(t){try{let e=this.nostr.sub();t.kinds&&(e=e.kinds(t.kinds)),t.authors&&(e=e.authors(t.authors)),t.since&&(e=e.since(t.since)),t.until&&(e=e.until(t.until)),t.limit&&(e=e.limit(t.limit)),await e.execute()}catch(e){this.debug&&console.warn("Failed to start content subscription:",e)}}async getEvent(t){await this.nostr.sub().ids([t]).limit(1).execute(),await new Promise(r=>setTimeout(r,500));const s=this.nostr.query().ids([t]).limit(1).execute().current;return s&&s.length>0?s[0]:null}sortByCreatedAt(t){return[...t].sort((e,s)=>s.created_at-e.created_at)}aggregateContentSummary(t){const e=t.filter(n=>n.kind===1),s=t.filter(n=>n.kind===6),r=this.sortByCreatedAt(e),i=this.sortByCreatedAt(s);return{totalNotes:e.length,totalReposts:s.length,latestNote:r[0],latestRepost:i[0]}}}class Rr{constructor(t,e){this.nostr=t,this.debug=e,this.debug&&console.log("🧵 ThreadModule initialized with Clean Architecture")}thread(t,e={}){this.startThreadSubscription(t,e);let s=this.nostr.query().kinds([1]);return s=s.tags("e",[t]),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute().map(r=>this.buildThreadStructure(r,t))}summary(t){return this.startThreadSubscription(t),this.nostr.query().kinds([1]).tags("e",[t]).execute().map(e=>this.aggregateThreadSummary(e,t))}myThreads(t={}){const e=this.nostr.me;return e?(this.startUserThreadsSubscription(e,t),this.nostr.query().kinds([1]).authors([e]).execute().map(s=>this.extractThreadSummaries(s))):this.createEmptyStore()}followingThreads(t={}){const e=this.nostr.me;return e?this.nostr.query().kinds([3]).authors([e]).limit(1).execute().map(r=>{if(!r||r.length===0)return[];const n=r[0].tags.filter(a=>a[0]==="p").map(a=>a[1]);return n.length===0?[]:(this.startFollowingThreadsSubscription(n,t),[])}):this.createEmptyStore()}async reply(t,e,s=[]){var r;try{const i=await this.getEvent(t);if(!i)return{success:!1,error:"Target event not found"};const{rootEventId:n,replyEventId:a}=this.determineThreadStructure(i);let c=this.nostr.events.create().kind(1).content(e);n&&n!==t&&(c=c.tag("e",n,"","root")),c=c.tag("e",t,"","reply"),c=c.tag("p",i.pubkey);for(const h of s)h!==i.pubkey&&(c=c.tag("p",h));const u=await c.publish();return this.debug&&console.log(`ThreadModule: Published reply to event ${t.substring(0,8)}...`),{success:u.success,eventId:u.eventId,error:(r=u.error)==null?void 0:r.message}}catch(i){return{success:!1,error:i instanceof Error?i.message:"Failed to publish reply"}}}get(t,e){return new Promise(s=>{const r=this.thread(t);let i=null;i=r.subscribe(n=>{if(i){const a=i;i=null,a()}s(n)})})}async watch(t){try{return await this.startThreadSubscription(t),!0}catch(e){return this.debug&&console.warn(`Failed to watch thread ${t}:`,e),!1}}async createThread(t,e=[]){var i;let s,r;typeof t=="string"?(s=t,r=e):(s=t.content,r=t.mentions||[]);try{this.nostr.events}catch{return{success:!1,error:"No signing provider available. Please initialize signing first."}}try{let n=this.nostr.events.note(s);for(const u of r)n=n.tag("p",u);const a=await n.publish();this.debug&&console.log(`ThreadModule: Created new thread with content "${s.substring(0,50)}..."`);let c="";try{c=this.nostr.me||a.pubkey||"",!c&&this.nostr.getMyPubkey&&(c=await this.nostr.getMyPubkey()||"")}catch{c=a.pubkey||""}return{success:a.success,eventId:a.eventId,error:(i=a.error)==null?void 0:i.message,message:a.success?{id:a.eventId||"",content:s,authorPubkey:c,timestamp:Math.floor(Date.now()/1e3),isOwn:!0}:void 0}}catch(n){return{success:!1,error:n instanceof Error?n.message:"Failed to create thread"}}}async startThreadSubscription(t,e={}){try{let s=this.nostr.sub().kinds([1]).tags("e",[t]);e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),await s.execute()}catch(s){this.debug&&console.warn(`Failed to start thread subscription for ${t}:`,s)}}async startUserThreadsSubscription(t,e){try{let s=this.nostr.sub().kinds([1]).authors([t]);e.since&&(s=s.since(e.since)),e.limit&&(s=s.limit(e.limit)),await s.execute()}catch(s){this.debug&&console.warn(`Failed to start user threads subscription for ${t}:`,s)}}async startFollowingThreadsSubscription(t,e){try{let s=this.nostr.sub().kinds([1]).authors(t);e.since&&(s=s.since(e.since)),e.limit&&(s=s.limit(e.limit)),await s.execute()}catch(s){this.debug&&console.warn("Failed to start following threads subscription:",s)}}async getEvent(t){await this.nostr.sub().ids([t]).limit(1).execute(),await new Promise(r=>setTimeout(r,500));const s=this.nostr.query().ids([t]).limit(1).execute().current;return s&&s.length>0?s[0]:null}buildThreadStructure(t,e){const s=[];for(const r of t){const i=this.analyzeThreadEvent(r,e);s.push(i)}return s.sort((r,i)=>r.created_at-i.created_at),s}analyzeThreadEvent(t,e){const s=t.tags.filter(c=>c[0]==="e");let r=0,i=null,n=[],a=e;if(s.length>0){const c=s.find(h=>h[3]==="root"),u=s.find(h=>h[3]==="reply");c&&(a=c[1]),u&&(i=u[1],r=1),!u&&s.length>0&&(s.length===1?(i=s[0][1],r=1):(a=s[0][1],i=s[s.length-1][1],r=s.length-1)),n=s.map(h=>h[1])}return{...t,depth:r,rootEventId:a,replyToEventId:i,threadPath:n}}determineThreadStructure(t){const e=t.tags.filter(r=>r[0]==="e");if(e.length===0)return{rootEventId:t.id,replyEventId:t.id};const s=e.find(r=>r[3]==="root");return s?{rootEventId:s[1],replyEventId:t.id}:e.length===1?{rootEventId:e[0][1],replyEventId:t.id}:{rootEventId:e[0][1],replyEventId:t.id}}aggregateThreadSummary(t,e){let s=0,r=0;const i=new Set;let n,a;for(const c of t){const u=this.analyzeThreadEvent(c,e);u.id===e?a=u:(s++,(!n||u.created_at>n.created_at)&&(n=u)),r=Math.max(r,u.depth),i.add(u.pubkey)}return{rootEventId:e,totalReplies:s,maxDepth:r,participants:Array.from(i),latestReply:n,rootEvent:a}}extractThreadSummaries(t){const e=new Map;for(const r of t){const i=r.tags.filter(n=>n[0]==="e");if(i.length===0){const n=r.id;e.has(n)||e.set(n,[]),e.get(n).push(r)}else{const n=i.find(c=>c[3]==="root"),a=n?n[1]:i[0][1];e.has(a)||e.set(a,[]),e.get(a).push(r)}}const s=[];for(const[r,i]of e){const n=this.aggregateThreadSummary(i,r);s.push(n)}return s.sort((r,i)=>{var c,u,h,d;const n=((c=r.latestReply)==null?void 0:c.created_at)||((u=r.rootEvent)==null?void 0:u.created_at)||0;return(((h=i.latestReply)==null?void 0:h.created_at)||((d=i.rootEvent)==null?void 0:d.created_at)||0)-n}),s}createEmptyStore(){return this.nostr.query().kinds([1]).authors([""]).limit(1).execute().map(()=>[])}}class Cr{constructor(t,e){this.nostr=t,this.debug=e,this.debug&&console.log("📰 FeedModule initialized with Clean Architecture")}global(t={}){const e={kinds:[1,6,7],limit:50,includeReplies:!0,includeReactions:!0,includeReposts:!0,...t};this.startFeedSubscription(e);let s=this.nostr.query().kinds(e.kinds);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute().map(r=>this.processFeedEvents(r,e))}following(t={}){const e=this.nostr.me;return e?this.nostr.query().kinds([3]).authors([e]).limit(1).execute().map(r=>{if(!r||r.length===0)return[];const n=r[0].tags.filter(c=>c[0]==="p").map(c=>c[1]);if(n.length===0)return[];const a={...t,authors:n,kinds:t.kinds||[1,6,7],limit:t.limit||30};return this.startFeedSubscription(a),[]}):this.createEmptyStore()}user(t,e={}){const s={kinds:[1,6,7],limit:50,includeReplies:!0,includeReactions:!0,includeReposts:!0,...e,authors:[t]};this.startFeedSubscription(s);let r=this.nostr.query().kinds(s.kinds).authors([t]);return s.since&&(r=r.since(s.since)),s.until&&(r=r.until(s.until)),s.limit&&(r=r.limit(s.limit)),r.execute().map(i=>this.processFeedEvents(i,s))}trending(t={}){const e={kinds:[1],limit:20,since:Math.floor(Date.now()/1e3)-86400,...t};this.startFeedSubscription(e);let s=this.nostr.query().kinds([1]);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit*3)),s.execute().map(r=>this.processTrendingEvents(r,e))}stats(t={}){const e={kinds:[1,6,7],limit:100,...t};this.startFeedSubscription(e);let s=this.nostr.query().kinds(e.kinds);return e.authors&&(s=s.authors(e.authors)),e.since&&(s=s.since(e.since)),e.until&&(s=s.until(e.until)),e.limit&&(s=s.limit(e.limit)),s.execute().map(r=>this.calculateFeedStats(r))}search(t,e={}){const s={kinds:[1],limit:30,...e};this.startFeedSubscription(s);let r=this.nostr.query().kinds(s.kinds);return s.authors&&(r=r.authors(s.authors)),s.since&&(r=r.since(s.since)),s.until&&(r=r.until(s.until)),s.limit&&(r=r.limit(s.limit*5)),r.execute().map(i=>this.filterEventsByContent(i,t,s))}async startFeedSubscription(t){try{let e=this.nostr.sub();t.kinds&&(e=e.kinds(t.kinds)),t.authors&&(e=e.authors(t.authors)),t.since&&(e=e.since(t.since)),t.until&&(e=e.until(t.until)),t.limit&&(e=e.limit(t.limit)),await e.execute()}catch(e){this.debug&&console.warn("Failed to start feed subscription:",e)}}processFeedEvents(t,e){let s=[];for(const r of t){const i=this.convertToFeedEvent(r);!e.includeReplies&&i.feedType==="thread"&&i.referencedEventId||!e.includeReactions&&i.feedType==="reaction"||!e.includeReposts&&i.feedType==="repost"||s.push(i)}return s.sort((r,i)=>i.created_at-r.created_at),s}processTrendingEvents(t,e){const s=t.map(r=>this.convertToFeedEvent(r));return s.sort((r,i)=>i.created_at-r.created_at),s.slice(0,e.limit||20)}filterEventsByContent(t,e,s){const r=e.toLowerCase(),n=t.filter(a=>a.content?a.content.toLowerCase().includes(r):!1).map(a=>this.convertToFeedEvent(a));return n.sort((a,c)=>c.created_at-a.created_at),n.slice(0,s.limit||30)}convertToFeedEvent(t){let e="note",s,r;if(t.kind===6){e="repost";const i=t.tags.filter(n=>n[0]==="e");i.length>0&&(s=i[0][1])}else if(t.kind===7){e="reaction";const i=t.tags.filter(n=>n[0]==="e");i.length>0&&(s=i[0][1])}else if(t.kind===1){const i=t.tags.filter(n=>n[0]==="e");if(i.length>0){e="thread";const n=i.find(c=>c[3]==="root"),a=i.find(c=>c[3]==="reply");n&&(r=n[1]),a?s=a[1]:i.length>0&&(s=i[0][1])}}return{...t,feedType:e,referencedEventId:s,threadRoot:r}}calculateFeedStats(t){const e={totalEvents:t.length,noteCount:0,repostCount:0,reactionCount:0,threadCount:0,uniqueAuthors:0,timeRange:{oldest:0,newest:0}};if(t.length===0)return e;const s=new Set;let r=t[0].created_at,i=t[0].created_at;for(const n of t)n.kind===1?n.tags.filter(c=>c[0]==="e").length>0?e.threadCount++:e.noteCount++:n.kind===6?e.repostCount++:n.kind===7&&e.reactionCount++,s.add(n.pubkey),r=Math.min(r,n.created_at),i=Math.max(i,n.created_at);return e.uniqueAuthors=s.size,e.timeRange.oldest=r,e.timeRange.newest=i,e}createEmptyStore(){return this.nostr.query().kinds([1]).authors([""]).limit(1).execute().map(()=>[])}}class xr{constructor(t){l(this,"config");l(this,"_content");l(this,"_reactions");l(this,"_threads");l(this,"_feeds");l(this,"_communities");l(this,"_lists");l(this,"closing",!1);l(this,"closePromise");this.config=t,this.config.debug&&console.log("🔥 SocialModule initialized with Clean Architecture")}get content(){return this._content||(this._content=new rs(this.config.nostr,this.config.debug)),this._content}get reactions(){return this._reactions||(this._reactions=new Tr(this.config.nostr,this.config.debug)),this._reactions}get threads(){return this._threads||(this._threads=new Rr(this.config.nostr,this.config.debug)),this._threads}get feeds(){return this._feeds||(this._feeds=new Cr(this.config.nostr,this.config.debug)),this._feeds}get communities(){if(!this._communities)throw new Error("CommunityModule not yet implemented - Coming in Phase 3");return this._communities}get lists(){if(!this._lists)throw new Error("ListModule not yet implemented - Coming in Phase 2");return this._lists}async updateSigningProvider(t){this.config.debug&&console.log("🔑 SocialModule.updateSigningProvider - storing reference")}async close(){if(this.closing)return this.closePromise?this.closePromise:void 0;this.closing=!0,this.closePromise=this.performCleanup();try{await this.closePromise,this.config.debug&&console.log("🔥 SocialModule cleanup completed successfully")}catch(t){throw this.config.debug&&console.error("🔥 SocialModule cleanup error:",t),t}}async performCleanup(){const t=[];this._content&&typeof this._content.close=="function"&&t.push(this._content.close().catch(e=>{this.config.debug&&console.warn("SocialModule: ContentModule cleanup error:",e)})),this._reactions&&typeof this._reactions.close=="function"&&t.push(this._reactions.close().catch(e=>{this.config.debug&&console.warn("SocialModule: ReactionModule cleanup error:",e)})),this._threads&&typeof this._threads.close=="function"&&t.push(this._threads.close().catch(e=>{this.config.debug&&console.warn("SocialModule: ThreadModule cleanup error:",e)})),this._feeds&&typeof this._feeds.close=="function"&&t.push(this._feeds.close().catch(e=>{this.config.debug&&console.warn("SocialModule: FeedModule cleanup error:",e)})),this._communities&&typeof this._communities.close=="function"&&t.push(this._communities.close().catch(e=>{this.config.debug&&console.warn("SocialModule: CommunityModule cleanup error:",e)})),this._lists&&typeof this._lists.close=="function"&&t.push(this._lists.close().catch(e=>{this.config.debug&&console.warn("SocialModule: ListModule cleanup error:",e)})),t.length>0&&await Promise.race([Promise.all(t),new Promise((e,s)=>setTimeout(()=>s(new Error("Module cleanup timeout after 10 seconds")),1e4))]),this._content=void 0,this._reactions=void 0,this._threads=void 0,this._feeds=void 0,this._communities=void 0,this._lists=void 0}}class Nr{constructor(t){l(this,"root",{});l(this,"parent",{});l(this,"_content");this.nostr=t}onEventRoot(t,e,s){return this.root.E={id:t,relay:e||void 0,pubkey:s||void 0},this}onAddressableRoot(t,e,s,r){return this.root.A={address:`${t}:${e}:${s}`,relay:r||void 0},this.root.K={kind:t},this.root.P={pubkey:e},this}onExternalRoot(t,e){return this.root.I={identifier:t,context:e||void 0},this}onKindRoot(t){return this.root.K={kind:t},this}onAuthorRoot(t,e){return this.root.P={pubkey:t,relay:e||void 0},this}replyToEvent(t,e,s){return this.parent.e={id:t,relay:e||void 0,pubkey:s||void 0},this}replyToAddress(t,e,s,r){return this.parent.a={address:`${t}:${e}:${s}`,relay:r||void 0},this.parent.k={kind:t},this.parent.p={pubkey:e},this}replyToExternal(t,e){return this.parent.i={identifier:t,context:e||void 0},this}replyToKind(t){return this.parent.k={kind:t},this}replyToAuthor(t,e){return this.parent.p={pubkey:t,relay:e||void 0},this}content(t){return this._content=t??"",this}buildTags(){const t=[];return this.root.E&&t.push(["E",this.root.E.id,this.root.E.relay||"",this.root.E.pubkey||""].filter(Boolean)),this.root.A&&t.push(["A",this.root.A.address,this.root.A.relay||""].filter(Boolean)),this.root.I&&t.push(["I",this.root.I.identifier,this.root.I.context||""].filter(Boolean)),this.root.K&&t.push(["K",String(this.root.K.kind)]),this.root.P&&t.push(["P",this.root.P.pubkey,this.root.P.relay||""].filter(Boolean)),this.parent.e&&t.push(["e",this.parent.e.id,this.parent.e.relay||"",this.parent.e.pubkey||""].filter(Boolean)),this.parent.a&&t.push(["a",this.parent.a.address,this.parent.a.relay||""].filter(Boolean)),this.parent.i&&t.push(["i",this.parent.i.identifier,this.parent.i.context||""].filter(Boolean)),this.parent.k&&t.push(["k",String(this.parent.k.kind)]),this.parent.p&&t.push(["p",this.parent.p.pubkey,this.parent.p.relay||""].filter(Boolean)),t}async publish(t){if(!this._content||this._content.length===0)throw new Error("Comment content must not be empty");const e=this.nostr.events.create().kind(1111).content(this._content);for(const i of this.buildTags())e.tag(i[0],...i.slice(1));const s=await e.sign();return await this.nostr.publishSigned(await s.build(),t)}}class Dr{constructor(t){this.nostr=t}create(){return new Nr(this.nostr)}getForAddressable(t,e,s){const r=`${t}:${e}:${s}`;return this.nostr.sub().kinds([1111]).execute().catch(()=>{}),this.nostr.query().kinds([1111]).execute().map(i=>i.filter(n=>n.tags.some(a=>a[0]==="A"&&a[1]===r||a[0]==="a"&&a[1]===r)))}getRepliesTo(t){return this.nostr.sub().kinds([1111]).execute().catch(()=>{}),this.nostr.query().kinds([1111]).execute().map(e=>e.filter(s=>s.tags.some(r=>r[0]==="e"&&r[1]===t)))}}class Lr{constructor(t,e){l(this,"tags",[]);l(this,"content","");l(this,"identifier",null);this.nostr=t,this.kind=e}id(t){return this.identifier=t,this}title(t){return this.tags.push(["title",t]),this}description(t){return this.tags.push(["description",t]),this}image(t){return this.tags.push(["image",t]),this}note(t){return this.content=t,this}addPerson(t,e,s){const r=["p",t];return e&&r.push(e),s&&r.push(s),this.tags.push(r),this}addEvent(t,e){const s=["e",t];return e&&s.push(e),this.tags.push(s),this}addAddress(t,e){const s=["a",t];return e&&s.push(e),this.tags.push(s),this}addRelay(t){return this.tags.push(["relay",t]),this}topic(t){return this.tags.push(["t",t]),this}async publish(){const t=this.nostr.events.kind(this.kind).content(this.content||"");this.identifier&&t.tag("d",this.identifier);for(const e of this.tags)t.tag(...e);return t.publish()}}class Fr{constructor(t){this.nostr=t}edit(t,e){const s=new Lr(this.nostr,t);return e&&s.id(e),s}get(t,e,s){const r=this.nostr.sub().kinds([e]).authors([t]);s&&r.tags("d",[s]),r.limit(1).execute().catch(()=>{});const i=this.nostr.query().kinds([e]).authors([t]);return s&&i.tags("d",[s]),i.limit(1).execute().map(a=>this.parse(a==null?void 0:a[0]))}parse(t){if(!t)return null;const e=p=>{var g;return(g=t.tags.find(y=>y[0]===p))==null?void 0:g[1]},s=p=>t.tags.filter(g=>g[0]===p),r=e("d")||null,i=e("title"),n=e("description"),a=e("image"),c=s("p").map(p=>({pubkey:p[1],relay:p[2],petname:p[3]})),u=s("e").map(p=>({id:p[1],relay:p[2]})),h=s("a").map(p=>({address:p[1],relay:p[2]})),d=s("relay").map(p=>p[1]),f=s("t").map(p=>p[1]);return{kind:t.kind,identifier:r,title:i,description:n,image:a,p:c,e:u,a:h,relays:d,topics:f,updatedAt:t.created_at}}}class $r{constructor(t){l(this,"tags",[]);l(this,"content","");this.nostr=t}namespace(t){return this.tags.push(["L",t]),this}label(t,e){return e?this.tags.push(["l",t,e]):this.tags.push(["l",t]),this}targetEvent(t,e){return this.tags.push(["e",t,e||""]),this}targetAuthor(t,e){return this.tags.push(["p",t,e||""]),this}targetAddress(t,e){return this.tags.push(["a",t,e||""]),this}targetRelay(t){return this.tags.push(["r",t]),this}targetTopic(t){return this.tags.push(["t",t]),this}reason(t){return this.content=t,this}async publish(){return await this.nostr.events.create().kind(1985).content(this.content).tags(this.tags).publish()}}class Or{constructor(t){this.nostr=t}edit(){return new $r(this.nostr)}forEvent(t){return this.nostr.sub().kinds([1985]).tags("e",[t]).execute().catch(()=>{}),this.nostr.query().kinds([1985]).tags("e",[t]).execute()}}class Br{constructor(t){l(this,"meta",{});l(this,"categoryTags",[]);this.nostr=t}name(t){return this.meta.name=t,this}about(t){return this.meta.about=t,this}picture(t){return this.meta.picture=t,this}relays(t){return this.meta.relays=t,this}category(t){return this.categoryTags.push(t),this}async publish(){const t=JSON.stringify(this.meta),e=this.nostr.events.create().kind(40).content(t);for(const s of this.categoryTags)e.tag("t",s);return e.publish()}}class Ur{constructor(t,e){l(this,"meta",{});l(this,"categoryTags",[]);l(this,"relayHint");this.nostr=t,this.channelEventId=e}hint(t){return this.relayHint=t,this}name(t){return this.meta.name=t,this}about(t){return this.meta.about=t,this}picture(t){return this.meta.picture=t,this}relays(t){return this.meta.relays=t,this}category(t){return this.categoryTags.push(t),this}async publish(){const t=JSON.stringify(this.meta),e=this.nostr.events.create().kind(41).content(t).tag("e",this.channelEventId,this.relayHint||"","root");for(const s of this.categoryTags)e.tag("t",s);return e.publish()}}class Kr{constructor(t,e){l(this,"messageContent","");l(this,"replyToEventId");l(this,"replyRelayHint");l(this,"mentions",[]);l(this,"relayHint");this.nostr=t,this.channelEventId=e}hint(t){return this.relayHint=t,this}content(t){return this.messageContent=t,this}replyTo(t,e){return this.replyToEventId=t,this.replyRelayHint=e,this}mention(t,e){return this.mentions.push({pubkey:t,relay:e}),this}async publish(){const t=this.nostr.events.create().kind(42).content(this.messageContent).tag("e",this.channelEventId,this.relayHint||"","root");this.replyToEventId&&t.tag("e",this.replyToEventId,this.replyRelayHint||"","reply");for(const e of this.mentions)t.tag("p",e.pubkey,e.relay||"");return t.publish()}}class Hr{constructor(t,e){l(this,"reason");this.nostr=t,this.messageEventId=e}withReason(t){return this.reason=t,this}async publish(){const t=this.reason?JSON.stringify({reason:this.reason}):"";return this.nostr.events.create().kind(43).content(t).tag("e",this.messageEventId).publish()}}class Wr{constructor(t,e){l(this,"reason");this.nostr=t,this.pubkey=e}withReason(t){return this.reason=t,this}async publish(){const t=this.reason?JSON.stringify({reason:this.reason}):"";return this.nostr.events.create().kind(44).content(t).tag("p",this.pubkey).publish()}}class zr{constructor(t){this.nostr=t}create(){return new Br(this.nostr)}metadata(t){return new Ur(this.nostr,t)}message(t){return new Kr(this.nostr,t)}hide(t){return new Hr(this.nostr,t)}mute(t){return new Wr(this.nostr,t)}list(){return this.nostr.sub().kinds([40]).execute().catch(()=>{}),this.nostr.query().kinds([40]).execute()}metadataFor(t){return this.nostr.sub().kinds([41]).tags("e",[t]).execute().catch(()=>{}),this.nostr.query().kinds([41]).tags("e",[t]).execute()}messagesFor(t){return this.nostr.sub().kinds([42]).tags("e",[t]).execute().catch(()=>{}),this.nostr.query().kinds([42]).tags("e",[t]).execute()}visibleMessages(t,e){const s=this.messagesFor(t),r=this.nostr.query().kinds([43]).authors([e]).execute(),i=this.nostr.query().kinds([44]).authors([e]).execute();return s.map(n=>{var u,h;const a=new Set(((u=r.current)==null?void 0:u.flatMap(d=>d.tags.filter(f=>f[0]==="e").map(f=>f[1])))||[]),c=new Set(((h=i.current)==null?void 0:h.flatMap(d=>d.tags.filter(f=>f[0]==="p").map(f=>f[1])))||[]);return n.filter(d=>!a.has(d.id)&&!c.has(d.pubkey))})}}function he(o){return`34550:${o.authorPubkey}:${o.identifier}`}class qr{constructor(t,e){l(this,"d");l(this,"nameTag");l(this,"descriptionTag");l(this,"imageTag");l(this,"moderators",[]);l(this,"relays",[]);this.nostr=t,this.authorPubkey=e}identifier(t){return this.d=t,this}name(t){return this.nameTag=t,this}description(t){return this.descriptionTag=t,this}image(t,e){return this.imageTag={url:t,dim:e},this}moderator(t,e){return this.moderators.push({pubkey:t,relay:e||void 0}),this}relay(t,e){return this.relays.push({url:t,marker:e}),this}async publish(){var e,s;if(!this.d)throw new Error("Community identifier (d) is required");const t=this.nostr.events.create().kind(34550).content("");t.tag("d",this.d),this.nameTag&&t.tag("name",this.nameTag),this.descriptionTag&&t.tag("description",this.descriptionTag),this.imageTag&&t.tag("image",this.imageTag.url,...this.imageTag.dim?[this.imageTag.dim]:[]);for(const r of this.moderators)t.tag("p",r.pubkey,...r.relay?[r.relay]:[],"moderator");for(const r of this.relays)r.marker?t.tag("relay",r.url,r.marker):t.tag("relay",r.url);try{const r=(e=this.relays.find(i=>i.marker==="author"))==null?void 0:e.url;r&&((s=t.toRelays)==null||s.call(t,r))}catch{}return await t.publish()}}class Vr{constructor(t,e){l(this,"_content");l(this,"relayHint");this.nostr=t,this.community=e}content(t){return this._content=t??"",this}relay(t){return this.relayHint=t,this}buildTags(){const t=he(this.community),e=[];return e.push(["A",t,...this.community.relay?[this.community.relay]:[]]),e.push(["a",t,...this.community.relay?[this.community.relay]:[]]),e.push(["P",this.community.authorPubkey,...this.community.relay?[this.community.relay]:[]]),e.push(["p",this.community.authorPubkey,...this.community.relay?[this.community.relay]:[]]),e.push(["K","34550"]),e.push(["k","34550"]),e}async publish(){var e,s,r,i,n;if(!this._content||this._content.length===0)throw new Error("Post content must not be empty");const t=this.nostr.events.create().kind(1111).content(this._content);if(this.relayHint)try{(e=t.toRelays)==null||e.call(t,this.relayHint)}catch{}else if(this.community.relay)try{(s=t.toRelays)==null||s.call(t,this.community.relay)}catch{}else try{const a=await this.nostr.communities.resolveRelays(this.community.authorPubkey,this.community.identifier,3e3);if(a!=null&&a.requests)try{(r=t.toRelays)==null||r.call(t,a.requests)}catch{}}catch{}if(!t.targetRelays||(((i=t.targetRelays)==null?void 0:i.length)||0)===0){this.nostr.getDebug()&&console.warn("⚠️ Community post without relay markers. Falling back to connected relays. Consider adding explicit relay markers for better delivery.");const a=this.nostr.relayManager.connectedRelays;if(a.length>0)try{(n=t.toRelays)==null||n.call(t,a)}catch{}else throw new Error("No connected relays available for community post. Ensure you are connected to at least one relay.")}for(const a of this.buildTags())t.tag(a[0],...a.slice(1));return await t.publish()}}class jr{constructor(t,e,s){l(this,"_content");l(this,"relayHint");this.nostr=t,this.community=e,this.parent=s}content(t){return this._content=t??"",this}relay(t){return this.relayHint=t,this}async publish(){var s,r,i,n,a;if(!this._content||this._content.length===0)throw new Error("Reply content must not be empty");const t=he(this.community),e=this.nostr.events.create().kind(1111).content(this._content);if(this.relayHint)try{(s=e.toRelays)==null||s.call(e,this.relayHint)}catch{}else if(this.community.relay)try{(r=e.toRelays)==null||r.call(e,this.community.relay)}catch{}else try{const c=await this.nostr.communities.resolveRelays(this.community.authorPubkey,this.community.identifier,800);if(c!=null&&c.requests)try{(i=e.toRelays)==null||i.call(e,c.requests)}catch{}}catch{}if(!e.targetRelays||(((n=e.targetRelays)==null?void 0:n.length)||0)===0){this.nostr.getDebug()&&console.warn("⚠️ Community reply without relay markers. Falling back to connected relays. Consider adding explicit relay markers for better delivery.");const c=this.nostr.relayManager.connectedRelays;if(c.length>0)try{(a=e.toRelays)==null||a.call(e,c)}catch{}else throw new Error("No connected relays available for community reply. Ensure you are connected to at least one relay.")}return e.tag("A",t,...this.community.relay?[this.community.relay]:[]),e.tag("P",this.community.authorPubkey,...this.community.relay?[this.community.relay]:[]),e.tag("K","34550"),e.tag("e",this.parent.id,...this.parent.relay?[this.parent.relay]:[]),e.tag("p",this.parent.pubkey,...this.parent.relay?[this.parent.relay]:[]),e.tag("k",String(this.parent.kind??1111)),await e.publish()}}class Gr{constructor(t,e){l(this,"_post");l(this,"_contentJson");l(this,"relayHint");this.nostr=t,this.community=e}post(t){return this._post=t,this._contentJson=JSON.stringify(t),this}relay(t){return this.relayHint=t,this}async publish(){var s,r,i,n,a;if(!this._post)throw new Error("Approval requires a post event");const t=this.nostr.events.create().kind(4550).content(this._contentJson);if(this.relayHint)try{(s=t.toRelays)==null||s.call(t,this.relayHint)}catch{}else if(this.community.relay)try{(r=t.toRelays)==null||r.call(t,this.community.relay)}catch{}else try{const c=await this.nostr.communities.resolveRelays(this.community.authorPubkey,this.community.identifier,3e3);if(c!=null&&c.approvals)try{(i=t.toRelays)==null||i.call(t,c.approvals)}catch{}}catch{}if(!t.targetRelays||(((n=t.targetRelays)==null?void 0:n.length)||0)===0){this.nostr.getDebug()&&console.warn("⚠️ Community approval without relay markers. Falling back to connected relays. Consider adding explicit relay markers for better delivery.");const c=this.nostr.relayManager.connectedRelays;if(c.length>0)try{(a=t.toRelays)==null||a.call(t,c)}catch{}else throw new Error("No connected relays available for community approval. Ensure you are connected to at least one relay.")}const e=he(this.community);return t.tag("a",e,...this.community.relay?[this.community.relay]:[]),t.tag("e",this._post.id),t.tag("p",this._post.pubkey),t.tag("k",String(this._post.kind)),await t.publish()}}class Yr{constructor(t){l(this,"relayMap",new Map);this.nostr=t}getAddress(t,e){return`34550:${t}:${e}`}learnRelaysFromEvent(t){const e={author:void 0,requests:void 0,approvals:void 0};try{for(const s of(t==null?void 0:t.tags)||[])if(s[0]==="relay"){const r=s[1],i=s[2];i==="author"?e.author=r:i==="requests"?e.requests=r:i==="approvals"&&(e.approvals=r)}}catch{}return e}getRelays(t,e){var i;const s=this.getAddress(t,e),r=this.relayMap.get(s);if(r)return r;try{const a=this.nostr.query().kinds([34550]).authors([t]).execute().current||[];let c=null;for(const u of a)((i=(u.tags||[]).find(d=>d[0]==="d"))==null?void 0:i[1])===e&&(!c||u.created_at>c.created_at)&&(c=u);if(c){const u=this.learnRelaysFromEvent(c);return this.relayMap.set(s,u),u}}catch{}return{}}async resolveRelays(t,e,s=2e3){var h,d;const r=this.getAddress(t,e),i=this.relayMap.get(r);if(i&&(i.author||i.requests||i.approvals))return this.nostr.getDebug()&&console.log("✅ Community relays from cache:",{author:t.slice(0,8),identifier:e,cached:i}),i;const n=Array.from(new Set([...this.nostr.relayManager.connectedRelays,...this.nostr.config.relays]));this.nostr.getDebug()&&console.log("🔍 Resolving community relays:",{author:t.slice(0,8),identifier:e,searchingRelays:n});try{await this.nostr.sub().kinds([34550]).authors([t]).relays(n).execute()}catch(f){this.nostr.getDebug()&&console.warn("⚠️ Subscription failed:",f)}const a=this.nostr.query().kinds([34550]).authors([t]).execute(),c=f=>f.filter(g=>(g.tags||[]).some(y=>y[0]==="d"&&y[1]===e)).sort((g,y)=>y.created_at-g.created_at)[0]||null;let u=c(a.current||[]);if(u||(u=await new Promise(f=>{let p=!1,g;try{const y=a.subscribe(b=>{if(p)return;const m=c(b);if(m){p=!0;try{clearTimeout(g)}catch{}try{y&&y()}catch{}f(m)}});g=setTimeout(()=>{if(!p){p=!0;try{y&&y()}catch{}f(null)}},Math.max(2e3,s))}catch{f(null)}})),u){const f=this.learnRelaysFromEvent(u);return this.relayMap.set(r,f),this.nostr.getDebug()&&console.log("✅ Resolved community relays:",{author:t.slice(0,8),identifier:e,relays:f,cacheSize:((h=a.current)==null?void 0:h.length)||0}),f}return this.nostr.getDebug()&&console.warn("⚠️ Community NOT FOUND:",{author:t.slice(0,8),identifier:e,searchedRelays:n,cacheSize:((d=a.current)==null?void 0:d.length)||0}),{}}create(t){return new qr(this.nostr,t)}postTo(t,e,s){const r=new Vr(this.nostr,{authorPubkey:t,identifier:e,relay:s||void 0});try{if(!s){const i=this.getRelays(t,e);i!=null&&i.requests&&r.relay(i.requests)}}catch{}return r}replyTo(t,e){const s=new jr(this.nostr,t,e);try{if(!t.relay){const r=this.getRelays(t.authorPubkey,t.identifier);r!=null&&r.requests&&s.relay(r.requests)}}catch{}return s}approve(t){const e=new Gr(this.nostr,t);try{const s=this.getRelays(t.authorPubkey,t.identifier);s!=null&&s.approvals&&e.relay(s.approvals)}catch{}return e}async revokeApproval(t,e){return await this.nostr.events.create().kind(5).content(e||"").tag("e",t,"","deletion").publish()}getCommunity(t,e){const s=e;return this.nostr.sub().kinds([34550]).authors([t]).execute().catch(()=>{}),this.nostr.query().kinds([34550]).authors([t]).execute().map(r=>r.filter(n=>n.tags.some(a=>a[0]==="d"&&a[1]===s)).sort((n,a)=>a.created_at-n.created_at)[0]??null)}posts(t,e,s){const r=`34550:${t}:${e}`;return this.nostr.sub().kinds([1111]).tags("A",[r]).execute().catch(()=>{}),s!=null&&s.approvedOnly&&(this.nostr.sub().kinds([4550]).tags("a",[r]).execute().catch(()=>{}),this.nostr.sub().kinds([34550]).authors([t]).execute().catch(()=>{}),this.nostr.sub().kinds([5]).execute().catch(()=>{})),this.nostr.query().kinds([1111]).tags("A",[r]).execute().map(i=>{let n=i.filter(a=>a.tags.some(c=>(c[0]==="A"||c[0]==="a")&&c[1]===r));if(s!=null&&s.approvedOnly){const c=this.nostr.query().kinds([4550]).execute().current||[],h=this.nostr.query().kinds([5]).execute().current||[],d=g=>h.some(y=>y.tags.some(b=>b[0]==="e"&&b[1]===g.id)),f=this.moderators(t,e),p=new Set(f.current||[]);n=n.filter(g=>{const y=c.filter(b=>b.tags.some(m=>m[0]==="a"&&m[1]===r)&&b.tags.some(m=>m[0]==="e"&&m[1]===g.id)&&!d(b));return y.length===0?!1:s!=null&&s.moderatorsOnly?y.some(b=>p.has(b.pubkey)):!0})}return n})}approvals(t,e,s){const r=`34550:${t}:${e}`;return this.nostr.sub().kinds([4550]).execute().catch(()=>{}),this.nostr.query().kinds([4550]).execute().map(i=>i.filter(n=>n.tags.some(a=>a[0]==="a"&&a[1]===r)&&(!s||n.tags.some(a=>a[0]==="e"&&a[1]===s))))}moderators(t,e){const s=e;return this.nostr.sub().kinds([34550]).authors([t]).execute().catch(()=>{}),this.nostr.query().kinds([34550]).authors([t]).execute().map(r=>{const n=r.filter(c=>c.tags.some(u=>u[0]==="d"&&u[1]===s)).sort((c,u)=>u.created_at-c.created_at)[0];if(!n)return[];const a=n.tags.filter(c=>c[0]==="p"&&(c[3]==="moderator"||c.includes("moderator"))).map(c=>c[1]);return Array.from(new Set(a))})}}class Jr{constructor(t){this.nostr=t}async hashHex(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);return D(et(e))}async publishNoteWithAttachment(t,e,s={}){const r=this.nostr.events.create().kind(1).content(t),i={mimeType:s.mimeType,alt:s.alt,dim:s.dim};if(s.addHash)try{const n=await fetch(e),a=new Uint8Array(await n.arrayBuffer());i.sha256=await this.hashHex(a)}catch{}return r.attachMedia(e,i),await r.publish()}}class Xr{constructor(t,e,s,r={}){l(this,"listeners",new Map);l(this,"subscriptionResult");l(this,"eventCount",0);l(this,"createdAt",Date.now());l(this,"lastEventAt");l(this,"debug");this.key=t,this.filters=e,this.relays=s,this.debug=r.debug||!1}addListener(t){const e=this.generateListenerId(),s={id:e,...t};return this.listeners.set(e,s),this.debug&&console.log(`SharedSubscription: Added listener ${e} to ${this.key} (${this.listeners.size} total)`),e}removeListener(t){return this.listeners.delete(t)&&this.debug&&console.log(`SharedSubscription: Removed listener ${t} from ${this.key} (${this.listeners.size} remaining)`),this.listeners.size===0}async broadcast(t){this.eventCount++,this.lastEventAt=Date.now();const e=[];for(const s of this.listeners.values())s.onEvent&&e.push(Promise.resolve(s.onEvent(t)).catch(r=>{this.debug&&console.error(`SharedSubscription: Listener ${s.id} onEvent error:`,r),s.onError&&s.onError(r instanceof Error?r:new Error(String(r)))}));await Promise.all(e)}async notifyEose(t){const e=[];for(const s of this.listeners.values())s.onEose&&e.push(Promise.resolve(s.onEose(t)).catch(r=>{this.debug&&console.error(`SharedSubscription: Listener ${s.id} onEose error:`,r),s.onError&&s.onError(r instanceof Error?r:new Error(String(r)))}));await Promise.all(e)}async notifyClose(t){const e=[];for(const s of this.listeners.values())s.onClose&&e.push(Promise.resolve(s.onClose(t)).catch(r=>{this.debug&&console.error(`SharedSubscription: Listener ${s.id} onClose error:`,r)}));await Promise.all(e)}async notifyError(t){const e=[];for(const s of this.listeners.values())s.onError&&e.push(Promise.resolve(s.onError(t)).catch(r=>{this.debug&&console.error(`SharedSubscription: Listener ${s.id} onError handler error:`,r)}));await Promise.all(e)}setSubscriptionResult(t){this.subscriptionResult=t}getSubscriptionResult(){return this.subscriptionResult}getStats(){return{listenerCount:this.listeners.size,eventCount:this.eventCount,age:Date.now()-this.createdAt,filters:this.filters,relays:this.relays}}hasListeners(){return this.listeners.size>0}isActive(){var t;return this.hasListeners()&&((t=this.subscriptionResult)==null?void 0:t.success)!==!1}getSubscriptionId(){var t,e;return(e=(t=this.subscriptionResult)==null?void 0:t.subscription)==null?void 0:e.id}generateListenerId(){return`listener_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}}class is{constructor(t){l(this,"subscriptions",new Map);l(this,"eventCallbacks",new Map);l(this,"sharedSubscriptions",new Map);l(this,"debug");this.relayManager=t,this.debug=t.debug||!1,this.setupRelayMessageHandling()}async getOrCreateSubscription(t,e){const s=e&&e.length>0?e:this.relayManager.connectedRelays.length>0?this.relayManager.connectedRelays:this.relayManager.relayUrls,r=this.generateFilterHash(t,s);if(this.sharedSubscriptions.has(r)){const a=this.sharedSubscriptions.get(r);if(this.debug){const c=a.getStats(),u=this.summarizeFilters(t);console.log(`SubscriptionManager: Reusing shared subscription ${r} (${c.listenerCount} listeners) - Filters: ${u}`)}return a}const i=new Xr(r,t,s,{debug:this.debug}),n=await this.subscribe(t,{relays:s,onEvent:a=>i.broadcast(a),onEose:a=>i.notifyEose(a),onClose:a=>i.notifyClose(a),onError:a=>i.notifyError(a)});if(i.setSubscriptionResult(n),n.success&&(this.sharedSubscriptions.set(r,i),this.debug)){const a=this.summarizeFilters(t);console.log(`SubscriptionManager: Created new shared subscription ${r} - Filters: ${a}`)}return i}summarizeFilters(t){return t.map(e=>{const s=[];if(e.kinds&&s.push(`kinds:[${e.kinds.join(",")}]`),e.authors){const r=e.authors.length>1?`${e.authors.length} authors`:`author:${e.authors[0].substring(0,8)}...`;s.push(r)}if(e.ids){const r=e.ids.length>1?`${e.ids.length} ids`:`id:${e.ids[0].substring(0,8)}...`;s.push(r)}return e["#p"]&&s.push(`#p:${e["#p"].length} mentions`),e["#e"]&&s.push(`#e:${e["#e"].length} events`),e["#t"]&&s.push(`#t:${e["#t"].join(",")}`),e.since&&s.push(`since:${new Date(e.since*1e3).toISOString().substring(11,19)}`),e.until&&s.push(`until:${new Date(e.until*1e3).toISOString().substring(11,19)}`),e.limit&&s.push(`limit:${e.limit}`),`{${s.join(", ")}}`}).join(" + ")}generateFilterHash(t,e){const s=t.map(a=>{const c={};return Object.keys(a).sort().forEach(u=>{const h=a[u];Array.isArray(h)&&h.every(d=>typeof d=="string")?c[u]=[...h].sort():c[u]=h}),c}),r=JSON.stringify(s),i=e.slice().sort().join(","),n=`${r}:${i}`;return typeof crypto<"u"&&crypto.subtle?this.generateSHA256HashSync(n):this.generateSecureHash(n)}generateSHA256HashSync(t){const s=new TextEncoder().encode(t);let r=2166136261;for(let i=0;i<s.length;i++)r^=s[i],r=Math.imul(r,16777619);return r^=r>>>16,r=Math.imul(r,2246822507),r^=r>>>13,r=Math.imul(r,3266489909),r^=r>>>16,(r>>>0).toString(16).padStart(8,"0")}generateSecureHash(t){const e=this.djb2Hash(t),s=this.sdbmHash(t),r=this.fnvHash(t);return((e^s^r)>>>0).toString(16).padStart(8,"0")}djb2Hash(t){let e=5381;for(let s=0;s<t.length;s++)e=(e<<5)+e+t.charCodeAt(s);return e}sdbmHash(t){let e=0;for(let s=0;s<t.length;s++)e=t.charCodeAt(s)+(e<<6)+(e<<16)-e;return e}fnvHash(t){let e=2166136261;for(let s=0;s<t.length;s++)e^=t.charCodeAt(s),e=Math.imul(e,16777619);return e}async cleanupSharedSubscriptions(){const t=[];for(const[e,s]of this.sharedSubscriptions.entries())if(!s.hasListeners()){t.push(e);const r=s.getSubscriptionId();r&&await this.close(r,"No more listeners")}for(const e of t)this.sharedSubscriptions.delete(e),this.debug&&console.log(`SubscriptionManager: Removed orphaned shared subscription ${e}`)}getSubscriptionAnalytics(){let t=0,e=0;for(const s of this.sharedSubscriptions.values()){const r=s.getStats();t+=r.listenerCount,r.listenerCount>1&&(e+=r.listenerCount-1)}return{totalSubscriptions:this.subscriptions.size,sharedSubscriptions:this.sharedSubscriptions.size,totalListeners:t,duplicatesAvoided:e}}getSharedSubscriptionsOverview(){const t=[];for(const[e,s]of this.sharedSubscriptions.entries()){const r=s.getStats();t.push({key:e,subscriptionId:s.getSubscriptionId(),stats:{listenerCount:r.listenerCount,eventCount:r.eventCount,age:r.age},filters:r.filters,relays:r.relays})}return t.sort((e,s)=>s.stats.listenerCount-e.stats.listenerCount),t}async subscribe(t,e={}){var s,r,i,n;try{const a=this.validateFilters(t);if(a)return{subscription:{},success:!1,relayResults:[],error:a};const c=this.generateSubscriptionId(),u=Date.now(),h=e.relays&&e.relays.length>0?e.relays:this.relayManager.connectedRelays.length>0?this.relayManager.connectedRelays:this.relayManager.relayUrls,d={id:c,filters:t,relays:h,state:"pending",createdAt:u,eventCount:0,onEvent:e.onEvent,onEose:e.onEose,onClose:e.onClose,relayStates:{},eoseRelays:new Set,receivedEventIds:new Set};if(h.forEach(m=>{d.relayStates[m]="active"}),e.timeout&&(d.timeoutId=setTimeout(()=>{this.handleSubscriptionTimeout(c)},e.timeout)),this.subscriptions.set(c,d),this.debug){const m=this.summarizeFilters(t);console.log(`Creating subscription ${c} with ${t.length} filters: ${m}`)}const f=e.retryAttempts||1,p=e.retryDelay||1e3;let g=[],y;for(let m=0;m<f;m++)try{const w=["REQ",c,...t];if(e.relays&&e.relays.length>0){try{const A=new Set(this.relayManager.relayUrls),M=(e.relays||[]).filter(P=>!A.has(P));M.length&&this.relayManager.addRelays&&this.relayManager.addRelays(M,{temporary:!0}),this.relayManager.ensureConnected&&await this.relayManager.ensureConnected(h)}catch{}g=[];let k=!1;for(const A of h)try{await((r=(s=this.relayManager).sendToRelays)==null?void 0:r.call(s,[A],w)),g.push({relay:A,success:!0,subscriptionId:c}),k=!0}catch(M){g.push({relay:A,success:!1,error:M instanceof Error?M.message:"Unknown error",subscriptionId:c})}if(k)break;y=new Error("All relays failed")}else{await((n=(i=this.relayManager).sendToAll)==null?void 0:n.call(i,w)),g=h.map(k=>({relay:k,success:!0}));break}}catch(w){y=w instanceof Error?w:new Error("Unknown error"),g=h.map(k=>({relay:k,success:!1,error:y})),m<f-1&&await new Promise(k=>setTimeout(k,p))}const b=g.length>0&&g.some(m=>m.success);return b||(this.subscriptions.delete(c),d.timeoutId&&clearTimeout(d.timeoutId)),{subscription:b?this.externalizeSubscription(d):{},success:b,relayResults:g,error:b?void 0:{message:y?y.message:g.length===0?"No relays available":"All relays failed",retryable:!0}}}catch(a){return{subscription:{},success:!1,relayResults:[],error:{message:a instanceof Error?a.message:"Unknown error",retryable:!0}}}}async activate(t){var s,r,i,n;const e=this.subscriptions.get(t);if(!e)throw new Error(`Subscription ${t} not found`);e.state="active";try{const a=["REQ",t,...e.filters],c=this.relayManager.connectedRelays;e.relays.length!==c.length||!e.relays.every(h=>c.includes(h))?await((r=(s=this.relayManager).sendToRelays)==null?void 0:r.call(s,e.relays,a)):await((n=(i=this.relayManager).sendToAll)==null?void 0:n.call(i,a))}catch(a){throw e.state="error",a}}async markEose(t,e){const s=this.subscriptions.get(t);s&&(s.eoseRelays.add(e),s.state="eose",s.onEose&&s.onEose(e))}async close(t,e){var r,i;const s=this.subscriptions.get(t);if(s){s.state="closed",s.timeoutId&&(clearTimeout(s.timeoutId),s.timeoutId=void 0);try{const n=["CLOSE",t];await((i=(r=this.relayManager).sendToAll)==null?void 0:i.call(r,n))}catch(n){this.debug&&console.error(`Error sending CLOSE for ${t}:`,n)}s.onClose&&s.onClose(e),this.subscriptions.delete(t)}}async closeAll(){const t=this.getActiveSubscriptions();await Promise.all(t.map(e=>this.close(e.id,"closeAll")))}async unsubscribe(t){await this.close(t,"unsubscribe")}async unsubscribeAll(){await this.closeAll()}async handleEvent(t,e){const s=this.subscriptions.get(t);s&&(s.receivedEventIds.has(e.id)||(s.receivedEventIds.add(e.id),s.eventCount++,s.lastEventAt=Date.now(),s.onEvent&&s.onEvent(e)))}async handleEventBatch(t,e){const s=this.subscriptions.get(t);if(!s)return;const r=[];for(const i of e)s.receivedEventIds.has(i.id)||(s.receivedEventIds.add(i.id),r.push(i));if(s.eventCount+=r.length,s.lastEventAt=Date.now(),s.onEvent&&r.length>0)for(const i of r)s.onEvent(i)}async handleRelayEvent(t,e,s){await this.handleEvent(e,s)}async handleRelayMessage(t,e){const[s,r,...i]=e;switch(s){case"EVENT":const n=i[0];await this.handleRelayEvent(t,r,n);break;case"EOSE":await this.markEose(r,t);break;case"NOTICE":this.debug&&console.log(`Notice from ${t}:`,i[0]);break}}async handleRelayDisconnection(t){this.subscriptions.forEach(e=>{e.relayStates[t]&&(e.relayStates[t]="disconnected")})}async handleRelayManagerUpdate(){const t=this.relayManager.connectedRelays;this.subscriptions.forEach(e=>{e.relays.forEach(s=>{t.includes(s)?e.relayStates[s]="active":e.relayStates[s]="disconnected"})})}getSubscription(t){const e=this.subscriptions.get(t);return e?this.externalizeSubscription(e):void 0}getActiveSubscriptions(){return Array.from(this.subscriptions.values()).filter(t=>t.state!=="closed").map(t=>this.externalizeSubscription(t))}getSubscriptionStats(t){const e=this.subscriptions.get(t);if(!e)throw new Error(`Subscription ${t} not found`);return{relayStates:{...e.relayStates},eoseCount:e.eoseRelays.size,eventCount:e.eventCount}}generateSubscriptionId(){return Array.from({length:16},()=>Math.floor(Math.random()*16).toString(16)).join("")}validateFilters(t){if(!Array.isArray(t)||t.length===0)return{message:"Invalid filter: must be non-empty array",retryable:!1};for(const e of t){if(e==null||typeof e!="object")return{message:"Invalid filter: must be object",retryable:!1};if(e.hasOwnProperty("invalid"))return{message:"Invalid filter: contains invalid properties",retryable:!1};if(e.kinds&&!Array.isArray(e.kinds))return{message:"Invalid filter: kinds must be array",retryable:!1}}return null}async sendSubscriptionToRelays(t,e){const s=[],r=["REQ",t.id,...t.filters];if(this.relayManager.sendToRelays)for(const i of t.relays)try{await this.relayManager.sendToRelays([i],r),s.push({relay:i,success:!0,subscriptionId:t.id})}catch(n){s.push({relay:i,success:!1,error:n instanceof Error?n.message:"Unknown error",subscriptionId:t.id})}else try{this.relayManager.sendToAll?(await this.relayManager.sendToAll(r),t.relays.forEach(i=>{s.push({relay:i,success:!0,subscriptionId:t.id})})):t.relays.forEach(i=>{s.push({relay:i,success:!0,subscriptionId:t.id})})}catch(i){t.relays.forEach(n=>{s.push({relay:n,success:!1,error:i instanceof Error?i.message:"Unknown error",subscriptionId:t.id})})}return s}handleSubscriptionTimeout(t){const e=this.subscriptions.get(t);e&&(e.state="error",e.onClose&&e.onClose("Subscription timeout"),this.subscriptions.delete(t))}externalizeSubscription(t){return new Proxy(t,{get(e,s){if(!(s==="timeoutId"||s==="relayStates"||s==="eoseRelays"||s==="receivedEventIds"))return e[s]},set(e,s,r){return s==="eventCount"||s==="lastEventAt"||s==="state"?(e[s]=r,!0):!1}})}setupRelayMessageHandling(){this.relayManager.setMessageHandler((t,e)=>{this.handleRelayMessage(t,e)})}}class Tt{constructor(t,e={}){l(this,"events",new Map);l(this,"eventsByKind",new Map);l(this,"eventsByAuthor",new Map);l(this,"eventsByTag",new Map);l(this,"subscribers",new Set);l(this,"config");l(this,"lruNodes",new Map);l(this,"lruHead",null);l(this,"lruTail",null);l(this,"stats",{queryCount:0,totalQueryTime:0,evictedCount:0,createdAt:Date.now()});l(this,"decryptor",null);this.config={maxEvents:e.maxEvents||1e4,maxMemoryMB:e.maxMemoryMB||50,evictionPolicy:e.evictionPolicy||"lru",debug:!!e.debug}}setDecryptor(t){this.decryptor=t??null}async reprocessGiftWraps(){const t=[];for(const e of this.events.values())e.kind===1059&&t.push(e);for(const e of t)try{const s=await this.unwrapGiftWrap(e);s&&s.kind!==1059&&(this.events.has(s.id)||(this.events.set(s.id,s),this.updateIndexes(s),this.updateAccessTracking(s.id),this.notifySubscribers(s)))}catch{}}async addEvent(t){if(t.kind===5){try{const e=[];for(const r of t.tags)Array.isArray(r)&&r[0]==="e"&&typeof r[1]=="string"&&r[1]&&e.push(r[1]);const s=e.filter(r=>{const i=this.events.get(r);return!!i&&i.pubkey===t.pubkey});s.length>0&&(this.config.debug&&console.log("[UEC] Deletion event received – removing referenced events from cache",{deletionId:(t.id||"").substring(0,8)+"...",count:s.length,ids:s.map(r=>r.substring(0,8)+"...")}),this.deleteEventsByIds(s),this.config.debug&&console.log("[UEC] Deletion processing complete"))}catch{}this.events.set(t.id,t),this.updateIndexes(t),this.updateAccessTracking(t.id),this.notifySubscribers(t);return}if(t.kind===1059){this.events.set(t.id,t),this.updateIndexes(t),this.updateAccessTracking(t.id),this.notifySubscribers(t);try{const e=await this.unwrapGiftWrap(t);e&&await this.addEvent(e)}catch(e){console.debug("Failed to unwrap gift wrap (stored anyway):",e)}return}this.enforceCapacityLimits(),this.events.set(t.id,t),this.updateIndexes(t),this.updateAccessTracking(t.id),this.notifySubscribers(t)}deleteEventsByIds(t){for(const e of t){const s=this.events.get(e);s&&(this.removeEvent(e),console.log("[UEC] Removed event from cache",{id:e.substring(0,8)+"...",kind:s.kind}),this.notifySubscribers(s))}}query(t){const e=performance.now(),s=this.getMatchingEvents(t);s.forEach(i=>this.updateAccessTracking(i.id));const r=performance.now()-e;return this.stats.queryCount++,this.stats.totalQueryTime+=r,s}subscribe(t){return this.subscribers.add(t),()=>this.subscribers.delete(t)}clear(){this.events.clear(),this.eventsByKind.clear(),this.eventsByAuthor.clear(),this.eventsByTag.clear(),this.lruNodes.clear(),this.lruHead=null,this.lruTail=null}get size(){return this.events.size}getStatistics(){const t=Date.now(),e=this.stats.queryCount,s={};this.eventsByKind.forEach((i,n)=>{s[n]=i.size});const r=s[0]||0;return{totalEvents:this.events.size,memoryUsageMB:this.estimateMemoryUsage(),subscribersCount:this.subscribers.size,byKind:s,profileCount:r,kindIndexSize:this.eventsByKind.size,authorIndexSize:this.eventsByAuthor.size,tagIndexSize:this.eventsByTag.size,queryCount:e,hitRate:e>0?this.events.size/e*100:0,avgQueryTime:e>0?this.stats.totalQueryTime/e:0,evictedCount:this.stats.evictedCount,evictionPolicy:this.config.evictionPolicy,maxEvents:this.config.maxEvents,maxMemoryMB:this.config.maxMemoryMB,lastUpdated:t,cacheAge:t-this.stats.createdAt}}async unwrapGiftWrap(t){if(this.decryptor&&typeof this.decryptor.nip44Decrypt=="function")try{const e=await this.decryptor.nip44Decrypt(t.pubkey,t.content);if(!e)return null;const s=JSON.parse(e),r=await this.decryptor.nip44Decrypt(s.pubkey,s.content);if(!r)return null;const i=JSON.parse(r);return this.normalizeRumorFromWrap(t,i)}catch{}return null}normalizeRumorFromWrap(t,e){try{const s=t.tags.find(u=>Array.isArray(u)&&typeof u[0]=="string"),r=s&&typeof s[1]=="string"?s[1]:"",i=Array.isArray(e==null?void 0:e.tags)?e.tags:[],a=i.some(u=>Array.isArray(u)&&u[0]==="p")||!r?i:[...i,["p",r]],c={id:"",pubkey:e.pubkey,created_at:e.created_at,kind:e.kind,tags:a,content:e.content,sig:""};return c.id=_.calculateEventId(c),c}catch{return null}}updateIndexes(t){this.eventsByKind.has(t.kind)||this.eventsByKind.set(t.kind,new Set),this.eventsByKind.get(t.kind).add(t.id),this.eventsByAuthor.has(t.pubkey)||this.eventsByAuthor.set(t.pubkey,new Set),this.eventsByAuthor.get(t.pubkey).add(t.id),t.tags.forEach(e=>{const s=e[0]||"",r=e[1]||"";if(!s||!r)return;this.eventsByTag.has(s)||this.eventsByTag.set(s,new Map);const i=this.eventsByTag.get(s);i.has(r)||i.set(r,new Set),i.get(r).add(t.id)})}getMatchingEvents(t){let e;if(t.kinds&&t.kinds.length>0){const r=t.kinds.map(i=>this.eventsByKind.get(i)||new Set);e=this.unionSets(r)}if(t.authors&&t.authors.length>0){const r=t.authors.map(n=>this.eventsByAuthor.get(n)||new Set),i=this.unionSets(r);e=e?this.intersectSets([e,i]):i}Object.entries(t).forEach(([r,i])=>{if(r.startsWith("#")&&Array.isArray(i)&&i.length>0){const n=r.slice(1),a=this.eventsByTag.get(n);if(a){const c=i.map(h=>a.get(h)||new Set),u=this.unionSets(c);e=e?this.intersectSets([e,u]):u}else e=new Set}});const s=Array.from(e??new Set(Array.from(this.events.keys()))).map(r=>this.events.get(r)).filter(r=>r&&this.matchesFilter(r,t)).sort((r,i)=>i.created_at-r.created_at);return t.limit&&t.limit>0?s.slice(0,t.limit):s}matchesFilter(t,e){if(e.since&&t.created_at<e.since||e.until&&t.created_at>e.until||e.ids&&e.ids.length>0&&!e.ids.includes(t.id))return!1;if(typeof e.search=="string"&&e.search.length>0){const s=e.search.toLowerCase();if(!(t.content||"").toLowerCase().includes(s))return!1}return!0}unionSets(t){const e=new Set;return t.forEach(s=>{s.forEach(r=>e.add(r))}),e}intersectSets(t){if(t.length===0)return new Set;if(t.length===1)return t[0]||new Set;const e=new Set;return t[0].forEach(r=>{t.every(i=>i.has(r))&&e.add(r)}),e}notifySubscribers(t){this.subscribers.forEach(e=>{try{e(t)}catch(s){console.error("Subscriber callback error:",s)}})}updateAccessTracking(t){if(this.config.evictionPolicy!=="lru")return;const e=Date.now();let s=this.lruNodes.get(t);s?(this.moveToHead(s),s.timestamp=e):(s={eventId:t,prev:null,next:null,timestamp:e},this.lruNodes.set(t,s),this.addToHead(s))}addToHead(t){t.prev=null,t.next=this.lruHead,this.lruHead&&(this.lruHead.prev=t),this.lruHead=t,this.lruTail||(this.lruTail=t)}removeNode(t){t.prev?t.prev.next=t.next:this.lruHead=t.next,t.next?t.next.prev=t.prev:this.lruTail=t.prev}moveToHead(t){this.removeNode(t),this.addToHead(t)}enforceCapacityLimits(){if(this.events.size>=this.config.maxEvents&&this.evictOldest(),this.estimateMemoryUsage()>this.config.maxMemoryMB)for(;this.estimateMemoryUsage()>this.config.maxMemoryMB&&this.events.size>0;)this.evictOldest()}evictOldest(){let t;this.config.evictionPolicy==="lru"?this.lruTail&&(t=this.lruTail.eventId):t=this.events.keys().next().value,t&&this.removeEvent(t)}removeEvent(t){var r,i;const e=this.events.get(t);if(!e)return;this.stats.evictedCount++,this.events.delete(t),(r=this.eventsByKind.get(e.kind))==null||r.delete(t),(i=this.eventsByAuthor.get(e.pubkey))==null||i.delete(t),e.tags.forEach(n=>{var u,h;const a=n[0]||"",c=n[1]||"";!a||!c||(h=(u=this.eventsByTag.get(a))==null?void 0:u.get(c))==null||h.delete(t)});const s=this.lruNodes.get(t);s&&(this.removeNode(s),this.lruNodes.delete(t))}estimateMemoryUsage(){return this.events.size*1024/(1024*1024)}}class ns{constructor(){l(this,"filter",{})}ensureLimit(t){return!("limit"in t)||typeof t.limit!="number"?{...t,limit:100}:t}kinds(t){const e=this.ensureLimit({...this.filter,kinds:t});return this.clone(e)}authors(t){const e=this.ensureLimit({...this.filter,authors:t});return this.clone(e)}tags(t,e){const s=this.ensureLimit({...this.filter});return e?s[`#${t}`]=e:s[`#${t}`]=[],this.clone(s)}since(t){const e={...this.filter,since:t};return this.clone(e)}until(t){const e={...this.filter,until:t};return this.clone(e)}limit(t){const e={...this.filter,limit:t};return this.clone(e)}search(t){const e=this.ensureLimit({...this.filter,search:String(t??"")});return this.clone(e)}ids(t){const e={...this.filter,ids:t};return this.clone(e)}notes(){return this.kinds([1])}profiles(){return this.kinds([0])}reactions(){return this.kinds([7])}dms(){return this.kinds([14])}reposts(){return this.kinds([6])}}class bt{constructor(t,e){l(this,"cache");l(this,"filter");l(this,"_data");l(this,"subscribers",new Set);l(this,"unsubscribeCache");this.cache=t,this.filter=e,this._data=this.cache.query(e),this.unsubscribeCache=this.cache.subscribe(s=>{this.matchesFilter(s,e)&&this.updateData()})}subscribe(t,e){return t(this._data),this.subscribers.add(t),()=>{this.subscribers.delete(t),this.subscribers.size===0&&this.unsubscribeCache&&this.unsubscribeCache()}}get current(){return this._data}map(t){return new Zr(this,t)}updateData(){this._data=this.cache.query(this.filter),this.notifySubscribers()}notifySubscribers(){this.subscribers.forEach(t=>t(this._data))}matchesFilter(t,e){if(e.kinds&&!e.kinds.includes(t.kind)||e.authors&&!e.authors.includes(t.pubkey)||e.ids&&!e.ids.includes(t.id))return!1;if(e["#p"]&&e["#p"].length>0){const s=t.tags.filter(r=>r[0]==="p").map(r=>r[1]);if(!e["#p"].some(r=>s.includes(r)))return!1}if(e["#e"]&&e["#e"].length>0){const s=t.tags.filter(r=>r[0]==="e").map(r=>r[1]);if(!e["#e"].some(r=>s.includes(r)))return!1}if(e["#t"]&&e["#t"].length>0){const s=t.tags.filter(r=>r[0]==="t").map(r=>r[1]);if(!e["#t"].some(r=>s.includes(r)))return!1}for(const s of Object.keys(e))if(s.startsWith("#")&&s.length>1&&!["#p","#e","#t"].includes(s)){const r=s.slice(1),i=e[s];if(i&&i.length>0){const n=t.tags.filter(a=>a[0]===r).map(a=>a[1]);if(!i.some(a=>n.includes(a)))return!1}}return!0}}class Zr{constructor(t,e){l(this,"_data");l(this,"subscribers",new Set);l(this,"sourceUnsubscriber");this.sourceStore=t,this.transform=e,this._data=this.safeTransform(this.sourceStore.current,this._data),this.sourceUnsubscriber=this.sourceStore.subscribe(s=>{const r=this.safeTransform(s,this._data);this._data!==r&&(this._data=r,this.notifySubscribers())})}subscribe(t,e){return t(this._data),this.subscribers.add(t),()=>{this.subscribers.delete(t),this.subscribers.size===0&&this.sourceUnsubscriber&&this.sourceUnsubscriber()}}get current(){return this._data}notifySubscribers(){this.subscribers.forEach(t=>t(this._data))}safeTransform(t,e){try{return this.transform(t)}catch{return e}}}class Wt extends ns{constructor(t){super(),this.cache=t}clone(t){const e=new Wt(this.cache);return e.filter=t,e}execute(){return new bt(this.cache,this.filter)}}const J=class J extends ns{constructor(e,s){super();l(this,"relayUrls",[]);l(this,"autoBatchFieldName",null);l(this,"autoBatchWindowMs",0);l(this,"autoBatchMaxValues",200);l(this,"autoBatchMaxTotalLimit",1e3);this.cache=e,this.subscriptionManager=s}clone(e){const s=new J(this.cache,this.subscriptionManager);return s.filter=e,s.relayUrls=[...this.relayUrls],s}relay(e){const s=this.clone(this.filter);return s.relayUrls=[e],s}relays(e){const s=this.clone(this.filter);return s.relayUrls=e,s}async execute(){const e=this.relayUrls.length>0?this.relayUrls:void 0;if(!this.autoBatchFieldName){const n=["ids","authors","#e","#p"];for(const a of n){const c=this.filter[a];if(Array.isArray(c)&&c.length===1){this.autoBatchFieldName=a;break}}}if(this.autoBatchFieldName&&Array.isArray(this.filter[this.autoBatchFieldName])&&this.filter[this.autoBatchFieldName].length===1){const n=new Set(["kinds",this.autoBatchFieldName,"limit"]),a=this.filter;if(Object.keys(a).filter(A=>{const M=a[A];return M==null?!1:Array.isArray(M)?M.length>0:typeof M=="object"?Object.keys(M).length>0:!0}).some(A=>!n.has(A)))return await this.executeNonBatched(e);const h=this.autoBatchFieldName,d={...this.filter},f=d[h],p=String(f[0]);d[h]="__BATCH__";const g=(e||[]).slice().sort().join(","),y=JSON.stringify(d)+"::"+g;J.pendingBatches.has(y)||J.pendingBatches.set(y,{tagName:h,ids:new Set,timer:null,creating:!1,resolvers:[],targetRelays:e,baseFilter:d});const b=J.pendingBatches.get(y);b.ids.add(p);const m=new Promise(A=>{b.resolvers.push(M=>A(M??y))});if(!b.timer){const A=async()=>{if(b.timer=null,!b.creating){b.creating=!0;try{const M=Array.from(b.ids).slice(0,this.autoBatchMaxValues),P={...b.baseFilter};P[b.tagName]=M;const I=this.filter.limit??100,R=Math.min(I*M.length,this.autoBatchMaxTotalLimit);R&&(P.limit=R);const C=await this.subscriptionManager.getOrCreateSubscription([P],b.targetRelays),$=C.addListener({onEvent:N=>{this.cache.addEvent(N)}}),x=String(C.key);b.sharedKey=x,b.resolvers.forEach(N=>N(x)),b.resolvers=[],J._batchedListenerRegistry=J._batchedListenerRegistry||new Map,J._batchedListenerRegistry.set(x,{sub:C,listenerId:$})}finally{J.pendingBatches.delete(y)}}};typeof window<"u"&&typeof window.requestAnimationFrame=="function"?b.timer=window.requestAnimationFrame(()=>A()):b.timer=setTimeout(A,this.autoBatchWindowMs||0)}const w=new bt(this.cache,this.filter);let k=null;return m.then(A=>{k=A}),{id:k||y,store:w,stop:async()=>{var P;const A=J._batchedListenerRegistry,M=k||y;if(A&&A.has(M)){const I=A.get(M),R=I.sub.removeListener(I.listenerId);A.delete(M),R&&((P=this.subscriptionManager)!=null&&P.cleanupSharedSubscriptions)&&await this.subscriptionManager.cleanupSharedSubscriptions()}},isActive:()=>!0}}const s=await this.subscriptionManager.getOrCreateSubscription([this.filter],e),r=s.addListener({onEvent:n=>{this.cache.addEvent(n)}}),i=new bt(this.cache,this.filter);return{id:s.key,store:i,stop:async()=>{var a;s.removeListener(r)&&((a=this.subscriptionManager)!=null&&a.cleanupSharedSubscriptions)&&await this.subscriptionManager.cleanupSharedSubscriptions()},isActive:()=>s.hasListeners()}}async executeOnce(e){const s=(e==null?void 0:e.closeOn)||"eose",r=this.relayUrls.length>0?this.relayUrls:void 0,i=await this.subscriptionManager.getOrCreateSubscription([this.filter],r),n=i.addListener({onEvent:c=>{var u;this.cache.addEvent(c),s==="first-event"&&i.removeListener(n)&&(u=this.subscriptionManager)!=null&&u.cleanupSharedSubscriptions&&this.subscriptionManager.cleanupSharedSubscriptions().catch(()=>{})},onEose:c=>{var u;s==="eose"&&i.removeListener(n)&&(u=this.subscriptionManager)!=null&&u.cleanupSharedSubscriptions&&this.subscriptionManager.cleanupSharedSubscriptions().catch(()=>{})}}),a=new bt(this.cache,this.filter);return{id:i.key,store:a,stop:async()=>{var u;i.removeListener(n)&&((u=this.subscriptionManager)!=null&&u.cleanupSharedSubscriptions)&&await this.subscriptionManager.cleanupSharedSubscriptions()},isActive:()=>i.hasListeners()}}async executeNonBatched(e){const s=await this.subscriptionManager.getOrCreateSubscription([this.filter],e),r=s.addListener({onEvent:n=>{this.cache.addEvent(n)}}),i=new bt(this.cache,this.filter);return{id:s.key,store:i,stop:async()=>{var a;s.removeListener(r)&&((a=this.subscriptionManager)!=null&&a.cleanupSharedSubscriptions)&&await this.subscriptionManager.cleanupSharedSubscriptions()},isActive:()=>s.hasListeners()}}};l(J,"pendingBatches",new Map);let Ut=J;class os{constructor(t){l(this,"config");l(this,"updates",{});l(this,"shouldPreserveExisting",!0);l(this,"customMetadata",{});this.config=t}name(t){return this.updates.name=t,this}about(t){return this.updates.about=t,this}picture(t){return this.updates.picture=t,this}banner(t){return this.updates.banner=t,this}nip05(t){return this.updates.nip05=t,this}lud16(t){return this.updates.lud16=t,this}website(t){return this.updates.website=t,this}github(t){return this.customMetadata.github=t,this}twitter(t){return this.customMetadata.twitter=t,this}telegram(t){return this.customMetadata.telegram=t,this}metadata(t,e){return this.customMetadata[t]=e,this}preserveExisting(t=!0){return this.shouldPreserveExisting=t,this}async sign(){const t=await this.prepareProfileData(),e=await this.config.signingProvider.getPublicKey(),s={kind:0,content:JSON.stringify(t),tags:[],created_at:Math.floor(Date.now()/1e3),pubkey:e},r=_.addEventId(s),i=await this.config.signingProvider.signEvent(s);return{...r,sig:i}}async publish(){try{const t=await this.prepareProfileData();this.config.debug&&console.log("ProfileBuilder: Publishing profile:",t);const e=await this.config.signingProvider.getPublicKey(),s={kind:0,content:JSON.stringify(t),tags:[],created_at:Math.floor(Date.now()/1e3),pubkey:e},r=_.addEventId(s),i=await this.config.signingProvider.signEvent(s),n={...r,sig:i},c=(await Promise.allSettled(this.config.relayManager.relayUrls.map(async h=>{try{return await this.config.relayManager.sendToRelay(h,["EVENT",n]),{success:!0,relay:h}}catch(d){return{success:!1,relay:h,error:d instanceof Error?d.message:"Unknown error"}}}))).filter(h=>h.status==="fulfilled"&&h.value.success).map(h=>h.value.relay);return c.length>0?(this.config.debug&&console.log(`ProfileBuilder: Published to ${c.length} relays`),{success:!0,eventId:n.id}):{success:!1,error:"Failed to publish to any relay"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to publish profile"}}}async prepareProfileData(){let t={};if(this.shouldPreserveExisting){const s=await this.getCurrentProfile();s?(t={...s.metadata},this.config.debug&&console.log("ProfileBuilder: Preserving existing profile data:",t)):this.config.debug&&console.log("ProfileBuilder: No existing profile found to preserve")}const e={...t,...this.updates};return Object.keys(this.customMetadata).length>0&&Object.assign(e,this.customMetadata),e}async getCurrentProfile(){try{const t=await this.config.signingProvider.getPublicKey(),e=this.config.nostr.query().kinds([0]).authors([t]).limit(1).execute(),s=e.current;if(s&&s.length>0){const i=s[0];try{const n=JSON.parse(i.content);return{pubkey:i.pubkey,metadata:n,lastUpdated:i.created_at,eventId:i.id,isOwn:!0}}catch{return null}}await this.config.nostr.sub().kinds([0]).authors([t]).limit(1).execute(),await new Promise(i=>setTimeout(i,1e3));const r=e.current;if(r&&r.length>0){const i=r[0];try{const n=JSON.parse(i.content);return{pubkey:i.pubkey,metadata:n,lastUpdated:i.created_at,eventId:i.id,isOwn:!0}}catch{return null}}return null}catch{return null}}}class as{constructor(t){l(this,"config");l(this,"pubkeys",[]);this.config=t}get(t){return this.pubkeys=[...t],this}async execute(){if(this.pubkeys.length===0)return{profiles:new Map,success:!0,errors:new Map,totalRequested:0,totalFound:0};this.config.debug&&console.log(`ProfileBatchBuilder: Fetching ${this.pubkeys.length} profiles using base layer`);try{const t=this.config.nostr.query().kinds([0]).authors(this.pubkeys).limit(this.pubkeys.length).execute(),e=t.current,s=new Map,r=new Map;this.pubkeys.forEach(a=>{s.set(a,null)});let i=0;return e.forEach(a=>{if(a.kind===0&&this.pubkeys.includes(a.pubkey))try{const c=JSON.parse(a.content),u={pubkey:a.pubkey,metadata:c,lastUpdated:a.created_at,eventId:a.id,isOwn:!1};s.set(a.pubkey,u),i++}catch{r.set(a.pubkey,"Failed to parse profile metadata")}}),this.config.debug&&console.log(`ProfileBatchBuilder: Found ${i}/${this.pubkeys.length} profiles in cache`),i===this.pubkeys.length?{profiles:s,success:!0,errors:r,totalRequested:this.pubkeys.length,totalFound:i}:(await this.config.nostr.sub().kinds([0]).authors(this.pubkeys).limit(this.pubkeys.length).execute(),await new Promise(a=>setTimeout(a,2e3)),t.current.forEach(a=>{if(a.kind===0&&this.pubkeys.includes(a.pubkey)&&!s.get(a.pubkey))try{const c=JSON.parse(a.content),u={pubkey:a.pubkey,metadata:c,lastUpdated:a.created_at,eventId:a.id,isOwn:!1};s.set(a.pubkey,u),i++}catch{r.set(a.pubkey,"Failed to parse profile metadata")}}),this.config.debug&&console.log(`ProfileBatchBuilder: Final result - found ${i}/${this.pubkeys.length} profiles`),{profiles:s,success:!0,errors:r,totalRequested:this.pubkeys.length,totalFound:i})}catch(t){return{profiles:new Map,success:!1,errors:new Map([["batch",t instanceof Error?t.message:"Unknown error"]]),totalRequested:this.pubkeys.length,totalFound:0}}}executeReactive(){return this.config.nostr.query().kinds([0]).authors(this.pubkeys).execute().map(t=>{const e=new Map;return this.pubkeys.forEach(s=>e.set(s,null)),t.forEach(s=>{if(s.kind===0&&this.pubkeys.includes(s.pubkey))try{const r=JSON.parse(s.content);e.set(s.pubkey,{pubkey:s.pubkey,metadata:r,lastUpdated:s.created_at,eventId:s.id,isOwn:!1})}catch{}}),e})}watch(){return this.config.nostr.sub().kinds([0]).authors(this.pubkeys).execute().catch(t=>{this.config.debug&&console.warn("ProfileBatchBuilder: Failed to start watch subscription:",t)}),this.executeReactive()}}class cs{constructor(t){l(this,"config");l(this,"criteria",{});this.config=t}byNip05(t){return this.criteria.nip05Query=t.toLowerCase(),this}byName(t){return this.criteria.nameQuery=t.toLowerCase(),this}withMetadata(t,e){return this.criteria.metadataFilters||(this.criteria.metadataFilters=new Map),this.criteria.metadataFilters.set(t,e),this}verified(){return this.criteria.verifiedOnly=!0,this}limit(t){return this.criteria.limit=Math.max(1,Math.min(t,100)),this}async execute(){this.config.debug&&console.log("ProfileDiscoveryBuilder: Starting discovery with criteria:",this.criteria);try{const t={kinds:[0],limit:this.criteria.limit||50},e=[],s=new Set;return new Promise(r=>{let i=!1;const n=setTimeout(()=>{i||(i=!0,this.finalizeResults(e,r))},1e4);(async()=>{const c=await this.config.subscriptionManager.getOrCreateSubscription([t]),u=c.addListener({onEvent:async h=>{if(h.kind===0&&!s.has(h.pubkey)){s.add(h.pubkey);try{const d=await this.parseProfileEvent(h),f=await this.evaluateProfile(d);f&&(e.push(f),this.config.debug&&console.log(`ProfileDiscoveryBuilder: Found match - ${d.metadata.name||"unnamed"} (score: ${f.relevanceScore})`),this.criteria.limit&&e.length>=this.criteria.limit&&(i||(i=!0,clearTimeout(n),c.removeListener(u),this.finalizeResults(e,r))))}catch(d){this.config.debug&&console.error("ProfileDiscoveryBuilder: Error processing profile:",d)}}},onEose:()=>{i||(i=!0,clearTimeout(n),c.removeListener(u),this.finalizeResults(e,r))},onError:h=>{i||(i=!0,clearTimeout(n),c.removeListener(u),this.config.debug&&console.error("ProfileDiscoveryBuilder: Search error:",h),r(e))}})})().catch(c=>{i||(i=!0,clearTimeout(n),this.config.debug&&console.error("ProfileDiscoveryBuilder: Failed to start search:",c),r(e))})})}catch(t){return this.config.debug&&console.error("ProfileDiscoveryBuilder: Failed to start discovery:",t),[]}}async parseProfileEvent(t){try{const e=JSON.parse(t.content);return{pubkey:t.pubkey,metadata:e,lastUpdated:t.created_at,eventId:t.id,isOwn:!1}}catch{throw new Error("Failed to parse profile event")}}async evaluateProfile(t){var a,c;const e=[];let s=0,r=0,i=0;if(this.criteria.nameQuery){i++;const u=((a=t.metadata.name)==null?void 0:a.toLowerCase())||"";if(u.includes(this.criteria.nameQuery))e.push("name"),r++,u===this.criteria.nameQuery?s+=1:u.startsWith(this.criteria.nameQuery)?s+=.8:s+=.5;else return null}if(this.criteria.nip05Query){i++;const u=((c=t.metadata.nip05)==null?void 0:c.toLowerCase())||"";if(u.includes(this.criteria.nip05Query))e.push("nip05"),r++,s+=u===this.criteria.nip05Query?1:.7;else return null}if(this.criteria.metadataFilters&&this.criteria.metadataFilters.size>0)for(const[u,h]of this.criteria.metadataFilters){i++;const d=t.metadata[u];d!==void 0&&(h===void 0?(e.push(u),r++,s+=.3):typeof d=="string"&&typeof h=="string"?d.toLowerCase().includes(h.toLowerCase())&&(e.push(u),r++,s+=d.toLowerCase()===h.toLowerCase()?.8:.5):d===h&&(e.push(u),r++,s+=.8))}if(this.criteria.verifiedOnly){if(i++,t.metadata.nip05){if(await this.checkNip05Verification(t))e.push("verified"),r++,s+=.5;else if(this.criteria.verifiedOnly)return null}else if(this.criteria.verifiedOnly)return null}if(i===0&&(s=.1,r=1,i=1),i>0&&r===0)return null;const n=Math.min(1,s/Math.max(i,1));return{profile:t,matchedFields:e,relevanceScore:n}}async checkNip05Verification(t){var e;if(!t.metadata.nip05)return!1;try{const[s,r]=t.metadata.nip05.split("@");if(!s||!r)return!1;const i=new AbortController,n=setTimeout(()=>i.abort(),5e3),a=await fetch(`https://${r}/.well-known/nostr.json?name=${s}`,{signal:i.signal});return clearTimeout(n),a.ok?((e=(await a.json()).names)==null?void 0:e[s])===t.pubkey:!1}catch(s){return this.config.debug&&console.error("ProfileDiscoveryBuilder: NIP-05 verification failed:",s),!1}}finalizeResults(t,e){t.sort((r,i)=>i.relevanceScore-r.relevanceScore);const s=this.criteria.limit?t.slice(0,this.criteria.limit):t;this.config.debug&&console.log(`ProfileDiscoveryBuilder: Discovery complete - found ${s.length} matches`),e(s)}}class us{constructor(t,e){l(this,"config");l(this,"targetPubkey");l(this,"relayUrl");l(this,"petnameValue");this.config=t,this.targetPubkey=e}relay(t){return this.relayUrl=t,this}petname(t){return this.petnameValue=t,this}async publish(){try{const t=await this.config.signingProvider.getPublicKey();this.config.debug&&console.log("FollowBuilder: Adding follow for",this.targetPubkey.substring(0,16)+"...");const e=await this.getCurrentFollows();if(e.some(g=>g.pubkey===this.targetPubkey))return this.config.debug&&console.log("FollowBuilder: Already following",this.targetPubkey.substring(0,16)+"..."),{success:!1,error:"Already following this user"};const r={pubkey:this.targetPubkey,relayUrl:this.relayUrl,petname:this.petnameValue},a={kind:3,content:"",tags:[...e,r].map(g=>{const y=["p",g.pubkey];return g.petname&&!g.relayUrl?(y.push(""),y.push(g.petname)):g.relayUrl&&!g.petname?y.push(g.relayUrl):g.relayUrl&&g.petname&&(y.push(g.relayUrl),y.push(g.petname)),y}),created_at:Math.floor(Date.now()/1e3),pubkey:t},c=_.addEventId(a),u=await this.config.signingProvider.signEvent(a),h={...c,sig:u},f=(await Promise.allSettled(this.config.relayManager.relayUrls.map(async g=>{try{return await this.config.relayManager.sendToRelay(g,["EVENT",h]),{success:!0,relay:g}}catch(y){return{success:!1,relay:g,error:y instanceof Error?y.message:"Unknown error"}}}))).filter(g=>g.status==="fulfilled"&&g.value.success).map(g=>g.value.relay);return f.length>0?(this.config.debug&&console.log(`FollowBuilder: Published follow list to ${f.length} relays`),{success:!0,eventId:h.id}):{success:!1,error:"Failed to publish to any relay"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to add follow"}}}async getCurrentFollows(){try{const t=await this.config.signingProvider.getPublicKey(),e=this.config.nostr.query().kinds([3]).authors([t]).limit(1).execute(),s=e.current;if(s&&s.length>0){const i=this.parseFollowListEvent(s[0]);return this.config.debug&&console.log("FollowBuilder: Using cached follow list with",i.length,"follows"),i}this.config.debug&&console.log("FollowBuilder: No cached follow list, querying relays..."),await this.config.nostr.sub().kinds([3]).authors([t]).limit(1).execute(),await new Promise(i=>setTimeout(i,1e3));const r=e.current;if(r&&r.length>0){const i=this.parseFollowListEvent(r[0]);return this.config.debug&&console.log("FollowBuilder: Found follow list from relay with",i.length,"follows"),i}return this.config.debug&&console.log("FollowBuilder: No follow list found, using empty array"),[]}catch{return[]}}parseFollowListEvent(t){const e=[];try{for(const s of t.tags)if(s[0]==="p"&&s[1]){const r={pubkey:s[1]};s[2]&&(r.relayUrl=s[2]),s[3]&&(r.petname=s[3]),e.push(r)}return e}catch(s){return this.config.debug&&console.error("FollowBuilder: Failed to parse follow list event:",s),[]}}}class ls{constructor(t){l(this,"config");l(this,"toAdd",[]);l(this,"toRemove",[]);l(this,"baseEventId");l(this,"baseCreatedAt");this.config=t}add(t){return this.toAdd.push(...t),this}remove(t){return this.toRemove.push(...t),this}async publish(){if(this.toAdd.length===0&&this.toRemove.length===0)return{success:!1,error:"No follow operations specified"};const t=3;let e="";for(let s=0;s<t;s++)try{const r=await this.config.signingProvider.getPublicKey();this.config.debug&&console.log(`FollowBatchBuilder: Batch operation attempt ${s+1}/${t} - adding ${this.toAdd.length}, removing ${this.toRemove.length}`);const{follows:i,eventId:n,createdAt:a}=await this.getCurrentFollowsWithMetadata();if(this.baseEventId&&this.baseEventId!==n){this.config.debug&&console.log(`FollowBatchBuilder: Detected concurrent update (base: ${this.baseEventId}, current: ${n}), retrying...`),this.baseEventId=n,this.baseCreatedAt=a;continue}this.baseEventId=n,this.baseCreatedAt=a;let c=[...i];if(this.toRemove.length>0&&(c=c.filter(m=>!this.toRemove.includes(m.pubkey)),this.config.debug&&console.log(`FollowBatchBuilder: Removed ${this.toRemove.length} follows`)),this.toAdd.length>0){const m=this.toAdd.filter(w=>!c.some(k=>k.pubkey===w)).map(w=>({pubkey:w}));c.push(...m),this.config.debug&&console.log(`FollowBatchBuilder: Added ${m.length} new follows (${this.toAdd.length-m.length} were duplicates)`)}const h={kind:3,content:"",tags:c.map(m=>{const w=["p",m.pubkey];return m.petname&&!m.relayUrl?(w.push(""),w.push(m.petname)):m.relayUrl&&!m.petname?w.push(m.relayUrl):m.relayUrl&&m.petname&&(w.push(m.relayUrl),w.push(m.petname)),w}),created_at:Math.floor(Date.now()/1e3),pubkey:r},d=_.addEventId(h),f=await this.config.signingProvider.signEvent(h),p={...d,sig:f},y=(await Promise.allSettled(this.config.relayManager.relayUrls.map(async m=>{try{return await this.config.relayManager.sendToRelay(m,["EVENT",p]),{success:!0,relay:m}}catch(w){return{success:!1,relay:m,error:w instanceof Error?w.message:"Unknown error"}}}))).filter(m=>m.status==="fulfilled"&&m.value.success).map(m=>m.value.relay);if(y.length>0)return this.config.debug&&(console.log(`FollowBatchBuilder: Published batch update to ${y.length} relays on attempt ${s+1}`),console.log(`FollowBatchBuilder: Final follow list has ${c.length} follows`),console.log("FollowBatchBuilder: Event will be received via subscription and cached properly")),{success:!0,eventId:p.id};if(e="Failed to publish to any relay",s===t-1)return{success:!1,error:e}}catch(r){if(e=r instanceof Error?r.message:"Failed to publish batch update",this.config.debug&&console.warn(`FollowBatchBuilder: Attempt ${s+1} failed:`,e),s===t-1)return{success:!1,error:e};await new Promise(i=>setTimeout(i,100*(s+1)))}return{success:!1,error:e||"Max retries exceeded"}}async getCurrentFollowsWithMetadata(){try{const t=await this.config.signingProvider.getPublicKey(),e=this.config.nostr.query().kinds([3]).authors([t]).limit(1).execute(),s=e.current;if(this.config.debug&&(console.log("FollowBatchBuilder: Cache query returned",s.length,"events"),s.length>0)){const i=s[0];console.log("FollowBatchBuilder: Latest cached event:",{id:i==null?void 0:i.id,created_at:i==null?void 0:i.created_at,tags:i==null?void 0:i.tags.filter(n=>n[0]==="p")})}if(s.length>0){const i=s[0];if(i&&this.config.debug&&console.log("FollowBatchBuilder: Using cached follow list with",i.tags.filter(n=>n[0]==="p").length,"follows"),i)return{follows:this.parseFollowListEvent(i),eventId:i.id,createdAt:i.created_at}}this.config.debug&&console.log("FollowBatchBuilder: No cached follow list found, querying relays..."),await this.config.nostr.sub().kinds([3]).authors([t]).limit(1).execute(),await new Promise(i=>setTimeout(i,1e3));const r=e.current;if(r&&r.length>0){const i=r[0],n=this.parseFollowListEvent(i);return this.config.debug&&console.log("FollowBatchBuilder: Found follow list from relay with",n.length,"follows"),{follows:n,eventId:i.id,createdAt:i.created_at}}return this.config.debug&&console.log("FollowBatchBuilder: No follow list found on relays, using empty array"),{follows:[]}}catch(t){return this.config.debug&&console.error("FollowBatchBuilder: Error getting current follows:",t),{follows:[]}}}async getCurrentFollows(){const{follows:t}=await this.getCurrentFollowsWithMetadata();return t}parseFollowListEvent(t){const e=[];try{for(const s of t.tags)if(s[0]==="p"&&s[1]){const r={pubkey:s[1]};s[2]&&(r.relayUrl=s[2]),s[3]&&(r.petname=s[3]),e.push(r)}return e}catch(s){return this.config.debug&&console.error("FollowBatchBuilder: Failed to parse follow list event:",s),[]}}}class Qr{constructor(t){l(this,"baseStore");l(this,"count");l(this,"follows");this.baseStore=t,this.count=new hs(t),this.follows=t}subscribe(t,e){return this.baseStore.subscribe(t,e)}get current(){return this.baseStore.current}}class hs{constructor(t){l(this,"sourceStore");l(this,"_count",0);l(this,"subscribers",new Set);var e;this.sourceStore=t,this._count=((e=t.current)==null?void 0:e.length)||0,t.subscribe(s=>{const r=(s==null?void 0:s.length)||0;r!==this._count&&(this._count=r,this.notifySubscribers())})}subscribe(t){return t(this._count),this.subscribers.add(t),()=>{this.subscribers.delete(t)}}get current(){return this._count}notifySubscribers(){this.subscribers.forEach(t=>t(this._count))}}class ds{constructor(t){l(this,"config");this.config=t}async mine(){var e,s;if(!this.config.signingProvider)throw new Error("Cannot access own follow list: No signing provider available. Initialize signing first.");let t=(s=(e=this.config.signingProvider).getPublicKeySync)==null?void 0:s.call(e);return t||(t=await this.config.signingProvider.getPublicKey()),this.of(t)}of(t){this.config.nostr.sub().kinds([3]).authors([t]).limit(1).execute().catch(s=>{this.config.debug&&console.warn("Failed to start follow list subscription:",s)});const e=this.config.nostr.query().kinds([3]).authors([t]).limit(1).execute().map(s=>this.parseFollowListEvents(s));return new Qr(e)}followers(t){this.config.nostr.sub().kinds([3]).tags("p",[t]).limit(100).execute().catch(s=>{this.config.debug&&console.warn("Failed to start followers subscription:",s)});const e=this.config.nostr.query().kinds([3]).tags("p",[t]).limit(100).execute().map(s=>{const r=new Set;return s.forEach(i=>{i.kind===3&&i.tags.some(a=>a[0]==="p"&&a[1]===t)&&r.add(i.pubkey)}),Array.from(r)});return new hs(e)}add(t){if(!this.config.signingProvider)throw new Error("Cannot add follow: No signing provider available. Initialize signing first.");return new us({relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,debug:this.config.debug??!1,nostr:this.config.nostr},t)}async remove(t){if(!this.config.signingProvider)throw new Error("Cannot remove follow: No signing provider available. Initialize signing first.");try{const e=await this.config.signingProvider.getPublicKey();this.config.debug&&console.log("FollowsModule: Removing follow for",t.substring(0,16)+"...");const s=await this.getCurrentFollows();if(!s.some(g=>g.pubkey===t))return this.config.debug&&console.log("FollowsModule: Not following",t.substring(0,16)+"..."),{success:!1,error:"Not following this user"};const a={kind:3,content:"",tags:s.filter(g=>g.pubkey!==t).map(g=>{const y=["p",g.pubkey];return g.petname&&!g.relayUrl?(y.push(""),y.push(g.petname)):g.relayUrl&&!g.petname?y.push(g.relayUrl):g.relayUrl&&g.petname&&(y.push(g.relayUrl),y.push(g.petname)),y}),created_at:Math.floor(Date.now()/1e3),pubkey:e},c=_.addEventId(a),u=await this.config.signingProvider.signEvent(a),h={...c,sig:u},f=(await Promise.allSettled(this.config.relayManager.relayUrls.map(async g=>{try{return await this.config.relayManager.sendToRelay(g,["EVENT",h]),{success:!0,relay:g}}catch(y){return{success:!1,relay:g,error:y instanceof Error?y.message:"Unknown error"}}}))).filter(g=>g.status==="fulfilled"&&g.value.success).map(g=>g.value.relay);return f.length>0?(this.config.debug&&console.log(`FollowsModule: Published updated follow list to ${f.length} relays`),{success:!0,eventId:h.id}):{success:!1,error:"Failed to publish to any relay"}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Failed to remove follow"}}}batch(){if(!this.config.signingProvider)throw new Error("Cannot batch follow operations: No signing provider available. Initialize signing first.");return new ls({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,debug:this.config.debug??!1,nostr:this.config.nostr})}async updateSigningProvider(t){this.config.signingProvider=t}async close(){}async startFollowListSubscription(t){try{await this.config.nostr.sub().kinds([3]).authors([t]).limit(1).execute()}catch(e){this.config.debug&&console.warn(`Failed to start follow list subscription for ${t}:`,e)}}parseFollowListEvents(t){if(t.length===0)return[];const e=t[0];return!e||e.kind!==3?[]:this.parseFollowListEvent(e)}async getCurrentFollows(){try{const t=await this.config.signingProvider.getPublicKey(),e=this.config.nostr.query().kinds([3]).authors([t]).limit(1).execute(),s=e.current;if(s&&s.length>0){const i=this.parseFollowListEvent(s[0]);return this.config.debug&&console.log("FollowsModule: Using cached follow list with",i.length,"follows"),i}this.config.debug&&console.log("FollowsModule: No cached follow list found, querying relays..."),await this.config.nostr.sub().kinds([3]).authors([t]).limit(1).execute(),await new Promise(i=>setTimeout(i,1e3));const r=e.current;if(r&&r.length>0){const i=this.parseFollowListEvent(r[0]);return this.config.debug&&console.log("FollowsModule: Found follow list from relay with",i.length,"follows"),i}return this.config.debug&&console.log("FollowsModule: No follow list found on relays, using empty array"),[]}catch(t){return this.config.debug&&console.error("FollowsModule: Error getting current follows:",t),[]}}parseFollowListEvent(t){const e=[];try{for(const s of t.tags)if(s[0]==="p"&&s[1]){const r={pubkey:s[1]};s[2]&&(r.relayUrl=s[2]),s[3]&&(r.petname=s[3]),e.push(r)}return e}catch(s){return this.config.debug&&console.error("FollowsModule: Failed to parse follow list event:",s),[]}}}class gs{constructor(t){l(this,"config");l(this,"_follows");this.config=t}get(t){return this.startProfileSubscription(t),this.config.nostr.query().kinds([0]).authors([t]).limit(1).execute().map(e=>this.parseProfileEvents(e,t))}getOnce(t){try{this.config.nostr.sub().kinds([0]).authors([t]).limit(1).executeOnce({closeOn:"eose"}).catch(()=>{})}catch{}return this.config.nostr.query().kinds([0]).authors([t]).limit(1).execute().map(e=>this.parseProfileEvents(e,t))}async startProfileSubscription(t){try{await this.config.nostr.sub().kinds([0]).authors([t]).limit(1).execute()}catch(e){this.config.debug&&console.warn(`Failed to start profile subscription for ${t}:`,e)}}parseProfileEvents(t,e){if(t.length===0)return null;const s=t[0];if(s.kind!==0||s.pubkey!==e)return null;try{const r=JSON.parse(s.content);return{pubkey:s.pubkey,metadata:r,lastUpdated:s.created_at,eventId:s.id,isOwn:!1}}catch(r){return this.config.debug&&console.warn(`Failed to parse profile event for ${e}:`,r),null}}edit(){if(!this.config.signingProvider)throw new Error("Cannot edit profile: No signing provider available. Initialize signing first.");return new os({relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,debug:this.config.debug,nostr:this.config.nostr})}get follows(){return this._follows||(this._follows=new ds({subscriptionManager:this.config.subscriptionManager,relayManager:this.config.relayManager,signingProvider:this.config.signingProvider,debug:this.config.debug,nostr:this.config.nostr})),this._follows}followerCount(t){return this.follows.followers(t)}batch(){return new as({debug:this.config.debug,nostr:this.config.nostr})}discover(){return new cs({subscriptionManager:this.config.subscriptionManager,debug:this.config.debug})}chat(t){const e=this.config.nostr.getDM();return e?e.with(t):(this.config.debug&&console.warn("DM module not available - make sure signing provider is initialized"),null)}async updateSigningProvider(t){this.config.signingProvider=t,this._follows&&await this._follows.updateSigningProvider(t)}async close(){this._follows&&await this._follows.close()}}class ti{constructor(t){l(this,"list",[]);this.nostr=t}read(t){return this.list.push({url:t,mode:"read"}),this}write(t){return this.list.push({url:t,mode:"write"}),this}both(t){return this.list.push({url:t,mode:"both"}),this}urls(t,e="both"){return t.forEach(s=>this.list.push({url:s,mode:e})),this}async publish(){const t=i=>{if(!i)return i;let n=i.trim();if(!/^wss?:\/\//i.test(n)){const a=n.replace(/^[\/]+/,"");n=(/(^localhost(?::\d+)?$)|(^127\.0\.0\.1(?::\d+)?$)|((?:^|\.)local(?::\d+)?$)/i.test(a)?"ws://":"wss://")+a}return n=n.replace(/\/+$/,""),n},e=new Set,s=this.list.map(i=>({url:t(i.url),mode:i.mode})).filter(i=>i.url&&!e.has(i.url)&&(e.add(i.url),!0)),r=this.nostr.events.kind(10002).content("");for(const i of s)i.mode==="read"?r.tag("r",i.url,"read"):i.mode==="write"?r.tag("r",i.url,"write"):r.tag("r",i.url);return r.publish()}}class ei{constructor(t,e){this.nostr=t,this.debug=e}edit(){return new ti(this.nostr)}get(t){return this.nostr.sub().kinds([10002]).authors([t]).limit(1).execute().catch(()=>{}),this.nostr.query().kinds([10002]).authors([t]).limit(1).execute().map(s=>this.parseRelayList(t,s))}parseRelayList(t,e){const s=Array.isArray(e)&&e.length>0?e[0]:null,r=[];if(s&&Array.isArray(s.tags))for(const c of s.tags){if(!Array.isArray(c)||c[0]!=="r")continue;const u=c[1]||"",h=(c[2]||"").toLowerCase(),d=h==="read"?"read":h==="write"?"write":"both";u&&r.push({url:u,mode:d})}const i=r.filter(c=>c.mode==="read").map(c=>c.url),n=r.filter(c=>c.mode==="write").map(c=>c.url),a=r.filter(c=>c.mode==="both").map(c=>c.url);return{author:t,entries:r,read:i,write:n,both:a,updatedAt:s?s.created_at:null}}}class si{constructor(t,e=s=>s){this.relayList=t,this.normalizeUrl=e}async selectRelays(t,e,s){try{const r=new Set;await this.ensureLoaded(s.authorPubkey);const i=this.relayList.get(s.authorPubkey).current;if(i&&i.entries.length>0)for(const n of[...i.write,...i.both])r.add(this.normalizeUrl(n));for(const n of s.mentionedPubkeys||[]){await this.ensureLoaded(n);const a=this.relayList.get(n).current;if(a&&a.entries.length>0)for(const c of[...a.read,...a.both])r.add(this.normalizeUrl(c))}for(const n of e)r.add(this.normalizeUrl(n));return Array.from(r)}catch{return e}}async ensureLoaded(t){try{this.relayList.get(t),await new Promise(e=>setTimeout(e,200))}catch{}}}class ri{constructor(t){this.nostr=t}async check(t,e=3e3){var r,i;const s=Date.now();try{await((i=(r=this.nostr.getSubscriptionManager())==null?void 0:r.ensureConnection)==null?void 0:i.call(r,t,e));const n=Date.now()-s;return{relay:t,ok:!0,latencyMs:n}}catch(n){return{relay:t,ok:!1,error:(n==null?void 0:n.message)||"connect failed"}}}async bulkCheck(t,e=3e3){return await Promise.all(t.map(s=>this.check(s,e)))}}class ii{constructor(t){this.nostr=t}discoverForUser(t){this.nostr.sub().kinds([10002]).authors([t]).execute().catch(()=>{}),this.nostr.sub().kinds([2]).authors([t]).execute().catch(()=>{});const e=new Set,s=this.nostr.query().kinds([10002]).authors([t]).execute().current;for(const i of s||[])for(const n of i.tags)n[0]==="r"&&n[1]&&e.add(ke(n[1]));const r=this.nostr.query().kinds([2]).authors([t]).execute().current;for(const i of r||[]){const n=(i.content||"").trim();n&&e.add(ke(n))}return Array.from(e)}}function ke(o){let t=o.trim();return/^wss?:\/\//i.test(t)||(t="wss://"+t.replace(/^\/*/,"")),t.replace(/\/+$/,"")}class ni{constructor(t){this.nostr=t}async requestZap(t,e={}){const s=this.nostr.events.create().kind(9734).content(JSON.stringify({relays:e.relays||this.nostr.relays}));return s.tag("p",t),e.noteId&&s.tag("e",e.noteId),e.address&&s.tag("a",e.address),e.amountMsat&&e.amountMsat>0&&s.tag("amount",String(e.amountMsat)),await s.publish()}receiptsForNote(t){return this.nostr.sub().kinds([9735]).execute().catch(()=>{}),this.nostr.query().kinds([9735]).execute().map(e=>e.filter(s=>s.tags.some(r=>r[0]==="e"&&r[1]===t)))}receiptsForProfile(t){return this.nostr.sub().kinds([9735]).execute().catch(()=>{}),this.nostr.query().kinds([9735]).execute().map(e=>e.filter(s=>s.tags.some(r=>r[0]==="p"&&r[1]===t)))}}class re{constructor(t){l(this,"remoteSignerPubkey");l(this,"relays");l(this,"nostr");l(this,"clientTransport");l(this,"remoteUserPubkey",null);l(this,"responseCallbacks",new Map);l(this,"subscriptionStarted",!1);l(this,"requestedPermissions",[]);this.remoteSignerPubkey=t.remoteSignerPubkey,this.relays=t.relays,this.nostr=t.nostr,this.clientTransport=new ft}async ensureResponseSubscription(){if(this.subscriptionStarted)return;const t=await this.clientTransport.getPublicKey();this.nostr.sub().kinds([24133]).authors([this.remoteSignerPubkey]).tags("p",[t]).limit(200).execute().then(()=>{}).catch(()=>{}),this.nostr.query().kinds([24133]).authors([this.remoteSignerPubkey]).tags("p",[t]).since(Math.floor(Date.now()/1e3)-300).execute().subscribe(async s=>{for(const r of s)try{const i=r.content,n=await this.clientTransport.nip44Decrypt(this.remoteSignerPubkey,i),a=JSON.parse(n),c=this.responseCallbacks.get(a.id);c&&(this.responseCallbacks.delete(a.id),c(a))}catch{}}),this.subscriptionStarted=!0}async rpcRequest(t,e){await this.ensureResponseSubscription();const s=await this.clientTransport.getPublicKey(),r=Math.random().toString(36).slice(2),i={id:r,method:t,params:e},n=await this.clientTransport.nip44Encrypt(this.remoteSignerPubkey,JSON.stringify(i)),a={pubkey:s,created_at:Math.floor(Date.now()/1e3),kind:24133,tags:[["p",this.remoteSignerPubkey]],content:n},c=_.calculateEventId(a),u=await this.clientTransport.signEvent(a),h={...a,id:c,sig:u},d=new Promise((f,p)=>{const g=setTimeout(()=>{this.responseCallbacks.delete(r),p(new Error("NIP-46 request timeout"))},1e4);this.responseCallbacks.set(r,y=>{clearTimeout(g),y.error?p(new Error(y.error)):f(y.result)})});return await this.nostr.publishSigned(h),await d}async createClientToken(t){const e=await this.clientTransport.getPublicKey(),s=(t!=null&&t.relays&&t.relays.length?t.relays:this.relays)||[],r=new URLSearchParams;for(const n of s)r.append("relay",encodeURIComponent(n));t!=null&&t.perms&&t.perms.length&&(r.set("perms",t.perms.join(",")),this.requestedPermissions=t.perms.slice()),t!=null&&t.name&&r.set("name",t.name),t!=null&&t.secret&&r.set("secret",t.secret);const i=r.toString();return`nostrconnect://${e}${i?`?${i}`:""}`}setRequestedPermissions(t){this.requestedPermissions=t.slice()}async getPublicKey(){if(this.remoteUserPubkey)return this.remoteUserPubkey;const t=await this.rpcRequest("get_public_key",[]);return this.remoteUserPubkey=String(t),this.remoteUserPubkey}getPublicKeySync(){return this.remoteUserPubkey}async signEvent(t){const e=await this.rpcRequest("sign_event",[JSON.stringify({content:t.content,kind:t.kind,tags:t.tags,created_at:t.created_at})]);try{const s=typeof e=="string"?JSON.parse(e):e;if(!s||!s.sig)throw new Error("Invalid response from remote signer");return s.sig}catch{throw new Error("Failed to parse remote signature")}}}class oi{constructor(t={}){l(this,"relayManager");l(this,"subscriptionManager");l(this,"cache");l(this,"signingProvider");l(this,"signingMethod");l(this,"config");l(this,"giftWrapSubscriptionActive",!1);l(this,"cachedMyPubkey",null);l(this,"events");l(this,"dm");l(this,"universalDM");l(this,"social");l(this,"_comments");l(this,"_lists");l(this,"_labels");l(this,"_channels");l(this,"_communities");l(this,"_content");l(this,"_files");l(this,"_profile");l(this,"_relayList");l(this,"relayRouter");l(this,"_relayDiscovery");l(this,"_relayHealth");l(this,"_zap");var s;const e={relays:t.relays??Re,debug:t.debug??!1,retryAttempts:t.retryAttempts??Z.RETRY_ATTEMPTS,retryDelay:t.retryDelay??Z.RETRY_DELAY,timeout:t.timeout??Z.PUBLISH_TIMEOUT,routing:t.routing??"none"};if(t.signingProvider&&(e.signingProvider=t.signingProvider),this.config=e,this.config.debug&&console.log("🔥 NostrUnchained v0.1.0-FIX (build:",new Date().toISOString().substring(0,19)+"Z)"),this.relayManager=new Ce(this.config.relays,{debug:this.config.debug,publishTimeout:this.config.timeout}),this.subscriptionManager=new is(this.relayManager),this.relayManager.configureAuth({authEventFactory:async({relay:r,challenge:i})=>{if(!this.signingProvider)throw new Error("No signing provider for AUTH");const a={pubkey:await this.signingProvider.getPublicKey(),created_at:Math.floor(Date.now()/1e3),kind:22242,tags:[["relay",r],["challenge",i]],content:""},c=_.calculateEventId(a),u=await this.signingProvider.signEvent(a);return{...a,id:c,sig:u}},onAuthStateChange:(r,i)=>{this.config.debug&&console.log(`NIP-42 state for ${r}:`,i)}}),this.events=new Ne(this),t.signingProvider){this.signingProvider=t.signingProvider;try{this.signingMethod=(s=t.signingProvider)!=null&&s.isExtension||t.signingProvider.constructor.name.includes("Extension")?"extension":"temporary"}catch{this.signingMethod="temporary"}this.cache=new Tt("",{debug:this.config.debug}),this._initializeCache().catch(r=>{this.config.debug&&console.log("⚠️ Cache initialization with private key failed:",r)}),this.config.debug&&console.log("🎯 NostrUnchained initialized with PROVIDED signing provider - Everything ready!")}else this.cache=new Tt("",{debug:this.config.debug}),this.config.debug&&console.log("🚨 NostrUnchained initialized WITHOUT signing provider - will auto-detect later");this.dm=new Ue({subscriptionManager:this.subscriptionManager,relayManager:this.relayManager,signingProvider:this.signingProvider,debug:this.config.debug,parent:this}),this.social=new xr({nostr:this,debug:this.config.debug}),this.config.debug&&console.log("NostrUnchained initialized with relays:",this.config.relays),this.config.routing==="nip65"&&(this.relayRouter=new si(this.relayList,i=>this.normalizeRelayUrl(i)),(async()=>{try{if(!this.signingProvider)return;const i=await this.signingProvider.getPublicKey();await this.sub().kinds([10002]).authors([i]).limit(1).execute();const n=this.query().kinds([10002]).authors([i]).limit(1).execute();if(n&&typeof n.subscribe=="function"){let a=!0;const c=n.subscribe(u=>{var d,f;try{if(!a)return;a=!1,c&&c()}catch{}const h=Array.isArray(u)&&u.length?u[0]:null;if(h&&Array.isArray(h.tags)){const p=h.tags.filter(g=>g[0]==="r").map(g=>g[1]).filter(Boolean);try{(f=(d=this.relayRouter)==null?void 0:d.setAuthorRelayHints)==null||f.call(d,i,p)}catch{}}})}}catch{}})())}get nip46(){const t=this;return{startPairing:async e=>{const s=new re({remoteSignerPubkey:e.remoteSignerPubkey||"",relays:e.relays,nostr:t,debug:t.getDebug()}),{uri:r,secret:i,clientPub:n}=await s.createClientTokenWithSecret({name:e.name,perms:e.perms,relays:e.relays,url:e.url,image:e.image});if(t.getDebug()&&console.log("[NIP46] Pairing started – listening on relays:",e.relays,"clientPub:",n.substring(0,8)),e.remoteSignerPubkey)try{t.getDebug()&&console.log("[NIP46] Sending connect RPC to remote-signer:",e.remoteSignerPubkey.substring(0,8)),(async()=>{try{await s.connect(e.perms,i)}catch(c){t.getDebug()&&console.warn("[NIP46] connect RPC failed (non-fatal):",c)}})()}catch{}return{uri:r,secret:i,clientPub:n,relays:e.relays.slice(),onAck:async(c=15e3)=>(t.getDebug()&&console.log("[NIP46] Awaiting ACK/secret on relays:",e.relays),await s.waitForConnectAck(i,c),t.getDebug()&&console.log("[NIP46] ACK received"),!0),useAsSigner:async()=>{await t.initializeSigning(s);const c=await t.getPublicKey();return t.getDebug()&&console.log("[NIP46] Remote signer initialized. userPub:",c.substring(0,8)),c},close:async()=>{}}}}}async _initializeCache(){if(this.signingProvider)try{this.cache||(this.cache=new Tt("",{}));try{this.signingProvider.capabilities&&(await this.signingProvider.capabilities()).nip44Decrypt&&this.cache.setDecryptor&&this.cache.setDecryptor({nip44Decrypt:this.signingProvider.nip44Decrypt.bind(this.signingProvider)})}catch{}await this.cache.reprocessGiftWraps();const t=await this.signingProvider.getPublicKey();this.universalDM=new Mr(this,t),this.config.debug&&console.log("🎯 Universal Cache and Universal DM Module initialized");try{this.signingProvider.capabilities&&(await this.signingProvider.capabilities()).nip44Decrypt&&this.cache.setDecryptor&&this.cache.setDecryptor({nip44Decrypt:this.signingProvider.nip44Decrypt.bind(this.signingProvider)})}catch{}}catch{this.cache||(this.cache=new Tt("",{}))}}get profile(){return this._profile||(this._profile=new gs({relayManager:this.relayManager,subscriptionManager:this.subscriptionManager,signingProvider:this.signingProvider,eventBuilder:new _,cache:this.cache,debug:this.config.debug,nostr:this})),this._profile}get relayList(){return this._relayList||(this._relayList=new ei(this)),this._relayList}get relayDiscovery(){return this._relayDiscovery||(this._relayDiscovery=new ii(this)),this._relayDiscovery}get relayHealth(){return this._relayHealth||(this._relayHealth=new ri(this)),this._relayHealth}get zaps(){return this._zap||(this._zap=new ni(this)),this._zap}get lists(){return this._lists||(this._lists=new Fr(this)),this._lists}get labels(){return this._labels||(this._labels=new Or(this)),this._labels}get channels(){return this._channels||(this._channels=new zr(this)),this._channels}get comments(){return this._comments||(this._comments=new Dr(this)),this._comments}get communities(){return this._communities||(this._communities=new Yr(this)),this._communities}get content(){return this._content||(this._content=new rs(this,this.config.debug)),this._content}get files(){return this._files||(this._files=new Jr(this)),this._files}get relays(){return this.config.relays}get connectedRelays(){return this.relayManager.connectedRelays}async initializeSigning(t){var e;if(this.signingProvider&&!t){this.config.debug&&console.log("🚫 Signing already initialized - skipping (Perfect DX!)");return}if(t){this.signingProvider=t;try{this.signingMethod=t!=null&&t.isExtension||t.constructor.name.includes("Extension")?"extension":"temporary"}catch{this.signingMethod="temporary"}}else if(this.config.signingProvider){this.signingProvider=this.config.signingProvider;try{this.signingMethod=(e=this.config.signingProvider)!=null&&e.isExtension||this.config.signingProvider.constructor.name.includes("Extension")?"extension":"temporary"}catch{this.signingMethod="temporary"}}else{const{provider:s,method:r}=await xe.createBestAvailable();this.signingProvider=s,this.signingMethod=r}this.cachedMyPubkey=null,await this._initializeCache();try{this.signingProvider&&this.signingProvider.nip44Decrypt&&this.cache.setDecryptor&&(this.cache.setDecryptor({nip44Decrypt:this.signingProvider.nip44Decrypt.bind(this.signingProvider)}),this.config.debug&&console.log("🔐 Using signer-provided NIP-44 decrypt capability"))}catch{}await this.dm.updateSigningProvider(this.signingProvider),await this.social.updateSigningProvider(this.signingProvider),this._profile&&await this._profile.updateSigningProvider(this.signingProvider),this.config.debug&&console.log(`Initialized signing with method: ${this.signingMethod}`);try{const s=this.getSigningInfo().method;typeof window<"u"&&(window.dispatchEvent(new CustomEvent("nostr:signer-changed",{detail:{method:s}})),window.dispatchEvent(new CustomEvent("nostr:auth-changed",{detail:{method:s}})))}catch{}try{await this.startUniversalGiftWrapSubscription()}catch{}}async connect(){try{if(await this.relayManager.connect(),this.config.debug){const t=this.relayManager.getStats();console.log("Relay connection stats:",t)}}catch(t){throw F.handleConnectionError("relays",t)}}async startUniversalGiftWrapSubscription(){if(this.giftWrapSubscriptionActive){this.config.debug&&console.log("🎁 Gift wrap subscription already active - skipping");return}if(!this.signingProvider){this.config.debug&&console.log("⚠️ Cannot start gift wrap subscription - no signing provider");return}try{this.relayManager.connectedRelays.length===0&&await this.connect();const t=await this.signingProvider.getPublicKey();(await this.subscriptionManager.getOrCreateSubscription([{kinds:[1059],"#p":[t],limit:100}],this.config.relays)).addListener({onEvent:async s=>{try{await this.cache.addEvent(s)}catch{}this.config.debug&&console.log(`🎁 Received gift wrap event: ${s.id.substring(0,8)}...`)},onEose:()=>{this.config.debug&&console.log("🎁 Gift wrap initial sync completed")}}),this.giftWrapSubscriptionActive=!0,this.config.debug&&console.log("🎁 Universal gift wrap subscription started successfully")}catch(t){throw console.error("Failed to start gift wrap subscription:",t),t}}async disconnect(){await this.relayManager.disconnect()}async publishToRelays(t,e){if(!this.signingProvider)throw new Error("No signing provider available. Call initializeSigning() first.");const s=_.validateEvent(t);if(!s.valid)throw new Error(`Invalid event: ${s.errors.join(", ")}`);const r=_.calculateEventId(t),i=await this.signingProvider.signEvent(t),n={...t,id:r,sig:i},a=await this.relayManager.publishToRelays(n,e),c=a.some(u=>u.success);return{success:c,eventId:c?n.id:void 0,event:c?n:void 0,relayResults:a,timestamp:Date.now(),error:c?void 0:{message:"Failed to publish to any relay",retryable:!0}}}async publishToRelaysSmart(t,e,s){if(!this.signingProvider)throw new Error("No signing provider available. Call initializeSigning() first.");const r=_.validateEvent(t);if(!r.valid)throw new Error(`Invalid event: ${r.errors.join(", ")}`);const i=_.calculateEventId(t),n=await this.signingProvider.signEvent(t),a={...t,id:i,sig:n},c=Array.from(new Set(e.filter(Boolean))),u=new Set(this.relayManager.relayUrls),h=c.filter(y=>!u.has(y));h.length&&this.relayManager.addRelays(h,{temporary:!0}),await this.relayManager.ensureConnected(c);const d=await this.relayManager.publishToRelays(a,c,s),f=d.some(y=>y.success),p=c.filter(y=>h.includes(y));if(p.length){try{await this.relayManager.disconnectRelays(p)}catch{}try{this.relayManager.removeRelays(p)}catch{}}const g={success:f,eventId:f?a.id:void 0,event:f?a:void 0,relayResults:d,timestamp:Date.now(),error:f?void 0:{message:"Failed to publish to any relay",retryable:!0}};return this.config.debug&&(g.debug={targetRelays:c}),g}async publish(t,e=1){const s=Date.now();if(!this.signingProvider)throw new Error("No signing provider available. Call initializeSigning() first.");const r=typeof t=="string"?await _.createEvent(t,await this.getPublicKey(),{kind:e}):t,i=_.validateEvent(r);if(!i.valid)throw new Error(`Invalid event: ${i.errors.join(", ")}`);const n=_.calculateEventId(r),a=await this.signingProvider.signEvent(r),c={...r,id:n,sig:a};let u=null;try{u=await this.autoSelectRelaysForEvent(r)}catch{}if(Array.isArray(u)&&u.length>0)return await this.publishToRelaysSmart(r,u);this.isRoutingSensitiveEventKind(r.kind)&&this.config.debug&&console.warn(`⚠️ Routing-sensitive event (kind ${r.kind}) without specific relay markers. Falling back to connected relays. Consider adding explicit relay markers for better delivery.`);let h=this.relayManager.connectedRelays;try{if(this.relayRouter&&this.config.routing==="nip65"){const y=c.pubkey,b=this.extractMentionedPubkeys(c);h=await this.relayRouter.selectRelays(c,h,{authorPubkey:y,mentionedPubkeys:b})}}catch{}const d=await this.relayManager.publishToRelays(c,h),f=Date.now()-s,p=d.some(y=>y.success),g={success:p,eventId:p?c.id:void 0,event:p?c:void 0,relayResults:d,timestamp:Date.now(),error:p?void 0:{message:"Failed to publish to any relay",retryable:!0,suggestion:"Check relay connectivity or try different relays"}};return this.config.debug&&(g.debug={connectionAttempts:this.relayManager.connectedRelays.length,relayLatencies:d.reduce((y,b)=>(y[b.relay]=0,y),{}),totalTime:f,signingMethod:this.signingMethod==="extension"?"extension":"temporary",targetRelays:h}),g}async publishSigned(t){const e=Date.now();if(!t.id||!t.sig||!t.pubkey)throw new Error("Invalid signed event: Missing required fields (id, sig, pubkey)");let s=null;try{s=await this.autoSelectRelaysForEvent(t)}catch{}if(Array.isArray(s)&&s.length>0)return await this.publishSignedToRelaysSmart(t,s);if(this.isRoutingSensitiveEventKind(t.kind))throw new Error("No target relay known for routing-sensitive event. Ensure markers (NIP-72) or recipient relay list (NIP-65) are available.");let r=this.relayManager.connectedRelays;try{if(this.relayRouter&&this.config.routing==="nip65"){const u=t.pubkey,h=this.extractMentionedPubkeys(t);r=await this.relayRouter.selectRelays(t,r,{authorPubkey:u,mentionedPubkeys:h})}}catch{}const i=await this.relayManager.publishToRelays(t,r),n=Date.now()-e,a=i.some(u=>u.success),c={success:a,eventId:a?t.id:void 0,event:a?t:void 0,relayResults:i,timestamp:Date.now(),error:a?void 0:{message:"Failed to publish to any relay",retryable:!0,suggestion:"Check relay connectivity or try different relays"}};return this.config.debug&&(c.debug={connectionAttempts:this.relayManager.connectedRelays.length,relayLatencies:i.reduce((u,h)=>(u[h.relay]=0,u),{}),totalTime:n,signingMethod:"temporary",targetRelays:r}),c}async autoSelectRelaysForEvent(t){var e,s;try{if(!t||!Array.isArray(t.tags))return null;if(t.kind===34550){const r=(e=(t.tags||[]).find(n=>n[0]==="relay"&&n[2]==="author"))==null?void 0:e[1];if(r)return[r];const i=(s=(t.tags||[]).find(n=>n[0]==="relay"))==null?void 0:s[1];return i?[i]:null}if(t.kind===1111){const r=(t.tags||[]).find(n=>n[0]==="A"||n[0]==="a"),i=Array.isArray(r)?r[1]:null;if(i&&i.startsWith("34550:")){const n=i.split(":"),a=String(n[1]||""),c=String(n[2]||"");try{const u=await this.communities.resolveRelays(a,c,800);if(u!=null&&u.requests)return[u.requests]}catch{}}return Array.isArray(r)&&typeof r[2]=="string"&&r[2]?[r[2]]:null}if(t.kind===4550){const r=(t.tags||[]).find(n=>n[0]==="a"),i=Array.isArray(r)?r[1]:null;if(i&&i.startsWith("34550:")){const[n,a,c]=i.split(":"),u=String(a||""),h=String(c||"");try{const d=await this.communities.resolveRelays(u,h,800);if(d!=null&&d.approvals)return[d.approvals]}catch{}}return Array.isArray(r)&&typeof r[2]=="string"&&r[2]?[r[2]]:null}if(t.kind===4||t.kind===14||t.kind===1059){const r=(t.tags||[]).filter(n=>Array.isArray(n)&&n[0]==="p"&&typeof n[1]=="string").map(n=>String(n[1])).filter(n=>!!n);if(!r.length)return null;const i=await this.resolveRecipientsPreferredRelays(r,1e3);return i.length?i:null}return null}catch{return null}}isRoutingSensitiveEventKind(t){return t===34550||t===1111||t===4550||t===4||t===14||t===1059}async resolveRecipientsPreferredRelays(t,e=1e3){const s=new Set;for(const r of Array.from(new Set(t||[])))try{const i=await this.resolveRelayListForAuthor(r,e);[...i.read||[],...i.both||[],...i.write||[]].forEach(n=>{n&&s.add(String(n))})}catch{}return Array.from(s)}async resolveRelayListForAuthor(t,e=1e3){try{const s=this.relayList.get(t);let r=s.current;return r&&typeof r=="object"&&(Array.isArray(r.read)||Array.isArray(r.write)||Array.isArray(r.both))?{read:r.read||[],write:r.write||[],both:r.both||[]}:await new Promise((i,n)=>{let a=!1,c;try{const u=s.subscribe(h=>{if(!a&&h&&(Array.isArray(h.read)||Array.isArray(h.write)||Array.isArray(h.both))){a=!0;try{clearTimeout(c)}catch{}try{u&&u()}catch{}i({read:h.read||[],write:h.write||[],both:h.both||[]})}});c=setTimeout(()=>{if(!a){a=!0;try{u&&u()}catch{}n(new Error("Timeout resolving relay list"))}},Math.max(200,e))}catch(u){n(u)}})}catch(s){throw s}}async publishSignedToRelaysSmart(t,e,s){if(!(t!=null&&t.id)||!(t!=null&&t.sig)||!(t!=null&&t.pubkey))throw new Error("Invalid signed event: Missing required fields (id, sig, pubkey)");const r=Array.from(new Set(e.filter(Boolean))),i=new Set(this.relayManager.relayUrls),n=r.filter(d=>!i.has(d));n.length&&this.relayManager.addRelays(n,{temporary:!0}),await this.relayManager.ensureConnected(r);const a=await this.relayManager.publishToRelays(t,r,s),c=a.some(d=>d.success),u=(s==null?void 0:s.removeAfter)??!0?r.filter(d=>n.includes(d)):[];if(u.length){try{await this.relayManager.disconnectRelays(u)}catch{}try{this.relayManager.removeRelays(u)}catch{}}const h={success:c,eventId:c?t.id:void 0,event:c?t:void 0,relayResults:a,timestamp:Date.now(),error:c?void 0:{message:"Failed to publish to any relay",retryable:!0}};return this.config.debug&&(h.debug={targetRelays:r}),h}extractMentionedPubkeys(t){const e=[];for(const s of t.tags||[])Array.isArray(s)&&s[0]==="p"&&s[1]&&/^[0-9a-f]{64}$/i.test(s[1])&&e.push(s[1].toLowerCase());return e}normalizeRelayUrl(t){if(!t)return t;let e=t.trim();return/^wss?:\/\//i.test(e)||(e="wss://"+e.replace(/^\/*/,"")),e=e.replace(/\/+$/,""),e}async getPublicKey(){if(!this.signingProvider)throw new Error("No signing provider available. Call initializeSigning() first.");return this.cachedMyPubkey||(this.cachedMyPubkey=await this.signingProvider.getPublicKey()),this.cachedMyPubkey}get me(){return this.cachedMyPubkey}async getMe(){try{return await this.getPublicKey()}catch{return null}}getRelayStats(){return this.relayManager.getStats()}getDebug(){try{return!!this.config.debug}catch{return!1}}getStats(){return this.getRelayStats()}query(){return new Wt(this.cache)}sub(){return new Ut(this.cache,this.subscriptionManager)}getCache(){return this.cache}get eventCache(){return this.cache}getCacheStatistics(){return this.cache.getStatistics()}getSubscriptionManager(){return this.subscriptionManager}getDM(){return this.universalDM}async hasExtension(){try{return await Et.isAvailable()}catch{return!1}}async useExtensionSigner(){try{const t=new Et;return await this.initializeSigning(t),{success:!0,pubkey:await t.getPublicKey()}}catch(t){return{success:!1,error:t.message}}}async useLocalKeySigner(){try{const t=new ft;return await this.initializeSigning(t),{success:!0,pubkey:await t.getPublicKey()}}catch(t){return{success:!1,error:t.message}}}async useNostrConnect(t){try{const e=new re({remoteSignerPubkey:t.remoteSignerPubkey,relays:t.relays,nostr:this}),{uri:s,secret:r,clientPub:i}=await e.createClientTokenWithSecret({name:t.name,perms:t.perms,relays:t.relays,url:t.url,image:t.image}),n=typeof t.waitForAckMs=="number"?t.waitForAckMs:0;if(n&&n>0)try{await e.waitForConnectAck(r,n)}catch{}return{success:!0,client:{uri:s,secret:r,clientPub:i}}}catch(e){return{success:!1,error:e.message}}}getSigningInfo(){return{method:this.signingMethod??"unknown",pubkey:this.me}}async useCustomSigner(t){try{return await this.initializeSigning(t),{success:!0,pubkey:await t.getPublicKey()}}catch(e){return{success:!1,error:e.message}}}async updateSigningProvider(t){var e;this.signingProvider=t;try{if((t==null?void 0:t.isExtension)===!0)this.signingMethod="extension";else{const r=((e=t==null?void 0:t.constructor)==null?void 0:e.name)||"";this.signingMethod=r.includes("Extension")?"extension":"temporary"}}catch{this.signingMethod="temporary"}this.dm&&await this.dm.updateSigningProvider(t),this.social&&await this.social.updateSigningProvider(t),this._profile&&await this._profile.updateSigningProvider(t),this.config.debug&&console.log("🔑 NostrUnchained signing provider updated")}getDebugInfo(){return{signingMethod:this.signingMethod==="extension"?"extension":"temporary",cacheSize:this.cache.getStatistics().totalEvents,giftWrapActive:this.giftWrapSubscriptionActive}}}const Ae={jpg:"image/jpeg",jpeg:"image/jpeg",png:"image/png",gif:"image/gif",webp:"image/webp",avif:"image/avif"},_e={mp4:"video/mp4",webm:"video/webm",mov:"video/quicktime",m4v:"video/x-m4v"},Me={mp3:"audio/mpeg",ogg:"audio/ogg",wav:"audio/wav",flac:"audio/flac",m4a:"audio/mp4"};function ai(o){try{const s=new URL(o).pathname.toLowerCase().match(/\.([a-z0-9]+)$/i),r=(s==null?void 0:s[1])||"";if(Ae[r])return Ae[r];if(_e[r])return _e[r];if(Me[r])return Me[r]}catch{}}function ci(o){const t=[];if(t.push(`url ${o.url}`),o.mimeType&&t.push(`m ${o.mimeType}`),o.blurhash&&t.push(`blurhash ${o.blurhash}`),o.dim&&t.push(`dim ${o.dim}`),o.alt&&t.push(`alt ${o.alt}`),o.sha256&&t.push(`x ${o.sha256}`),o.fallbacks&&o.fallbacks.length)for(const e of o.fallbacks)t.push(`fallback ${e}`);return["imeta",...t]}function ui(o){const t=[];for(const e of o.tags||[]){if(e[0]!=="imeta")continue;const s={url:""};for(let r=1;r<e.length;r++){const i=e[r],n=i.indexOf(" ");if(n<=0)continue;const a=i.slice(0,n),c=i.slice(n+1);switch(a){case"url":s.url=c;break;case"m":s.mimeType=c;break;case"blurhash":s.blurhash=c;break;case"dim":s.dim=c;break;case"alt":s.alt=c;break;case"x":s.sha256=c;break;case"fallback":s.fallbacks||(s.fallbacks=[]),s.fallbacks.push(c);break}}s.url&&t.push(s)}return t}const li=Object.freeze(Object.defineProperty({__proto__:null,DMConversation:Oe,DMModule:Ue,DMRoom:Be,EphemeralKeyManager:xt,GiftWrapCreator:Ft,GiftWrapProtocol:at,NIP44Crypto:X,SealCreator:Lt,TimestampRandomizer:Qt},Symbol.toStringTag,{value:"Module"})),hi=Object.freeze(Object.defineProperty({__proto__:null,FollowBatchBuilder:ls,FollowBuilder:us,FollowsModule:ds,ProfileBatchBuilder:as,ProfileBuilder:os,ProfileDiscoveryBuilder:cs,ProfileModule:gs},Symbol.toStringTag,{value:"Module"}));function di(o){return typeof globalThis.btoa=="function"?globalThis.btoa(o):Buffer.from(o,"utf8").toString("base64")}async function fs(o,t){const e=t.method.toUpperCase(),s=t.url;let r;t.payload&&typeof t.payload=="string"?r=D(et(new TextEncoder().encode(t.payload))):t.payload&&(r=D(et(t.payload)));const i=o.events.create().kind(27235).content("").tag("u",s).tag("method",e);return r&&i.tag("payload",r),await(await i.sign()).build()}function ys(o){const t=JSON.stringify(o);return`Nostr ${di(t)}`}async function ps(o,t){const e=await fs(o,t),s=ys(e);return{event:e,header:s}}class gi{constructor(t){this.nostr=t}async discover(t){const e=new URL("/.well-known/nostr/nip96.json",t).toString(),s=await fetch(e);if(!s.ok)throw new Error(`nip96.json fetch failed: ${s.status}`);const r=await s.json();if(!r.api_url||typeof r.api_url!="string")throw new Error("Invalid nip96.json: missing api_url");return r}async upload(t,e,s={}){var p;const r=await this.discover(t),i=r.api_url||r.delegated_to_url||t,n=e instanceof Uint8Array?e:new Uint8Array(e),a=new FormData,c=new Blob([n],{type:s.contentType||"application/octet-stream"});a.append("file",c,s.filename||"upload.bin"),s.caption&&a.append("caption",s.caption),s.alt&&a.append("alt",s.alt);const u={method:"POST",body:a,headers:{}};if(s.requireAuth){const{header:g}=await ps(this.nostr,{method:"POST",url:i,payload:n});u.headers.Authorization=g}const h=await fetch(i,u),d=await h.json(),f={status:d.status||(h.ok?"success":"error"),message:d.message};if((p=d.nip94_event)!=null&&p.tags){f.nip94_event=d.nip94_event;const g=d.nip94_event.tags,y=g.find(w=>w[0]==="url"),b=g.find(w=>w[0]==="ox"),m=g.find(w=>w[0]==="x");f.url=y==null?void 0:y[1],f.ox=b==null?void 0:b[1],f.x=m==null?void 0:m[1]}return f}async publishNip94(t){const e=this.nostr.events.create().kind(1063).content(t.content||"");for(const s of t.tags||[])e.tag(s[0],...s.slice(1));return await e.publish()}}const fi="0.2.0";exports.DEFAULT_RELAYS=Re;exports.DM=li;exports.EVENT_KINDS=Jt;exports.ErrorHandler=F;exports.EventBuilder=_;exports.EventsModule=Ne;exports.ExtensionSigner=Et;exports.FeedStoreImpl=Kt;exports.FluentEventBuilder=Ct;exports.LocalKeySigner=ft;exports.Nip96Client=gi;exports.NostrConnectSigner=re;exports.NostrUnchained=oi;exports.Profile=hi;exports.QueryBuilder=Wt;exports.QuickSigner=Bs;exports.RelayManager=Ce;exports.SigningProviderFactory=xe;exports.SubBuilder=Ut;exports.SubscriptionManager=is;exports.TemporarySigner=Us;exports.VERSION=fi;exports.buildHttpAuthEvent=fs;exports.buildHttpAuthHeader=ys;exports.buildImetaTag=ci;exports.createFeed=Ws;exports.createFeedFromFilter=qs;exports.createFeedFromQuery=zs;exports.createNaddr=ts;exports.createNevent=kr;exports.createNprofile=Sr;exports.decode=yt;exports.derived=T;exports.guessMimeType=ai;exports.hexToNote=Er;exports.hexToNpub=wr;exports.hexToNsec=vr;exports.isNostrUri=Ge;exports.isValidHexKey=es;exports.isValidNote=_r;exports.isValidNpub=ss;exports.isValidNsec=Ar;exports.naddrEncode=ue;exports.neventEncode=ce;exports.noteEncode=Xe;exports.noteToHex=Qe;exports.nprofileEncode=ae;exports.npubEncode=Je;exports.npubToHex=le;exports.nsecEncode=Ye;exports.nsecToHex=Ze;exports.parseImetaTags=ui;exports.parseNostrUri=mr;exports.setDefaultSubscriptionManager=Hs;exports.signHttpAuth=ps;exports.toNostrUri=br;exports.writable=rt;
